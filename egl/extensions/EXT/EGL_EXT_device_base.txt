Name

    EXT_device_base

Name Strings

    EGL_EXT_device_base

Contributors

    James Jones
    Daniel Kartch

Contacts

    James Jones, NVIDIA  (jajones 'at' nvidia.com)

Status

    Complete

Version

    Version 8 - May 16th, 2014

Number

    EGL Extension #72

Extension Type

    EGL client extension

Dependencies

    Written against the wording of EGL 1.5.

    Requires EGL 1.5 or an earlier verison of EGL with the
    EGL_EXT_client_extensions extension.

Overview

    Increasingly, EGL and its client APIs are being used in place of
    "native" rendering APIs to implement the basic graphics
    functionality of native windowing systems.  This creates demand
    for a method to initialize EGL displays and surfaces directly on
    top of native GPU or device objects rather than native window
    system objects.  The mechanics of enumerating the underlying
    native devices and constructing EGL displays and surfaces from
    them have been solved in various platform and implementation-
    specific ways.  The EGL device family of extensions offers a
    standardized framework for bootstrapping EGL without the use of
    any underlying "native" APIs or functionality.

    This extension defines the first step of this bootstrapping
    process: Device enumeration.

New Types

    This is the type of a handle that represents an EGLDeviceEXT
    object.

        typedef void* EGLDeviceEXT;

    If EGL 1.5 is not supported, the following type is added, as
    defined in the EGL 1.5 specification:

        typedef intptr_t EGLAttrib;

New Functions

    EGLBoolean eglQueryDeviceAttribEXT(EGLDeviceEXT device,
                                       EGLint attribute,
                                       EGLAttrib *value);

    const char *eglQueryDeviceStringEXT(EGLDeviceEXT device,
                                        EGLint name);

    EGLBoolean eglQueryDevicesEXT(EGLint max_devices,
                                  EGLDeviceEXT *devices,
                                  EGLint *num_devices);

    EGLBoolean eglQueryDisplayAttribEXT(EGLDisplay dpy,
                                        EGLint attribute,
                                        EGLAttrib *value);

New Tokens

    Functions with a return type of EGLDeviceEXT will return this
    value on failure:

        EGL_NO_DEVICE_EXT                            ((EGLDeviceEXT)0)

    This error value will be generated by functions that take an
    EGLDeviceEXT object as a parameter:

        EGL_BAD_DEVICE_EXT                       0x322B

    Accepted by the <attribute> parameter of
    eglQueryDisplayAttribEXT:

        EGL_DEVICE_EXT                           0x322C

Add a new section "2.1.2 Devices" after "2.1.1 Scalar Types"

    "All EGL operations occur on an EGLDeviceEXT.  However, devices
    themselves expose no functionality.  They are simple abstract
    objects that exist only for the sake of enumeration and
    defining a namespace."

Modify the last sentence of section "2.1.3" Displays" to read:

    "Besides devices, objects are always specified by the combination
    of an EGLDisplay parameter with a parameter representing the
    handle of the object."

Add a new extension type to the list in section "2.8 Extensions"

    "Device Extensions
        A *device extension* adds functionality to an individual
        EGLDeviceEXT.  Different instances of EGLDeviceEXT may support
        different sets of device extensions"

Add a new error to section "3.1 Errors"

    "EGL_BAD_DEVICE_EXT
        An EGLDeviceEXT argument does not refer to a valid
        EGLDeviceEXT.  Any command taking an EGLDeviceEXT parameter
        may generate this error.

Add a new section "3.2 Device Enumeration" after "3.1 Errors"

    "EGL devices can be enumerated before EGL is initialized.  Use:

        EGLBoolean eglQueryDevicesEXT(EGLint max_devices,
                                      EGLDeviceEXT *devices,
                                      EGLint *num_devices);

    to obtain a list of all supported devices in the system.  On
    success, EGL_TRUE is returned, and <num_devices> devices are
    stored in the array pointed to by <devices>.  <num_devices> will
    be less than or equal to <max_devices>.  If <devices> is NULL,
    then <max_devices> will be ignored, no devices will be returned in
    <devices>, and <num_devices> will be set to the number of
    supported devices in the system.  All implementations must support
    at least one device.

    On failure, EGL_FALSE is returned.  An EGL_BAD_PARAMETER error is
    generated if <max_devices> is less than or equal to zero unless
    <devices> is NULL, or if <num_devices> is NULL.

    To query the properties of a device, use:

        EGLBoolean eglQueryDeviceAttribEXT(EGLDeviceEXT device,
                                           EGLint attribute,
                                           EGLAttribEXT *value);

    On success, EGL_TRUE is returned and the requested attribute value
    is returned in <value>.  Currently there are no valid values of
    <attribute> defined.

    On failure, EGL_FALSE is returned.  An EGL_BAD_ATTRIBUTE error is
    generated if <attribute> is not a valid attribute.  An
    EGL_BAD_DEVICE_EXT error is generated if <device> is not a valid
    EGLDeviceEXT.

        const char *eglQueryDeviceStringEXT(EGLDeviceEXT device,
                                            EGLint name);

    returns a pointer to a static, zero-terminated string describing
    some aspect of the specified EGLDeviceEXT.  <name> must be
    EGL_EXTENSIONS.

    The EGL_EXTENSIONS string describes which device extensions are
    supported by <device>.  The string is of the same format specified
    for display and client extension strings in section 3.4.

    On failure, NULL is returned.  An EGL_BAD_DEVICE_EXT error is
    generated if <device> is not a valid EGLDeviceEXT.  An
    EGL_BAD_PARAMETER error is generated if <name> is not one of the
    values described above.

Add a section "3.4 Display Attributes" after "3.3 EGL Versioning"

    "To query attributes of an initialized display, use:

        EGLBoolean eglQueryDisplayAttribEXT(EGLDisplay dpy,
                                            EGLint name,
                                            EGLAttribEXT *value);

    "On success, EGL_TRUE is returned.  If <name> is EGL_DEVICE_EXT,
    the EGLDeviceEXT associated with <dpy> is returned in <value>.
    All displays have an associated EGLDeviceEXT, regardless of how
    they were created.  A successful query of EGL_DEVICE_EXT will
    never return EGL_NO_DEVICE_EXT.

    "On failure, EGL_FALSE is returned.  An EGL_NOT_INITIALIZED error
    is generated if EGL is not initialized for <dpy>.  An
    EGL_BAD_ATTRIBUTE error is generated if <name> is not a valid
    value."

Issues

    1.  Should there be a mechanism (such as an attribute list) to
        filter devices in eglQueryDevicesEXT()?

        RESOLVED: No.  This could develop too much complexity, like
        the EGLConfig mechanism.  Instead, force applications to query
        all devices and implement any desired filtering themselves.

    2.  Should there be an eglSetDeviceAttribEXT()?

        RESOLVED: No.  Device properties are immutable.

    3.  Should a device file descriptor attribute be included in the
        base specification?

        RESOLVED: No.  It seems like an arbitrary attribute to include
        in the base extension.  Other extensions can easily be added
        if this or other device attributes are needed.

    4.  Should EGLDeviceEXT handles be opaque pointers or 32-bit
        values?

        RESOLVED: Opaque pointers.  The trend seems to be to use
        opaque pointers for object handles, and opaque pointers allow
        more implementation flexibility than 32-bit values.
        Additionally, the introduction of the EGLAttrib type allows
        inclusion of pointer-sized types in attribute lists, which was
        the only major advantage of 32-bit types.

    5.  Should eglQueryDisplayAttribEXT be defined as part of this
        extension?

        RESOLVED: Yes.  There are no other known uses for this
        function, so it should be defined here.  If other uses are
        found, future extension specifications can reference this
        extension or retroactively move it to a separate extension.

    6.  How should bonded GPU configurations, such as SLI or Crossfire
        be enumerated?  What about other hybrid rendering solutions?

        RESOLVED: Bonded GPUs should appear as one device in this API,
        since the client APIs generally treat them as one device.
        Further queries can be added to distinguish the lower-level
        hardware within these bonded devices.

        Hybrid GPUs, which behave independently but are switched
        between in a manner transparent to the user, should be
        enumerated separately.  This extension is intended to be used
        at a level of the software stack below this type of automatic
        switching or output sharing.

    7.  Should this extension require all displays to have an
        associated, queryable device handle?

        RESOLVED: Yes.  This allows creating new namespace containers
        that all displays can be grouped in to and allows existing
        applications with display-based initialization code to easily
        add device-level functionality.  Future extensions are
        expected to expose methods to correlate EGL devices and native
        devices, and to use devices as namespaces for future objects
        and operations, such as cross-display EGL streams.

    8.  Are device handles returned by EGL valid in other processes?

        RESOLVED: No.  Another level of indirection is required to
        correlate two EGL devices in separate processes.

    9.  Is a general display pointer query mechanism needed, or should
        an eglGetDevice call be added to query a display's associated
        device?

        RESOLVED: A general mechanism is better.  It may have other
        uses in the future.

    10. Should a new type of extension be introduced to query device-
        specific extensions?

        RESOLVED: Yes.  Without this mechanism, it is likely that most
        device extensions would require a separate mechanism to
        determine which devices actually support them.  Further,
        requiring all device-level extensions to be listed as client
        extensions forces them to be implemented in the EGL client
        library, or "ICD".  This is unfortunate since vendors will
        likely wish to expose vendor-specific device extensions.

        These advantages were weighed against the one known
        disadvantage of a separate extension type: Increasing the
        complexity of this extension and the EGL extension mechanism
        in general.

    11. Is eglQueryDeviceStringEXT necessary, or should the device
        extension string be queried using eglQueryDeviceAttribEXT?

        RESOLVED: Using a separate query seems more consistent with
        how the current extension strings are queried.

Revision History:

    #8  (May 16th, 2014) James Jones
        - Marked the extension complete.
        - Marked all issues resolved.

    #7  (April 8th, 2014) James Jones
        - Renamed eglGetDisplayAttribEXT back to
          eglQueryDisplayAttribEXT.
        - Update wording based on the EGL 1.5 specification.
        - Use EGLAttrib instead of EGLAttribEXT.
        - Assigned values to tokens.

    #6  (November 6th, 2013) James Jones
        - Added EGL_BAD_DEVICE_EXT error code.
        - Renamed some functions for consistency with the core spec

    #5  (November 6th, 2013) James Jones
        - Specified this is a client extension
        - Renamed eglQueryDisplayPointerEXT eglGetDisplayAttribEXT
          and modified it to use the new EGLAttribEXT type rather than
          a void pointer
        - Introduced the "device" extension type.
        - Added eglQueryDeviceStringEXT to query device extension
          strings
        - Removed issues 5, 10, and 12 as they are no longer relevant
        - Added issues 10 and 11.

    #4  (May 14th, 2013) James Jones
        - Merged in EGL_EXT_display_attributes
        - Changed eglGetDisplayPointerEXT to eglQueryDisplayPointerEXT
        - Remove eglGetDisplayAttribEXT since it has no known use case

    #3  (April 23rd, 2013) James Jones
        - Include EGL_NO_DEVICE_EXT
        - Added issues 8 and 9

    #2  (April 18th, 2013) James Jones
        - Reworded issue 3 and flipped the resolution
        - Added issues 5, 6, and 7
        - Filled in the actual spec language modifications
        - Renamed from EGL_EXT_device to EGL_EXT_device_base
        - Fixed some typos

    #1  (April 16th, 2013) James Jones
        - Initial Draft
