Name

    SUN_triangle_list


Name Strings

    GL_SUN_triangle_list

Contact

    Jack Middleton, Sun (Jack.Middleton 'at' eng.sun.com)

Status

    Shipping

Version

    $Date: 1999/12/28 01:40:37 $ $Revision: 1.4 $
    SUN Date: 99/06/25 13:12:54  Revision: 1.6

Number

    165

Dependencies

    OpenGL 1.1 is required


Overview

    OpenGL has two chained triangle primitives, TRIANGLE_STRIP and
    TRIANGLE_FAN.  For multiple, consecutive triangle strips or
    triangle fans, the overhead of Begin and End, or separate calls to
    DrawArrays, can be significant depending on the number of triangles
    per strip or fan.

    Many surface tessellators produce triangle strips with very few
    triangles per strip before needing to restart a new strip.  Even
    sophisticated tessellators typically need to restart a new strip,
    or switch from a triangle strip to a triangle fan, many times
    within a single object.  Such tessellators can often produce a more
    efficient tessellation--one with fewer vertices--by mixing strips
    and fans within the same object.  The ability to switch from one to
    the other without restarting the strip or fan yields even more
    savings.  Unfortunately, the overhead of switching from a triangle
    strip to a triangle fan, or vice versa, can reduce, or even
    eliminate the benefit gained from reducing the number of vertices.

    A new triangle list primitive, along with an associated replacement
    code attribute, is defined by this extension to allow multiple
    triangle strips and fans to be specified within the same Begin/End
    pair or from a single call to DrawArrays.  The triangle list
    extension also provides the means to switch between triangle strips
    and triangle fans with or without restarting the strip or fan.

    TRIANGLE_LIST is a new primitive type (i.e., new Begin mode) that
    uses the ReplacementCodeSUN state attribute to determine whether the
    current vertex replaces the oldest vertex, as in a triangle strip,
    the middle vertex, as in a triangle fan, or restarts a new chained
    triangle list.  The first vertex of a new triangle list is
    implicitly treated as a RESTART.  The first three vertices complete
    the first triangle, after which the replacement codes of the vertex
    are used.  The two vertices immediately following a
    restart--including the implicit restart on the first vertex--are
    ignored.  The ReplacementCodeSUN attribute is part of the vertex
    state, and is only used by the TRIANGLE_LIST primitive.


Issues

    1.	Two types of restarts: CW/CCW

	Compressed geometry supports the notion of RESTART_CW versus
	RESTART_CCW.  These two types of restart are supported by all
	of Sun's hardware and this capability was exposed via XGL.  We
	need to decide whether we want to expose this in OpenGL.  In a
	sense, we already have exposed it with the compressed geometry
	extension, since the compressed geometry spec allows both types
	of restart.

	It is worth noting that these modes are somewhat misnamed.
	They really don't override the meaning of the GL_FRONT_FACE
	flag (nor did they override the equivalent XGL mode, either).
	Rather, the type of restart either inverts the GL_FRONT_FACE
	state, in the case of RESTART_CW, or it uses the GL_FRONT_FACE
	flag unmodified, in the case of RESTART_CCW.  This should be
	the case for compressed geometry today (although it may be
	broken), and it would be true for triangle lists if we decided
	to expose this capability.  My preference would be to not
	expose this, since all it really does is create a documentation
	headache.  The user can always define a generalized triangle list
	with consistently wound triangles using the CCW variant of restart.
        Supporting both types of restart just doesn't fit into OpenGL's
	(or Java 3D's) model cleanly.

	[NOTE: a decision has been made to not expose the CW/CCW feature]

    2.	Enumerated values for replacement codes

	Enumerated values used for extensions are typically defined as
	integers in a specified range.  This range depends on whether
	they are vendor private (_SUN) or multi-vendor (_EXT or _ARB)
	extensions.  For this extension, we are defining a new
	replacement code attribute that is part of the vertex state
	and is expected to be processed directly by hardware.  Given
	this, we have defined the replacement codes as small integer
	values (1, 2, and 3) that correspond with what the hardware
	wants to see.  The cost for having these values be different,
	especially for replacement codes in a vertex array, are too
	great.

	Another reason for not using constants in the range of
	extension enums is that if this ever became part of the core
	after first being an extension, or even if it became a
	multi-vendor extension after first being a Sun-private
	extension, then the codes would change.  This would be
	unworkable for an attribute such as this, since it is part of
	the vertex pipeline.

	We need to ensure that our current plan of defining
	replacement codes outside the range of extension enums is not
	violating any rules.  I think that this shouldn't be a problem
	since the replacement codes themselves are really just
	parameters to the replacement code command.  As such, they are
	just bit patterns and shouldn't need to be unique.


New Procedures and Functions

    void ReplacementCodeuiSUN(uint code);

    void ReplacementCodeusSUN(ushort code);

    void ReplacementCodeubSUN(ubyte code);

    void ReplacementCodeuivSUN(const uint *code);

    void ReplacementCodeusvSUN(const ushort *code);

    void ReplacementCodeubvSUN(const ubyte *code);

    void ReplacementCodePointerSUN(enum type,
				   sizei stride,
				   const void *pointer);


New Tokens


	TRIANGLE_LIST_SUN			0x81D7


	REPLACEMENT_CODE_SUN			0x81D8


	RESTART_SUN				0x01
	REPLACE_MIDDLE_SUN			0x02
	REPLACE_OLDEST_SUN			0x03


	REPLACEMENT_CODE_ARRAY_SUN		0x85C0


	REPLACEMENT_CODE_ARRAY_TYPE_SUN		0x85C1
	REPLACEMENT_CODE_ARRAY_STRIDE_SUN	0x85C2


	REPLACEMENT_CODE_ARRAY_POINTER_SUN	0x85C3



	R1UI_V3F_SUN				0x85C4
	R1UI_C4UB_V3F_SUN			0x85C5
	R1UI_C3F_V3F_SUN			0x85C6
	R1UI_N3F_V3F_SUN			0x85C7
	R1UI_C4F_N3F_V3F_SUN			0x85C8
	R1UI_T2F_V3F_SUN			0x85C9
	R1UI_T2F_N3F_V3F_SUN			0x85CA
	R1UI_T2F_C4F_N3F_V3F_SUN		0x85CB


