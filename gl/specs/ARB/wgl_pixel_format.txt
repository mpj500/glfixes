Name

    WGL_ARB_pixel_format

Name Strings

    WGL_ARB_pixel_format

Contact

    Pat Brown, NVIDIA (pbrown 'at' nvidia.com)
    Paula Womack

Notice

    Copyright (c) 2000-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete. Approved by ARB on 3/15/2000.

Version

    Last Modified Date: March 25, 2009
    Author Revision: 1.3

Number

    ARB Extension #9

Dependencies

    WGL_ARB_extensions_string is required.

Overview

    This extension adds functions to query pixel format attributes and
    to choose from the list of supported pixel formats.

    These functions treat pixel formats as opaque types: attributes are
    specified by name rather than by accessing them directly as fields
    in a structure. Thus the list of attributes can be easily extended.

    Attribute names are defined which correspond to all of the values in
    the PIXELFORMATDESCRIPTOR and LAYERPLANEDESCRIPTOR data structures.
    Additionally this interface allows pixel formats to be supported
    which have attributes that cannot be represented using the standard
    pixel format functions, i.e. DescribePixelFormat,
    DescribeLayerPlane, ChoosePixelFormat, SetPixelFormat, and
    GetPixelFormat.

IP Status

    No issues.

Issues and Notes

  1. No provision is made to support extended pixel format attributes in
     metafiles.
  2. Should the transparent value pixel format attribute have separate red,
     green and blue values? Yes.
  3. What data type should the transparent value be? This is no longer an
     issue since the transparent value is no longer a packed pixel value (it
     has separate r,g,b,a and index values).
  4. Should we add DONT_CARE values for some of the pixel format attributes?
     No we should just ignore attributes that aren't specified in the list
     passed to wglChoosePixelFormatARB.
  5. Should wglGetPixelFormatAttrib*vARB ignore the <iLayerPlane> parameter
     when the attribute specified only applies to the main planes (e.g.,
     when the attribute is set to WGL_NUMBER_OVERLAYS) or should it require
     <iLayerPlane> to be set to zero? It will just ignore the parameter.
     This allows these attributes to be queried at the same time as
     attributes of the overlay planes.
  6. Should wglGetPixelFormatAttribivARB convert floating point values to
     fixed point? No, wglChoosePixelFormatARB needs a way to accept floating
     point values. pfAttribFList accomplishes this.
  7. Should wglChoosePixelFormatARB take an <iLayerPlane> parameter?
     Typically <iLayerPlane> would be set to zero and a pixel format would
     be selected based on the attributes of the main plane, so there is no
     <iLayerPlane> parameter. This should be OK; applications won't
     typically select a pixel format on the basis of overlay attributes.
     They can always call wglGetPixelFormatAttrib*vARB to get a pixel format
     that has the desired overlay values.
  8. Application programmers must check to see if a particular extension is
     supported before using any pixel format attributes associated with the
     extension. For example, if WGL_ARB_pbuffer is not supported then it is
     an error to specify WGL_DRAW_TO_PBUFFER_ARB in the attribute list to
     wglGetPixelFormatAttrib*vARB or wglChoosePixelFormatARB.
  9. Should WGLChoosePixelFormatARB consider pixel formats at other display
     depths? It would be useful to have an argument to
     WGLChoosePixelFormatARB indicating what display depth should be used.
     However, there is no good way to implement this in the ICD since pixel
     format handles are sequential indices and the pixel format for index n
     differs depending on the display mode.
 10. Should we allow non-displayable pixel formats for pbuffers? Yes,
     although many (most?) implementations will use displayable pixel
     formats for pbuffers, this is a useful feature and the spec should
     allow for it.
 11. Should we create all new calls for pixel formats, specifically should
     we introduce SetPixelFormatARB? No, this doesn't offer any value over
     the existing SetPixelFormat call.
 12. Should we add support for triple buffering? No, triple buffering needs
     to be covered by a separate extension.

New Procedures and Functions

    BOOL wglGetPixelFormatAttribivARB(HDC hdc,
                                      int iPixelFormat,
                                      int iLayerPlane,
                                      UINT nAttributes,
                                      const int *piAttributes,
                                      int *piValues);

    BOOL wglGetPixelFormatAttribfvARB(HDC hdc,
                                      int iPixelFormat,
                                      int iLayerPlane,
                                      UINT nAttributes,
                                      const int *piAttributes,
                                      FLOAT *pfValues);

    BOOL wglChoosePixelFormatARB(HDC hdc,
                                 const int *piAttribIList,
                                 const FLOAT *pfAttribFList,
                                 UINT nMaxFormats,
                                 int *piFormats,
                                 UINT *nNumFormats);

New Tokens


        WGL_NUMBER_PIXEL_FORMATS_ARB            0x2000
        WGL_DRAW_TO_WINDOW_ARB                  0x2001
        WGL_DRAW_TO_BITMAP_ARB                  0x2002
        WGL_ACCELERATION_ARB                    0x2003
        WGL_NEED_PALETTE_ARB                    0x2004
        WGL_NEED_SYSTEM_PALETTE_ARB             0x2005
        WGL_SWAP_LAYER_BUFFERS_ARB              0x2006
        WGL_SWAP_METHOD_ARB                     0x2007
        WGL_NUMBER_OVERLAYS_ARB                 0x2008
        WGL_NUMBER_UNDERLAYS_ARB                0x2009
        WGL_TRANSPARENT_ARB                     0x200A
        WGL_TRANSPARENT_RED_VALUE_ARB           0x2037
        WGL_TRANSPARENT_GREEN_VALUE_ARB         0x2038
        WGL_TRANSPARENT_BLUE_VALUE_ARB          0x2039
        WGL_TRANSPARENT_ALPHA_VALUE_ARB         0x203A
        WGL_TRANSPARENT_INDEX_VALUE_ARB         0x203B
        WGL_SHARE_DEPTH_ARB                     0x200C
        WGL_SHARE_STENCIL_ARB                   0x200D
        WGL_SHARE_ACCUM_ARB                     0x200E
        WGL_SUPPORT_GDI_ARB                     0x200F
        WGL_SUPPORT_OPENGL_ARB                  0x2010
        WGL_DOUBLE_BUFFER_ARB                   0x2011
        WGL_STEREO_ARB                          0x2012
        WGL_PIXEL_TYPE_ARB                      0x2013
        WGL_COLOR_BITS_ARB                      0x2014
        WGL_RED_BITS_ARB                        0x2015
        WGL_RED_SHIFT_ARB                       0x2016
        WGL_GREEN_BITS_ARB                      0x2017
        WGL_GREEN_SHIFT_ARB                     0x2018
        WGL_BLUE_BITS_ARB                       0x2019
        WGL_BLUE_SHIFT_ARB                      0x201A
        WGL_ALPHA_BITS_ARB                      0x201B
        WGL_ALPHA_SHIFT_ARB                     0x201C
        WGL_ACCUM_BITS_ARB                      0x201D
        WGL_ACCUM_RED_BITS_ARB                  0x201E
        WGL_ACCUM_GREEN_BITS_ARB                0x201F
        WGL_ACCUM_BLUE_BITS_ARB                 0x2020
        WGL_ACCUM_ALPHA_BITS_ARB                0x2021
        WGL_DEPTH_BITS_ARB                      0x2022
        WGL_STENCIL_BITS_ARB                    0x2023
        WGL_AUX_BUFFERS_ARB                     0x2024


        WGL_NO_ACCELERATION_ARB                 0x2025
        WGL_GENERIC_ACCELERATION_ARB            0x2026
        WGL_FULL_ACCELERATION_ARB               0x2027

        WGL_SWAP_EXCHANGE_ARB                   0x2028
        WGL_SWAP_COPY_ARB                       0x2029
        WGL_SWAP_UNDEFINED_ARB                  0x202A

        WGL_TYPE_RGBA_ARB                       0x202B
        WGL_TYPE_COLORINDEX_ARB                 0x202C

