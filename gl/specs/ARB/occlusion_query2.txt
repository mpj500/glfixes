Name

    ARB_occlusion_query2

Name Strings

    GL_ARB_occlusion_query2

Contributors

    Aske Simon Christensen
    Bill Licea-Kane
    Cass Everitt
    Jeff Bolz
    Maurice Ribble

Contact

    Bill Licea-Kane (bill 'at' amd.com)

Notice

    Copyright (c) 2010-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete. Approved by the ARB at the 2010/01/22 F2F meeting.
    Approved by the Khronos Board of Promoters on March 10, 2010.

Version

    Date: March 21, 2010
    Revision: 11
    $Id$

Number

    ARB Extension #80

Dependencies

    Written based on the wording of OpenGL Specification
    Version 3.2 (Core Profile) - July 24, 2009

    Version 3.2 (Compatibility Profile) interacts with this extension.

    OpenGL 1.x is required.

    ARB_occlusion_query interacts with this extension.

    Conditional rendering interacts with this extension.

New Procedures and Functions

    None

New Tokens


        ANY_SAMPLES_PASSED                              0x8C2F

Dependencies

Version 3.2 (Compatibility Profile) interacts with this extension.

   Other than adjusting the page numbers referenced in the edits, there are no
   further changes required for the Compatibility Profile specification.

ARB_occlusion_query

   If ARB_occlusion_query is not supported, then delete the enum
   SAMPLES_PASSED and delete sections of text refering to
   SAMPLES_PASSED, and incorporate all other enums, entry
   points and state introduced by ARB_occlusion_query into
   this extension.

Conditional Rendering

   If Conditional Rendering is not supported, delete edits to
   section on Conditional Rendering.

New State

(table 6.33, p. 298)

    Get Value         Type    Get Command          Initial Value   Description              Sec     Attribute
    ---------         ----    -----------          -------------   -----------              ------  ---------
    QUERY_RESULT      Z+      GetQueryObjectuiv    0               samples-passed count     6.1.6   -
|                                                  FALSE           or any-samples-passed
|                                                                  boolean value


Usage Examples

    Here is some rough sample code that illustrates how this extension
    can be used.

        GLuint    queries[N];
        GLint     sampleBoolean;
        GLint     available;


        glGenQueries(N, queries);
        ...
        // before this point, render major occluders
        glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
        glDepthMask(GL_FALSE);
        // also disable texturing and any fancy shaders
        for (i = 0; i < N; i++) {
            glBeginQuery(GL_ANY_SAMPLES_PASSED, queries[i]);
            // render bounding box for object i
            glEndQuery(GL_ANY_SAMPLES_PASSED);
        }

        glFlush();

        // Do other work until "most" of the queries are back, to avoid
        // wasting time spinning
        i = N*3/4; // instead of N-1, to prevent the GPU from going idle
        do {
            DoSomeStuff();
            glGetQueryObjectiv(queries[i],
                                  GL_QUERY_RESULT_AVAILABLE,
                                  &available);
        } while (!available);

        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
        glDepthMask(GL_TRUE);
        // reenable other state, such as texturing
        for (i = 0; i < N; i++) {
            glGetQueryObjectuiv(queries[i], GL_QUERY_RESULT,
                                   &sampleBoolean);
            if (sampleBoolean != 0) {
                // render object i
            }
        }

    Here is some rough sample code for a simple multipass rendering
    application that does not use occlusion queries.

        for (i = 0; i < N; i++) {
            // First rendering pass
            glDisable(GL_BLEND);
            glDepthFunc(GL_LESS);
            glDepthMask(GL_TRUE);
            // configure shader 0
            // render object i

            // Second rendering pass
            glEnable(GL_BLEND);
            glBlendFunc(...);
            glDepthFunc(GL_EQUAL);
            glDepthMask(GL_FALSE);
            // configure shader 1
            // render object i
        }

    Here is the previous example, enhanced using occlusion queries.

        GLuint queries[N];
        GLuint sampleBoolean;

        glGenQueries(N, queries);
        ...
        // First rendering pass plus almost-free visibility checks
        glDisable(GL_BLEND);
        glDepthFunc(GL_LESS);
        glDepthMask(GL_TRUE);
        // configure shader 0
        for (i = 0; i < N; i++) {
            glBeginQuery(GL_ANY_SAMPLES_PASSED, queries[i]);
            // render object i
            glEndQuery(GL_ANY_SAMPLES_PASSED);
        }

        // Second pass only on objects that were visible
        glEnable(GL_BLEND);
        glBlendFunc(...);
        glDepthFunc(GL_EQUAL);
        glDepthMask(GL_FALSE);
        // configure shader 1
        for (i = 0; i < N; i++) {
            glGetQueryObjectuiv(queries[i], GL_QUERY_RESULT,
                                   &sampleBoolean);
            if (sampleBoolean != 0) {
                // render object i
            }
        }


