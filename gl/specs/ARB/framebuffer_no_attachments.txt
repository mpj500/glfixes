Name

    ARB_framebuffer_no_attachments

Name Strings

    GL_ARB_framebuffer_no_attachments

Contact

    Pat Brown, NVIDIA (pbrown 'at' nvidia.com)

Contributors

    Members of the Khronos OpenGL ARB TSG

Notice

    Copyright (c) 2012-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete.
    Approved by the ARB on 2012/06/12.

Version

    Last Modified Date:         May 7, 2015
    Revision:                   5

Number

    ARB Extension #130

Dependencies

    OpenGL 3.0 or ARB_framebuffer_object is required.

    This extension is written against the OpenGL 4.2 (Compatibility Profile)
    Specification (January 19, 2012).

    This extension interacts with OpenGL 3.0 and EXT_texture_array.

    This extension interacts with EXT_direct_state_access.

Overview

    Framebuffer objects as introduced by ARB_framebuffer_object and OpenGL 3.0
    provide a generalized mechanism for rendering to off-screen surfaces.
    Each framebuffer object may have depth, stencil and zero or more color
    attachments that can be written to by the GL.  The size of the framebuffer
    (width, height, layer count, sample count) is derived from the attachments
    of that framebuffer.  In unextended OpenGL 4.2, it is not legal to render
    into a framebuffer object that has no attachments.  Such a framebuffer
    would be considered incomplete with the
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT status.

    With OpenGL 4.2 and ARB_shader_image_load_store, fragment shaders are
    capable of doing random access writes to buffer and texture memory via
    image loads, stores, and atomics.  This ability enables algorithms using
    the conventional rasterizer to generate a collection of fragments, where
    each fragment shader invocation will write its outputs to buffer or
    texture memory using image stores or atomics.  Such algorithms may have no
    need to write color or depth values to a conventional framebuffer.
    However, a framebuffer with no attachments will be considered incomplete
    and no rasterization or fragment shader exectuion will occur.  To avoid
    such errors, an application may be required to create an otherwise
    unnecessary "dummy" texture and attach it to the framebuffer (possibly
    with color writes masked off).  If the algorithm requires the rasterizer
    to operate over a large number of pixels, this dummy texture will
    needlessly consume a significant amount of memory.

    This extension enables the algorithms described above to work even with a
    framebuffer with no attachments.  Applications can specify default width,
    height, layer count, and sample count parameters for a framebuffer object.
    When a framebuffer with no attachments is bound, it will be considered
    complete as long as the application has specified non-zero default width
    and height parameters.  For the purposes of rasterization, the framebuffer
    will be considered to have a width, height, layer count, and sample count
    derived from its default parameters.  Framebuffers with one or more
    attachments are not affected by these default parameters; the size of the
    framebuffer will still be derived from the sizes of the attachments in
    that case.

    Additionally, this extension provides queryable implementation-dependent
    maximums for framebuffer width, height, layer count, and sample count,
    which may differ from similar limits on textures and renderbuffers.  These
    maximums will be used to error-check the default framebuffer parameters
    and also permit implementations to expose the ability to rasterize to an
    attachment-less framebuffer larger than the maximum supported texture
    size.

IP Status

    No known IP claims.

New Procedures and Functions

    void FramebufferParameteri(enum target, enum pname, int param);
    void GetFramebufferParameteriv(enum target, enum pname, int *params);

    (the following two commands are supported only if EXT_direct_state_access
    is supported)

    void NamedFramebufferParameteriEXT(uint framebuffer, enum pname,
                                       int param);
    void GetNamedFramebufferParameterivEXT(uint framebuffer, enum pname,
                                       int *params);

New Tokens


        FRAMEBUFFER_DEFAULT_WIDTH                       0x9310
        FRAMEBUFFER_DEFAULT_HEIGHT                      0x9311
        FRAMEBUFFER_DEFAULT_LAYERS                      0x9312
        FRAMEBUFFER_DEFAULT_SAMPLES                     0x9313
        FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS      0x9314


        MAX_FRAMEBUFFER_WIDTH                           0x9315
        MAX_FRAMEBUFFER_HEIGHT                          0x9316
        MAX_FRAMEBUFFER_LAYERS                          0x9317
        MAX_FRAMEBUFFER_SAMPLES                         0x9318


