Name

    ARB_vertex_blend

Name Strings

    GL_ARB_vertex_blend

Contact

    Evan Hart, NVIDIA (ehart 'at' nvidia.com)
    Tom Frisinger, AMD (tom.frisinger 'at' amd.com)

Notice

    Copyright (c) 2000-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete. Approved by ARB on September 19, 2000.

Version

    Last Modified Date: November 4, 2006
    Revision: 1.3

Number

    ARB Extension #15

Dependencies

    OpenGL 1.0 is required.
    This extension is written against the OpenGL 1.2.1 Specification.

Overview

    This extension provides the ability to replace the single
    modelview transformation with a set of n vertex units. (Where
    n is constrained to an implementation defined maximum.) Each
    unit has its own modelview transform matrix. For each unit,
    there is a current weight associated with the vertex. When
    this extension is enabled the vertices are transformed by
    the modelview matrices of all of the enabled units. Afterward,
    these results are scaled by the weights for the respective
    units and then summed to create the eye-space vertex. A
    similar procedure is followed for the normals, except they
    are transformed by the inverse transpose of the modelview
    matrices.

    This extension is an orthoganalized version of functionality
    already provided by other 3D graphics API's.

    
IP Status

    Unknown, but believed to be none. 

Issues


    Should an indexed form of matrix addressing be used?

        No, this should be added as an additional extension.

    Should integer blending weights be allowed?

        Yes, this was an over-sight in the original spec. Integer
        formats allow for the potential to provide smaller data
        types to the API. Integer data types are always mapped
        to floats in the same manner as colors.

    Should the blending weights be forced to sum to 1?

        No, it should be provided as a convenience to developers,
        since it is the most common case. Additionally, it should
        be noted that even if the weights do not sum to one,
        the result of the modelview transformation provides an
        eye coordinate whose homogenous coordinate is equivalent
        to the homogeneous coordinate after the transformation
        had the weights been scaled to sum to one.

        Additionally, NORMALIZE should in general be left on to
        prevent non-unit normals.
    
    What about projective modelview matrices?  

        Projective modelview matrices can cause problems with many
        other features in GL, so this should not be a problem in
        practice. This extension makes no attempts to handle
        projective modelview matrices.

    Should the set of modelview matrices affect parts of GL other
      than vertices?

        No, this seems to confuse the operation, and it forces
        vertex components to affect setting of GL state.
      
    Some transformations may cause the normals to be transformed in
      such a way that they no longer represent the tangent plane to
      the surface.

        This is a basic property of the math of the technique. In
        general with these varying transformations, it is impossible
        to maintain the normal as the tangent plane to the surface
        without topological information. 

        Lacking the topological data, the best approximation is to
        transform the normals by the inverse transpose of the
        blend of the modelview matrices. As the inverse per-vertex
        may be computationally impractical, a slightly less accurate
        blend of inverse transpose matrices is allowed as the
        transformation.

        When the less accurate blend is used, the normals will only
        be identical to the normals formed by the more correct math
        when the blending matrices are pair-wise orthogonal and
        the sum of the square of the weights is equal to one.
        
    Should weights be specified as vectors rather than independent
      scalars?

        Yes, this removes little flexibility and significantly
        reduces the call overhead.


New Procedures and Functions

    void Weight{bsifd ubusui}vARB(int size, T* weights)

    void WeightPointerARB(int size, enum type, sizei stride,
                          void *pointer)

    void VertexBlendARB(int count)


New Tokens


      MAX_VERTEX_UNITS_ARB            0x86A4
      ACTIVE_VERTEX_UNITS_ARB         0x86A5


      WEIGHT_SUM_UNITY_ARB            0x86A6
      VERTEX_BLEND_ARB                0x86A7


      MODELVIEW0_ARB:                 0x1700 (alias to MODELVIEW)
      MODELVIEW1_ARB:                 0x850a
      MODELVIEW2_ARB:                 0x8722
      MODELVIEW3_ARB:                 0x8723
      MODELVIEW4_ARB:                 0x8724
      MODELVIEW5_ARB:                 0x8725
      MODELVIEW6_ARB:                 0x8726
      MODELVIEW7_ARB:                 0x8727
      MODELVIEW8_ARB:                 0x8728
      MODELVIEW9_ARB:                 0x8729
      MODELVIEW10_ARB:                0x872A
      MODELVIEW11_ARB:                0x872B
      MODELVIEW12_ARB:                0x872C
      MODELVIEW13_ARB:                0x872D
      MODELVIEW14_ARB:                0x872E
      MODELVIEW15_ARB:                0x872F
      MODELVIEW16_ARB:                0x8730
      MODELVIEW17_ARB:                0x8731
      MODELVIEW18_ARB:                0x8732
      MODELVIEW19_ARB:                0x8733
      MODELVIEW20_ARB:                0x8734
      MODELVIEW21_ARB:                0x8735
      MODELVIEW22_ARB:                0x8736
      MODELVIEW23_ARB:                0x8737
      MODELVIEW24_ARB:                0x8738
      MODELVIEW25_ARB:                0x8739
      MODELVIEW26_ARB:                0x873A
      MODELVIEW27_ARB:                0x873B
      MODELVIEW28_ARB:                0x873C
      MODELVIEW29_ARB:                0x873D
      MODELVIEW30_ARB:                0x873E
      MODELVIEW31_ARB:                0x873F
      
    
      CURRENT_WEIGHT_ARB              0x86A8 
      

      WEIGHT_ARRAY_TYPE_ARB           0x86A9
      WEIGHT_ARRAY_STRIDE_ARB         0x86AA
      WEIGHT_ARRAY_SIZE_ARB           0x86AB

      WEIGHT_ARRAY_POINTER_ARB        0x86AC


      WEIGHT_ARRAY_ARB                0x86AD

