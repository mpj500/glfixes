Name

    ARB_texture_compression

Name Strings

    GL_ARB_texture_compression

Contact

    Pat Brown, Intel Corporation (patrick.r.brown 'at' intel.com)

Notice

    Copyright (c) 2000-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete. Approved by ARB on March 16, 2000

Version

    Last Modified Date: May 23, 2000
    Author Revision: 1.03

Number

    ARB Extension #12

Dependencies

    OpenGL 1.1 is required.

    This extension is written against the OpenGL 1.2.1 Specification.

    This extension is written against the GLX Extensions for OpenGL
    Specification (Version 1.3).

    Depends on GL_ARB_texture_cube_map, as cube maps may be stored in
    compressed form.

Overview

    Compressing texture images can reduce texture memory utilization and
    improve performance when rendering textured primitives.  This extension
    allows OpenGL applications to use compressed texture images by providing:

        (1) A framework upon which extensions providing specific compressed
            image formats can be built.

        (2) A set of generic compressed internal formats that allow
            applications to specify that texture images should be stored in
            compressed form without needing to code for specific compression
            formats.

    An application can define compressed texture images by providing a texture
    image stored in a specific compressed image format.  This extension does
    not define any specific compressed image formats, but it does provide the
    mechanisms necessary to enable other extensions that do.

    An application can also define compressed texture images by providing an
    uncompressed texture image but specifying a compressed internal format.
    In this case, the GL will automatically compress the texture image using
    the appropriate image format.  Compressed internal formats can either be
    specific (as above) or generic.  Generic compressed internal formats are
    not actual image formats, but are instead mapped into one of the specific
    compressed formats provided by the GL (or to an uncompressed base internal
    format if no appropriate compressed format is available).  Generic
    compressed internal formats allow applications to use texture compression
    without needing to code to any particular compression algorithm.  Generic
    compressed formats allow the use of texture compression across a wide
    range of platforms with differing compression algorithms and also allow
    future GL implementations to substitute improved compression methods
    transparently.

    Compressed texture images can be obtained from the GL in uncompressed form
    by calling GetTexImage and in compressed form by calling
    GetCompressedTexImageARB.  Queried compressed images can be saved and
    later reused by calling CompressedTexImage[123]DARB.  Pre-compressed
    texture images do not need to be processed by the GL and should
    significantly improve texture loading performance relative to uncompressed
    images.

    This extension does not define specific compressed image formats (e.g.,
    S3TC, FXT1), nor does it provide means to encode or decode such images.
    To support images in a specific compressed format, a hardware vendor
    would:

      (1) Provide a new extension defininig specific compressed
          <internalformat> and <format> tokens for TexImage[123]D,
          TexSubImage[123]D, CopyTexImage[12]D, CompressedTexImage[123]DARB,
          CompressedTexSubImage[123]DARB, and GetCompressedTexImageARB calls.

      (2) Specify the encoding of compressed images of that specific format.

      (3) Specify a method for deriving the size of compressed images of that
          specific format, using the <internalformat>, <width>, <height>,
          <depth> parameters, and (if necessary) the compressed image itself.

IP Status

    No known intellectual property issues on this general extension.

    Specific compression algorithms used to implement this extension (and any
    other specific texture compression extensions) may be protected and
    require licensing agreements.

Issues

    (1) Should we define additional internal formats that strongly tie an
    underlying compression algorithm to the format?

      RESOLVED:  Not here.  Explicit compressed formats will be provided by
      other extensions built on top of this one.

    (2) Should we provide additional compression state that gives more control
    on the level/quality of compression?  If so, how?

      RESOLVED:  Yes, as a hint.  Could have also been implemented as a [0.0,
      1.0] floating-point TexParameter "quality" state variable (such as the
      JPEG quality scale found in many apps).  This control will affect only
      the speed (and quality) with which a driver compresses incoming images,
      but will not affect the compressed image format selected by the driver.

      As the spec is currently formulated, the requirement that quality
      control not affect compression format selection could have been relaxed
      by loosening the invariance requirements (so that the quality control
      can affect the choice of internal format).  The risk was the potential
      for subtle mipmap consistency issues if the hint changes.

    (3) Most current compression algorithms handle primarily RGB and RGBA
    images.  Does it make sense having generic compressed formats for alpha,
    intensity, luminance, and luminance-alpha?

      RESOLVED:  Yes.  It is conceivable that some or all of these formats may
      be compressed.  Implementations not having compression algorithms for
      these formats can simply choose not to compress and use the appropriate
      base internal format instead.

    (4) Full GetTexImage support requires that the renderer decompress the
    whole image.  Should this extra implementation burden be imposed on the
    renderer?

      RESOLVED:  Yes, returning the uncompressed image is a useful feature for
      evaluating the quality of the compressed image.  A decompression engine
      may also be required for a number of other areas, including software
      rasterization.

    (5) Full TexSubImage support may require that the renderer decompress
    portions of the image (or perhaps the whole image), do a merge, and then
    recompress.  Even if this were done, portions of the image outside the
    "modified" area may also be modified due to lossy compression. Should this
    extra implementation burden be imposed on the renderer?

      RESOLVED:  No.  To avoid the complications involved with modifying a
      compressed texture image, only the lower-left corner may be modified by
      TexSubImage.  In addition, after calling TexSubImage, the "unmodified"
      portion of the image is left undefined. An INVALID_OPERATION error
      results from any other TexSubImage calls.

      This behavior allows for the use of compressed images whose dimensions
      are not powers of two, which TexImage will not accept.  The recommended
      sequence of calls for defining such images is to first call TexImage
      with a NULL <data> pointer and the image size parameters padded out to
      the next power of two, and then call CompressedTexSubImageARB or
      TexSubImage with <xoffset>, <yoffset>, and <zoffset> parameters of zero
      and the compressed data pointed to by <data>.  This behavior also allows
      TexSubImage to be used as a light-weight replacement of TexImage, where
      only the image contents are modified.

      Certain compressed formats may allow a wider variety of edits -- their
      specifications will document the restrictions under which these edits
      are permitted.  it is impossible to document such restrictions for
      unknown generic formats.  It is desirable to keep the behavior of
      generic formats and the specific formats they map to as consistent as
      possible.

    (6) What do the return values of the component sizes (RED_BITS,
    GREEN_BITS, ...) give for compressed textures?  Compressed proxy textures?

      RESOLVED:  Some behavior has to be defined. For both normal and proxy
      textures, we return the bit depths of an uncompressed sized image that
      would most closely match the quality of the compression algorithm for an
      "average" texture image.  Since compressed image quality is highly data
      dependent, the actual compressed image quality may be better or worse
      than the renderer's best guess at the best matching sized internal
      format.  To implement this feature in a driver, it is expected that an
      error analysis would be done on a set of representative images, and the
      resultant "equivalent bit depths" would be hardwired constants.

    (7) What should GetTexLevelParameter with TEXTURE_COMPRESSED_
    IMAGE_SIZE_ARB return for existing uncompressed formats?  For proxy
    textures?

      RESOLVED: For both, an INVALID_OPERATION error results.  The actual
      image to be compressed is not available for proxies, so actually
      compressing the specified image is not an option.

      For uncompressed internal formats, we could return the actual amount of
      memory taken by the texture image.  Such a mechanism might be useful as
      a metric of "how much space does this texture image take".  It's not
      particularly useful for an application based texture management scheme,
      since there is no information available indicating the amount of
      available memory.  In addition, because of implementation-dependent
      hardware constraints, the amount of texture memory consumed by a texture
      object is not necessarily equal to the sum of the memory consumed by
      each of its mipmaps.  The OpenGL ARB decided against adopting this
      behavior when this specification was approved.

    (8) What about texture borders?

      RESOLVED:  Not a problem for generic compressed formats since a base
      internal format can be used if borders are not supported in the
      compressed image format.  Borders may pose problems for specific
      compression extensions, and compressed textures with borders might well
      be disallowed by those extensions.

    (9) Should certain pixel operations be disallowed for compressed texture
    internal formats (e.g., PixelStorage, PixelTransfer)?  What about byte
    swapping?

      RESOLVED:  For uncompressed source images, all pixel storage and pixel
      transfer modes will be applied prior to compression.  For compressed
      source images, all pixel storage and transfer modes will be ignored.
      The encoding of compressed images should be specified as a byte stream
      that matches the disk file format defined for the corresponding image
      type.

    (10) Should functionality be provided to allow applications to save
    compressed images to disk and reuse them in subsequent runs without
    programming to specific formats?  If so, how?

      RESOLVED:  Yes.  This can be done without knowledge of specific
      compression formats in the following manner:

        * Call TexImage with an uncompressed image and a generic compressed
          internal format.  The texture image will be compressed by the GL, if
          possible.

        * Call GetTexLevelParameteriv with a <value> of TEXTURE_COMPRESSED_ARB
          to determine if the GL was able to store the image in compressed
          form.

        * Call GetTexLevelParameteriv with a <value> of
          TEXTURE_INTERNAL_FORMAT to determine the specific compressed image
          format in which the image is stored.

        * Call GetTexLevelParameteriv with a <value> of
          TEXTURE_COMPRESSED_IMAGE_SIZE_ARB to determine the size (in ubytes)
          of the compressed image that will be returned by the GL.  Allocate a
          buffer of at least this size.

        * Call GetCompressedTexImageARB.  The GL will write the compressed
          texture image into the allocated buffer.

        * Save the returned compressed image to disk, along with the
          associated width, height, depth, border parameters and the returned
          values of TEXTURE_COMPRESSED_IMAGE_SIZE_ARB and
          TEXTURE_INTERNAL_FORMAT.

        * Load the compressed image and its parameters, and call
          CompressedTexImage_[123]DARB to use the compressed image.  The value
          of TEXTURE_INTERNAL_FORMAT should be used as <internalFormat> and
          the value of TEXTURE_COMPRESSED_IMAGE_SIZE_ARB should be used as
          <imageSize>.

      The saved images will be valid as long as they are used on a device
      supporting the returned <internalFormat> parameter.  If the saved images
      are used on a device that does not support the compressed internal
      format, an INVALID_ENUM error would be generated by the call to
      CompressedTexImage_[123]D because of the unknown format.

      Note also that to reliably determine if the GL will compress an image
      without actually compressing it, an application need only define a proxy
      texture image and query TEXTURE_COMPRESSED_ARB as above.

    (11) Without knowing of the compressed image format, there is no
    convenient way for the client-side GLX library or tracing tools to
    ascertain the size of a compressed texture image when sending a
    TexImage1D, TexImage2D, or TexImage3D packet or interpret pixel storage
    modes.  To complicate matters further, it is possible to create both
    indirect (that might not understand an image format) and direct rendering
    contexts (that might understand an image format) on the same renderer.
    How should this be solved?

      RESOLVED:  A separate set of CompressedTexImage and
      CompressedTexSubImage calls has been created that allows libraries to
      pass compressed images along to the renderer without needing to
      understand their specific image formats or how to interpret pixel
      storage modes.

    (12) Are the CompressedTexImage[123]DARB entry points really needed?

      RESOLVED:  Yes.  To robustly support images of unknown format, specific
      compressed entry points are required.  While the extension does not
      support images in a completely unspecified format (early drafts did),
      having a separate call means that GLX and tools such as GLS (stream
      encoder) do not need intimate knowledge of every compressed image
      format.  Having separate calls also cleanly solves the problem where
      pixel storage and pixel transfer operations apply if and only if the
      source image is uncompressed.

    (13) Is variable-ratio compression supported?

      RESOLVED:  Yes.  Fixed-ratio compression is currently the predominant
      texture compression format, but this spec should not preclude the use of
      other compression schemes.

    (14) Should the <imageSize> parameter be validated on CompressedTexImage
    calls?

      RESOLVED: Yes.  Enforcement overhead is generally trivial.  Without
      enforcement, an application could specify incorrect image sizes but
      notice them only when run on an indirect renderer, causing portability
      problems.  There is also a reliability issue with respect to the GLX
      environment -- if the compressed image size provided by the user is less
      than the required image size, the GLX server may run off the end of the
      image and access invalid memory.  A size check may thus be desirable to
      prevent server crashes (even though that could be considered an
      "undefined" result).

      While enforcing correct <imageSize> parameters is trivial for current
      compressed internal formats, it might not be reasonable on others
      (particular variable-ratio compression formats).  For such formats, this
      restriction should be overridden in the spec defining the formats.  The
      <imageSize> check was made mandatory only in the final draft approved at
      the March 2000 OpenGL ARB meeting.

    (15) Should TexImage calls fall back to uncompressed image formats when
    <internalformat> is a specific compressed format but its use in
    combination with other parameter values passed is not supported by the
    renderer?

      RESOLVED:  Yes.  Advantages:  Works in exactly the same way as generic
      formats, meaning no extra code/error checking.  Inherent limitations of
      TexImage on specific formats should be documented in their specs and
      observed by their users.  One simple query can detect fallback cases.
      Disadvantages: Silent fallback to a format not requested by the user.

    (16) Should the texture format invariance requirements disallow scanning
    of the image data to select a compression method?  What about for a base
    (uncompressed) internal format?

      RESOLVED:  The primary issue is mipmap consistency.  The 1.2.1 spec
      defines a set of mipmaps as consistent if all are specified using the
      same internal format.  However, it doesn't require that all mipmaps are
      allocated using the same format -- the renderer is responsible for
      ensuring mipmap consistency if it selects different formats for
      different images.  There is no reason to disallow scanning for base
      internal formats; the renderer is responsible for doing the right thing.

      The selection of a specific compressed internal format is different.  It
      must be independent of the the image data because the GL treats the
      texture image as though it were specified using the specific compressed
      internal format chosen by the renderer.

    (17) Should functionality be provided to enumerate the specific compressed
    formats supported by the renderer?  If so, how and what will it accomplish?

      RESOLVED:  Yes.  A glGet* query is added to return the number of
      compressed internal formats supported by the renderer and the
      <internalformat> tokens for each.  These tokens can subsequently be used
      as <internalformat> parameters for normal TexImage calls and the new
      CompressedTexImage calls.

      Providing an internal format enumeration allows applications to weigh
      the suitability of the various compression methods provided to it by the
      renderer without needing specific knowledge of the formats.
      Applications can query the component sizes (see issue 6) to determine
      the base format and approximate precision.  Applications can directly
      evaluate image compression quality by having the renderer generate
      compressed texture images (using the returned <internalformat> values)
      and return them in uncompressed form using GetTexImage.  Applications
      should also be aware that the use of the internal formats returned by
      this query is subject to the restrictions imposed by the specification
      defining them.  The use of proxy textures allows the application to
      determine if a specific set of TexImage parameters is supported for a
      given internal format.

      The renderer should enumerate all supported compression formats EXCEPT
      those that operate fundamentally differently from a normal uncompressed
      format.  For example, the DirectX DXT1 compression format is
      fundamentally an RGB format, but it has a "transparent" encoding where
      the red, green, and blue component values are forced to zero, regardless
      of their original (uncompressed) values.  Since such formats may have
      caveats that must be understood before being used, they should not be
      enumerated by this query.

      This allows for forward compatibility -- an application can exploit
      compression techniques provided by future renderers.

    (18) Should the separate GetCompressedTexImageARB function exist, or is
         GetTexImage with special <format> and/or <type> parameters
         sufficient?

      RESOLVED:  Provide a separate GetCompressedTexImageARB function.  The
      primary rationale is for GLX indirect rendering.  The client GetTexImage
      would require information to determine if an image is uncompressed (and
      should be decoded using pixel storage state) or compressed (pixel
      storage ignored).  In addition, if the image is compressed, the actual
      image size would be required, but the only image size that could be
      inferred from the GLX protocol is padded out to a multiple of four
      bytes.  A separate call is the cleanest solution to both issues.

New Procedures and Functions

    void CompressedTexImage3DARB(enum target, int level,
                                 enum internalformat, sizei width,
                                 sizei height, sizei depth,
                                 int border, sizei imageSize,
                                 const void *data);
    void CompressedTexImage2DARB(enum target, int level,
                                 enum internalformat, sizei width,
                                 sizei height, int border, 
                                 sizei imageSize, const void *data);
    void CompressedTexImage1DARB(enum target, int level,
                                 enum internalformat, sizei width,
                                 int border, sizei imageSize,
                                 const void *data);
    void CompressedTexSubImage3DARB(enum target, int level, 
                                    int xoffset, int yoffset,
                                    int zoffset, sizei width,
                                    sizei height, sizei depth,
                                    enum format, sizei imageSize,
                                    const void *data);
    void CompressedTexSubImage2DARB(enum target, int level, 
                                    int xoffset, int yoffset,
                                    sizei width, sizei height,
                                    enum format, sizei imageSize,
                                    const void *data);
    void CompressedTexSubImage1DARB(enum target, int level, 
                                    int xoffset, sizei width,
                                    enum format, sizei imageSize,
                                    const void *data);
    void GetCompressedTexImageARB(enum target, int lod,
                                  void *img);

New Tokens


        COMPRESSED_ALPHA_ARB                            0x84E9
        COMPRESSED_LUMINANCE_ARB                        0x84EA
        COMPRESSED_LUMINANCE_ALPHA_ARB                  0x84EB
        COMPRESSED_INTENSITY_ARB                        0x84EC
        COMPRESSED_RGB_ARB                              0x84ED
        COMPRESSED_RGBA_ARB                             0x84EE


        TEXTURE_COMPRESSION_HINT_ARB                    0x84EF


        TEXTURE_COMPRESSED_IMAGE_SIZE_ARB               0x86A0
        TEXTURE_COMPRESSED_ARB                          0x86A1


        NUM_COMPRESSED_TEXTURE_FORMATS_ARB              0x86A2
        COMPRESSED_TEXTURE_FORMATS_ARB                  0x86A3

