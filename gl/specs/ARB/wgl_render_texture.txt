Name 

    ARB_render_texture 

Name Strings 

    WGL_ARB_render_texture 

Contact 

    Bimal Poddar, Intel, bimal.poddar@intel.com
    Paula Womack, Nvidia, PWomack@nvidia.com

Notice

    Copyright (c) 2001-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status 

    Complete. Approved by ARB on June 13, 2001

Version 

    Last Modified Date: July 16, 2001

Number 

    ARB Extension #20 

Dependencies 

    OpenGL 1.1 is required. 
    WGL_ARB_extension_string is required. 
    WGL_ARB_pixel_format is required. 
    WGL_ARB_pbuffer is required. 
    WGL_ARB_make_current_read affects the definition of this extension. 
    GL_ARB_texture_cube_map affects the definition of this extension 
    The extension is written against the OpenGL 1.2.1 Specification. 

Overview 

    This extension allows a color buffer to be used for both rendering and
    texturing. When a color buffer is bound to a texture target it cannot 
    be rendered to. Once it has been released from the texture it can be 
    rendered to once again. 

    This extension may provide a performance boost and reduce memory 
    requirements on architectures that support rendering to the same 
    memory where textures reside and in the same memory format and layout
    required by texturing. The functionality is similar to CopyTexImage1D
    and CopyTexImage2D. However, some changes were made to make it easier 
    to avoid copying data: 

    -   Only color buffers of a pbuffer can be bound as a texture. It is 
        not possible to use the color buffer of a window as a texture. 

    -   The texture internal format is determined when the color buffer 
        is associated with the texture, guaranteeing that the color 
        buffer format is equivalent to the texture internal format. 
        
    -   When a color buffer of a pbuffer is being used as a texture, 
        the pbuffer can not be used for rendering; this makes it 
        easier for implementations to avoid a copy of the image 
        since the semantics of the pointer swap are clear. 

    -   The application must release the color buffer from the texture 
        before it can render to the pbuffer again. When the color buffer 
        is bound as a texture, draw and read operations on the pbuffer 
        are undefined. 

    -   A mipmap attribute can be set, in which case memory will be 
        allocated up front for mipmaps. The application can render 
        the mipmap images or, if SGIS_generate_mipmap is supported, 
        they can be automatically generated when the color buffer is 
        bound as a texture. 

    -   A texture target is associated with the pbuffer, so that cubemap 
        images can be rendered into a single color buffer. 

    Note that this extension may be used in conjunction with other 
    extensions to associate video images/buffers to pbuffers.  Once the 
    video image is associated with a pbuffer it can be used as a texture.
    Also, if SGIX_generate_mipmap is supported, it is possible to 
    create a complete set of mipmap images from a single color buffer. 

IP Status 

    There are no known IP issues. 

Issues 

 1. Should we support 3D textures? What about 1D textures? 

    3D textures - No. This adds a lot of implementation burden without 
    having a good usage model.

    1D textures - Yes. Just a special case of 2D texture.

 2. Should we allow a portion of the color buffer to be used as a texture? 
    No, if a different size texture is needed the application can just 
    create another pbuffer. 

 3. Do we need the MIPMAP_TEXTURE attribute? 

    Yes this is good to have since some architectures may require all or 
    some of the mipmaps to be stored together in memory. 

 4. Should we require power of 2 textures? 

    Yes, we will allow an implementation to fail if the texture size is 
    not a power of 2. This restriction can be relaxed later by the
    exension that allows non-power of 2 texture.

 5. Should the render texture attributes be per color buffer or per drawable? 

    There really isn't a mechanism for associating attributes with the color
    buffer. Also, allowing different render texture attributes for each 
    color buffer makes the extension more difficult to implement without 
    providing a very useful tool for applications. 

 6. What should happen if the color buffer is used for rendering before it 
    is released from the texture? 

    There are three reasonable options: generate an error, create another 
    buffer or have the rendering results be undefined.  Since this is an 
    error condition, and not a useful feature, we should pick the option 
    that is easiest to implement.  For now, we choose to have the rendering 
    results be undefined--the rendering commands will be processed and the 
    context will be updated but the pbuffer may or may  not be updated. 
    Note that the pbuffer that contains the color buffer can be bound to a 
    different context, so the invalid state must be stored with the pbuffer,
    not the context.. (Also the texture object that contains the 
    color buffer's image may be released from the current context). 

 7. Should the new pbuffer attributes be available through GL queries? 

    No, like other pbuffer attributes you need to query them through the 
    window system extension. This extension does not make any changes to 
    OpenGL. 

 8. Should we allow a subset of mipmaps to be defined? 

    No. 

 9. What happens when a pbuffer is bound as a texture and then a mode 
    change occurs and the pbuffer is lost? 

    The texture is not lost in this case. OpenGL doesn't have the notion 
    of volatile textures and this extension should not introduce them. 
    (It may be an interesting additional extension). When a color buffer 
    is bound to a texture, it must be saved and restored by the driver, 
    whenever texture memory is lost (even on a windows mode change). 

10. Should there be any restrictions on the texture operations that 
    can be performed on a color buffer? 

    Yes. We allow TexSubImage and CopyTexSubImage calls but disallow 
    TexImage and CopyTexImage calls. When a TexImage or CopyTexImage call 
    is made then the color buffer is released back to the pbuffer and 
    new memory is allocated for the texture. No mixing and matching of 
    images is allowed. In other words, it is not possible to render a 
    non-mipmapped image to a pbuffer, bind it to a texture and then 
    call TexImage2D to create the other mipmap levels. Modifying any 
    mipmap level via TexImage or CopyTexImage will cause the color 
    buffer to be released back to the pbuffer, even if that level 
    was not defined by the color buffer. 

    Also, if DeleteTextures is called on the texture target, then the 
    color buffer that is bound to the texture target is released back 
    to the pbuffer.

    The implicit release of the color buffer is intended to work just
    like an explicit release - i.e. the color buffer is available for
    rendering without the app having to call ReleaseTexImage.
    
11. When the color buffer is released from the texture (back to the pbuffer)
    should the contents be preserved? 

    No, this may prove difficult to implement on some architectures. 

12. Should releasing the color buffer from the texture (back to the pbuffer)
    affect the scissor or viewport? 

    No, since releasing the color buffer, does not change its size, it 
    should not affect the scissor or viewport. The application is also 
    responsible for updating the viewport and scissor when changing which 
    mipmap level it is rendering to (this is similar to window resize, 
    where the application is responsible for updating the scissor and 
    viewport).

13. How should swap buffers work when a color buffer is bound as a texture? 

    Since a color buffer (not a pbuffer) is bound to a texture, swap buffers
    should be a no-op. Otherwise the name of the bound buffer (FRONT, BACK) 
    will change while it is bound. Note that swap buffers works just as
    for a pbuffer when the color buffer is not bound as a texture.

14. What happens when the application binds one color buffer of a pbuffer 
    to a texture and then tries to render to another color buffer of the 
    pbuffer? 

    If any of the pbuffer's color buffers are bound to a texture, then 
    rendering results are undefined for all color buffers of the pbuffer. 

15. Should it be an error to bind a color buffer of a pbuffer to a 
    texture, if that pbuffer is current to another thread? 

    No. It is not an error to make a drawable current to two threads right 
    now. Read and draw operations produce indeterminate results when the 
    pbuffer is bound to a texture. 

16. Should we allow color buffers of all drawables (pbuffers and windows)
    to be bound to textures? 

    For now we just allow pbuffers. This is simpler since they are not 
    shared with the window system and the color buffers are not part of the 
    visible framebuffer. Also, windows can be resized at any time and 
    handling this resize would unnecessarily complicate this extension. 

17. Should we allow depth buffers to be bound as textures? 

    This extension does not provide for this but it would be an interesting 
    additional extension. When a color buffer is bound to a texture, only 
    the color buffer is moved--ancillary buffers continue to be bound to 
    the pbuffer. 

    This extension is written such that adding depth textures should
    be very easy.

18. What happens when a color buffer is bound to a shared texture object? 

    Since the color buffer is associated with the texture object itself, 
    it should be shared. 

19. Should we specify how this extension interacts with SGIS_generate_mipmap? 

    No, since this is a potential ARB extension and SGIS_generate_mipmap 
    is not. If SGIS_generate_mipmap is supported along with this extension,
    then if wglBindTexImageARB is called and both GENERATE_MIPMAP_SGIS and 
    WGL_MIPMAP_TEXTURE_ARB are TRUE, then a set of mipmaps should be 
    generated. This behaviour needs to be documented in the 
    SGIS_generate_mipmap (or equivalent) extension. 

20. Should we support borders on render textures? 

    No. Although borders are part of 1.2.1, they are often not supported 
    and better techniques (such as virtual textures) are starting to 
    become available for paging in large textures. 

21. Should wglBindTexImageARB take an attribute indicating whether 
    mipmaps are defined or should this be implied from the 
    WGL_MIPMAP_TEXTURE_ARB attribute of the pbuffer? 

    This should be implied from the WGL_MIPMAP_TEXTURE_ARB attribute 
    since GL allows controls for the applications to use only level zero 
    image even if the pbuffer has been defined large enough to
    store mipmaps.

22. This extension introduces pbuffer attributes that can be modified. 
    (Previously all pbuffer attributes were static and could not be 
    changed.) Should we allow the non-static attributes to be set when the 
    pbuffer is created or should we require the application to call 
    wglSetPbufferAttribARB? 

    We require the application to call wglSetPbufferAttribARB to set 
    non-static Pbuffer attributes since this seems to be more consistent 
    with OpenGL specification.

23. Do we need WGL_TEXTURE_FORMAT_ARB or is WGL_ALPHA_BITS_ARB enough
    to distinguish between selecting RGB vs. RGBA textures? Additionally,
    how is this parameter defined for non texture buffers.

    Resolved: In order to accommodate RGBA visuals to support RGB textures
    (i.e. ignore alpha) and to allow the specification to be extensible
    for depth textures, WGL_TEXTURE_FORMAT_ARB is required in this
    specification. This parameter is defined as WGL_NO_TEXTURE_ARB for
    non texture buffers.

24. Should luminance and Intensity texture formats be allowed?

    No. WGL doesn't support single-channel framebuffer formats. Allowing
    these formats would require a copy to reformat a RGB/RGBA framebuffer
    to a Luminance or Intensity format. If luminance framebuffer gets
    added to WGL, then this feature can be added at that time.

Implementation Notes

 1. In order to prevent releases of a pbuffer from the texture object
    and to deal with implicit release followed by an explicit release,
    the GL implementation can keep a reference to any texture pbuffer
    in the texture object. When the pbuffer is released, this handle
    is set to NULL. Subsequent requests for releasing the texture
    pbuffer are ignored.

 2. The implicit release of the color buffers has been specifed to 
    work just like the explicit release so that the implementation
    can delete a texture object (one of the implicit free cases) without 
    having to track whether the texture was associated with any color buffers.

Intended Usage 

    To define a cube map texture, single threaded case 

    1)  Create the rendering window. Call wglChoosePixelFormatARB and 
        find a suitable pixel format for rendering the image. Set the pixel 
        format for the rendering window to this pixel format. 

    2)  Create the pbuffer. Call wglChoosePixelFormatARB and find a 
        suitable pixel format for rendering the texture.  
        WGL_DRAW_TO_PBUFFER and WGL_BIND_TO_TEXTURE_RGB_ARB or 
        WGL_BIND_TO_TEXTURE_RGBA_ARB must be TRUE. Create the pbuffer 
        with this pixel format. Set the pbuffer width and height to the 
        width and height of the level zero image. Set WGL_TEXTURE_FORMAT_ARB 
        to be WGL_TEXTURE_RGB_ARB or WGL_TEXTURE_RGBA_ARB. Also set 
        WGL_TEXTURE_TARGET_ARB to WGL_TEXTURE_CUBE_MAP_ARB. 

    3)  Create a context for the pbuffer. Make the context current to the 
        pbuffer and initialize the context's attributes. 

    4)  Render all the cube map faces to the pbuffer. Call 
        wglSetPbufferAttribARB to set the cube map face before rendering
        each face. Call glFlush. 

    5)  Create a context for the window. Make the context current to the 
        window and intialize the contexts attributes. Bind a texture object 
        to the TEXTURE_CUBE_MAP_ARB target and set the texture parameters 
        to the desired values. 

    6)  Call wglBindTexImageARB to bind the pbuffer drawable to the cube 
        map texture. Set <iBuffer> to WGL_FRONT or WGL_BACK depending upon
        which color buffer was used for rendering the cube map.

    7)  Render to the window using the cube map texture. 

    8)  Call wglReleaseTexImageARB to release the color buffer of the 
        pbuffer. Goto step 4 to generate more frames. 

    To define a 2D texture, single threaded case 

    In step 2, set the WGL_TEXTURE_TARGET_ARB to WGL_TEXTURE_2D_ARB.

    Since a 2D texture does not have multiple faces, in step 5
    there is no need to call wglSetPbufferAttribARB. 

    In addition, if mipmaps are to be generated, the step 5 should
    be repeated multiple times with calls to wglSetPbufferAttribARB
    to set different mip levels.

New Procedures and Functions 

    BOOL wglBindTexImageARB (HPBUFFERARB hPbuffer, int iBuffer)

    BOOL wglReleaseTexImageARB (HPBUFFERARB hPbuffer, int iBuffer) 

    BOOL wglSetPbufferAttribARB (HPBUFFERARB hPbuffer, 
        const int *piAttribList) 

New Tokens 


        WGL_BIND_TO_TEXTURE_RGB_ARB         0x2070
        WGL_BIND_TO_TEXTURE_RGBA_ARB        0x2071


        WGL_TEXTURE_FORMAT_ARB              0x2072
        WGL_TEXTURE_TARGET_ARB              0x2073
        WGL_MIPMAP_TEXTURE_ARB              0x2074


        WGL_TEXTURE_RGB_ARB                 0x2075
        WGL_TEXTURE_RGBA_ARB                0x2076
        WGL_NO_TEXTURE_ARB                  0x2077


        WGL_TEXTURE_CUBE_MAP_ARB            0x2078
        WGL_TEXTURE_1D_ARB                  0x2079
        WGL_TEXTURE_2D_ARB                  0x207A
        WGL_NO_TEXTURE_ARB                  0x2077


        WGL_MIPMAP_LEVEL_ARB                0x207B
        WGL_CUBE_MAP_FACE_ARB               0x207C


        WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB     0x207D
        WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB     0x207E
        WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB     0x207F
        WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB     0x2080
        WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB     0x2081 
        WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB     0x2082


        WGL_FRONT_LEFT_ARB                  0x2083
        WGL_FRONT_RIGHT_ARB                 0x2084
        WGL_BACK_LEFT_ARB                   0x2085
        WGL_BACK_RIGHT_ARB                  0x2086
        WGL_AUX0_ARB                        0x2087 
        WGL_AUX1_ARB                        0x2088 
        WGL_AUX2_ARB                        0x2089 
        WGL_AUX3_ARB                        0x208A 
        WGL_AUX4_ARB                        0x208B 
        WGL_AUX5_ARB                        0x208C 
        WGL_AUX6_ARB                        0x208D
        WGL_AUX7_ARB                        0x208E 
        WGL_AUX8_ARB                        0x208F 
        WGL_AUX9_ARB                        0x2090

