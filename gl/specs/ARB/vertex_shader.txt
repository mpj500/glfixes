Name

    ARB_vertex_shader

Name Strings

    GL_ARB_vertex_shader

Contributors

    Kurt Akeley
    Allen Akin
    Dave Baldwin
    Pat Brown
    Matt Craighead
    Cass Everitt
    Evan Hart
    Phil Huxley
    Dale Kirkland
    John Kessenich
    Steve Koren
    Jon Leech
    Bill Licea-Kane
    Benjamin Lipchak
    Barthold Lichtenbelt
    Kent Lin
    Jeremy Morris
    Teri Morrison
    Glenn Ortner
    Randi Rost
    Jeremy Sandmel
    Folker Schamel
    Eskil Steenberg

    The ARB_vertex_program working group members. Several concepts and
    chunks of text are copied from the ARB_vertex_program specification.

Contact

    Barthold Lichtenbelt, 3Dlabs, Inc. (barthold 'at' 3dlabs.com)
    Randi Rost, 3Dlabs, Inc. (rost 'at' 3dlabs.com)

Notice

    Copyright (c) 2003-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

IP Status

    As described in the Contributor License, which can be found at
    http://developer.3dlabs.com/openGL2/specs/3dlabs_contributor.pdf .

Status

    Complete. Approved by the ARB on June 11, 2003.
    Updated revision 0.81 approved by the ARB on June 17, 2004.

Version

    Last Modified Date: December 14, 2009
    Author Revision: 0.83

Number

    ARB Extension #31

Dependencies

    OpenGL 1.0 is required.

    This extension is written against version 1.10 of the OpenGL Shading
    Language Specification.

    The extension is written against the OpenGL 1.4 Specification.

    The ARB_shader_objects extension is required.

Overview

    This extension adds programmable vertex level processing to OpenGL. The
    application can write vertex shaders in a high level language as defined
    in the OpenGL Shading Language specification. The language itself is not
    discussed here. A vertex shader replaces the transformation, texture
    coordinate generation and lighting parts of OpenGL, and it also adds
    texture access at the vertex level. Furthermore, management of vertex
    shader objects and loading generic attributes are discussed. A vertex
    shader object, attached to a program object, can be compiled and linked
    to produce an executable that runs on the vertex processor in OpenGL.
    This extension also defines how such an executable interacts with the
    fixed functionality vertex processing of OpenGL 1.4.

Issues

    1) What does need to be said about invariance (Appendix A of the OpenGL
       1.4 spec)?

    DISCUSSION: Numerous rules and proposals have been discussed. In the
    end, simplicity is an important goal. It is always possible to later add
    more invariance rules, if it turns out to be desirable.

    RESOLUTION: The same shader will produce the same result when run
    multiple times with the same input. The wording 'the same shader' means
    a program object that is populated with the same source strings, which
    are compiled and then linked, possibly multiple times. This program
    object is executed using the same GL state vector.

    Position invariance between a vertex shader and the fixed functionality
    pipeline is important for certain applications. Therefore there must be
    a way to guarantee that a vertex shader produces the exact same position
    for a vertex as the fixed function pipeline does. This is achieved by
    using the built-in function ftransform in a vertex shader, and assign it
    to the output variable gl_Position. The shader does this instead of
    computing the product of the ModelViewProjection matrix with the vertex
    position. See section 2.15.6 for more.

    2) Should we take the API commands to load generic vertex attributes
       from ARB_vertex_program?

    DISCUSSION: At first glance these commands, for example
    VertexAttrib3fvARB, look like exactly what this extension needs.
    However, if we re-use these commands here, how does the GL
    implementation decide where attributes go when using shaders written
    using ARB_vertex_program or this extension? What happens to the
    attribute value when switching between an ARB_vertex_program and an
    ARB_vertex_shader shader? How does this resolve with respect to
    undefined aliasing defined in ARB_vertex_program and the no aliasing
    defined in this extension?

    RESOLUTION: Resolved, we will re-use these entry points. It is very
    convenient for an ISV to be able to re-use the entry points to load
    data, and only have to switch shaders when it wants to go from an
    ARB_vertex_program shader to an ARB_vertex_shader shader. This extension
    allows for no aliasing among generic attributes and standard vertex
    attributes, whereas ARB_vertex_program has the concept of undefined
    aliasing. In order to resolve this the interactions section extends
    ARB_vertex_program to expose this no aliasing approach. Note that we do
    not lift the restriction in the grammar on invalid attribute binding
    pairs, see Table X.2.1 in the ARB_vertex_program specification.

    3) Should we take the API commands to load generic vertex arrays from
       ARB_vertex_program?

    DISCUSSION: See issue 2.

    RESOLUTION: Resolved, yes we will re-use these entry points. See also
    the previous issue resolution.

    4) Should we take the API commands to query the values of generic
       attributes from ARB_vertex_program?

    DISCUSSION: This goes hand in hand with issue 2.

    RESOLUTION: Yes we will.

    5) Do we need to specify how Evaluators and AUTO_NORMAL generation
       interacts?

    DISCUSSION: ARB_vertex_program specifies that for evaluated normals the
    normal is no longer automatically normalized when a vertex shader is
    active. This is discussed in detail in issue 92 in the
    ARB_vertex_program specification.

    RESOLUTION: We will follow ARB_vertex_program.

    6) What should the initial value of the generic vertex attributes be?

    DISCUSSION: ARB_vertex_program leaves their initial values undefined. It
    seems to make sense to do so, because of the undefined aliasing. In this
    extension there is no aliasing among conventional and generic
    attributes. Hence it could be desirable to define the initial values to
    be (0, 0, 0, 1).

    RESOLUTION: The initial values are (0, 0, 0, 1).

    7) Do generic attributes push and pop?

    DISCUSSION: There has been some concern that adding more state than
    strictly necessary is a performance issue for applications that push and
    pop a lot. Conventional attributes are pushed and popped, as well as
    generic attributes, by ARB_vertex_program.

    RESOLUTION: YES, they are part of GL state, and such should push and pop
    under the 'current' bit. Note that an OpenGL implementation could track
    if a generic attribute has been set, and as long as it has not, never
    push/pop that attribute.

    8) How does user clipping work?

    DISCUSSION: The OpenGL Shading Language provides a gl_ClipVertex
    built-in variable in the vertex shading language. This variable provides
    a place for vertex shaders to specify a coordinate to be used by the
    user clipping plane stage. The user must ensure that the clip vertex and
    user clipping planes are defined in the same coordinate space. Note that
    this is different than ARB_vertex_program, where user clipping is
    ignored unless the position invariant option is enabled (where all
    vertex transformation options are performed by the fixed functionality
    pipeline). Here are some tips on how to use user clipping in a vertex
    shader:

      1) When using a traditional transform in a vertex shader, compute the
         eye coordinates and store the result in gl_ClipVertex.

      2) If clip planes are enabled with a vertex shader, gl_ClipVertex must
         be written to, otherwise results will be undefined.

      3) When doing object-space clipping, keep in mind that the clip planes
         are automatically transformed to eye coordinates (see section 2.11
         of the GL 1.4 spec). Use an identity modelView matrix to avoid this
         transformation.

    RESOLUTION: Resolved. See also section 2.11.

    9) Do we need a vertex shader point size enable?

    DISCUSSION: ARB_vertex_program provides an enable,
    VERTEX_PROGRAM_POINT_SIZE_ARB. This extension uses the same enable. If
    VERTEX_PROGRAM_POINT_SIZE mode is enabled, and a vertex shader is
    active, then the point size is taken from the vertex shader's point size
    result, otherwise it is taken from the PointSize command. The OpenGL
    Shading Language provides a built-in gl_PointSize that a vertex shader
    can write to, to specify the point size in pixels. If gl_PointSize is
    not written while the point size mode is enabled then the point size
    used in the rasterization stage is undefined.

    This point size enable is convenient for the majority of applications
    who do not change the point size. Not setting the enable means the point
    size is picked up automatically, instead of having to write a shader
    which always outputs the same point size.

    RESOLUTION: Yes.

    10) How to handle the color sum stage?

    DISCUSSION: It is the vertex shader's responsibility to write a primary
    and secondary color into the appropriate built in varying variables, if
    subsequent stages in the pipeline use these. Otherwise results are
    undefined. Section 3.9 of the OpenGL 1.4 spec states that the color sum
    stage is always applied when lighting is enabled, ignoring the value of
    the COLOR_SUM enable bit. Should we take out this automatic enable when
    lighting is enabled?

    RESOLUTION: This automatic enable will only have effect when no vertex
    shader is active. This behavior is the same in ARB_vertex_program.

    11) Does generic attribute zero also provoke (signal the end of a
        vertex), or just the glVertex command?

    DISCUSSION: To be more compatible with ARB_vertex_program this would be
    desirable. It may be that no attribute directly expresses a vertex
    position. The shader may derive the position based on multiple
    attributes, where there is no clear attribute that can be marked as "the
    vertex". On the other hand, it is mandatory in a vertex shader to write
    to gl_Vertex. Thus it makes some sense that the glVertex API has to be
    used to signal the end of a vertex.

    RESOLUTION: Resolved. For compatibility reasons, attribute zero will
    also provoke.

    12) How to handle texture access from a vertex shader?

    DISCUSSION: The OpenGL Shading Language allows for texture access from a
    vertex shader. What is the OpenGL support necessary to make that
    actually happen? Two approaches seem feasible. 1) Virtualize the number
    of texture image units available in OpenGL. Deprecate the concept of
    binding a texture object to a texture image unit. Instead, bind a
    texture object directly to a sampler. 2) A not so drastic approach that
    makes a maximum number of texture image units available to a vertex
    shader as well as to the fragment processing part of the OpenGL
    pipeline. The sum of the available texture image units cannot exceed the
    constant MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB.

    RESOLUTION: Option 2) is what is used in this specification. Option 1)
    is a more invasive approach, and left for a future extension.

    This approach allows for two types of hardware. One where the hardware
    resources to perform the functions associated with a texture image unit
    are not shared between a vertex and fragment shader, and one type of
    hardware where they are shared. The maximum number of texture image
    units available to a vertex shader is
    MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB. The maximum number of texture image
    units available to the fragment stage of OpenGL is
    MAX_TEXTURE_IMAGE_UNITS_ARB. Now consider, for example, an
    implementation that supports up to 16 texture stages and shares its
    texture mapping resources between the vertex shader and fragment shader.
    For this implementation MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB,
    MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB and MAX_TEXTURE_IMAGE_UNITS_ARB would
    all be set to 16. A hardware implementation which does not share its
    texture mapping resources, and who can support 2 texture stages for a
    vertex shader and 16 texture stages for the fragment processing, would
    set MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB to 18,
    MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB to 2 and MAX_TEXTURE_IMAGE_UNITS_ARB
    to 16. A vertex shader cannot use more than
    MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB texture image units. The fragment
    processing part of OpenGL cannot use more than
    MAX_TEXTURE_IMAGE_UNITS_ARB texture image units.

    Both the vertex shader and fragment processing combined cannot use more
    than MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB texture image units. If a
    vertex shader and fragment processing part of OpenGL both use the same
    texture image unit, then that counts as separate units against the above
    mentioned limits.

    Automatic LOD calculation does not happen during vertex processing in a
    vertex shader, hence there is no automatic selection of an image array
    level. Minification or magnification of a texture map is controlled by a
    LOD value passed as an argument in some of the built-in texture lookup
    functions. These built-in texture lookup functions, defined in the
    OpenGL Shading Language, come in two flavors. One set of lookup
    functions that take a LOD value as an input, and one set that does not
    take a LOD value.

    If the former set of functions is used, then the LOD value passed in is
    used directly as the LOD value lambda' in section 3.8.8 equation 3.16 on
    page 140 of the OpenGL 1.4 spec. This in turn defines lambda, which then
    is used as usual to determine magnification or minification and, when
    mipmapping, which mipmap array(s) to select.

    If the latter set of functions is used, then lambda, the result of
    equation 3.16, is set to zero. This effectively means a texture object
    is considered magnified, and only paragraph 3.8.9 applies.

    13) Do we split a texture unit into a texture image unit and a texture
        coordinate set?

    DISCUSSION: This is what ARB_fragment_program does, and
    ARB_fragment_shader as well. The OpenGL Shading Language allows for
    texture lookups in a vertex shader. This means that a vertex shader
    should have access to a texture image unit (texture maps and associated
    parameters). A vertex shader also has access to state stored with a
    texture coordinate set, which encompasses vertex texture coordinate
    attributes, as well as the texture matrix stack and texture generation
    state. The number of supported texture image units and texture
    coordinate sets is not necessarily the same on a particular
    implementation.

    RESOLUTION: Yes

    14) Do we need to specify different texture coordinate sets for a vertex
        shader and fragment processing?

    DISCUSSION: So far there are MAX_TEXTURE_COORDS_ARB texture coordinate
    sets. This constant is defined in ARB_fragment_program, and re-used in
    ARB_fragment_shader as well as the OpenGL Shading Language (see built-in
    constants, section 7.4). Only a vertex shader has access to vertex
    texture coordinate attributes. But both an ARB vertex and fragment
    shader has access to the other state associated with a texture
    coordinate set. That state is texture generation and the texture matrix
    stack.

    RESOLUTION: NO.

    15) What is the minimum value for MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB?

    DISCUSSION: Should this be zero, or more?

    RESOLUTION: Resolved, zero.

    16) Do we also need a built in function to guarantee position invariance
        with respect to user clip planes?

    DISCUSSION: Issue 1 discusses invariance with respect to the vertex
    position. A vertex shader however can also output coordinates used for
    subsequent user clipping, by writing to gl_ClipVertex. In other words,
    do we need something like gl_ClipVertex = ftransformClip()?

    RESOLUTION: NO, position invariance with respect to user clipping seems
    like a rarely needed feature. The OpenGL Shading Language does not have
    a ftransformClip() built-in function. If this functionality is ever
    needed, it is easy to add later.

    17) What happens to the point size when a vertex shader is active?

    DISCUSSION: The point size is taken from the built-in gl_PointSize when
    VERTEX_PROGRAM_POINT_SIZE_ARB is enabled, but what to do with distance
    attenuation and point fade (see Section 3.3)?

    RESOLUTION: Resolved. The vertex shader should compute distance
    attenuation. Fixed function computes it as a function of, among others,
    eyeZ. It is not required for a vertex shader to compute eyeZ, and the
    fixed function eyeZ might have nothing to do with the vertex position
    computed in the vertex shader. Point fade, however, should still be
    fixed function. The vertex shader could compute a point fade, but it'll
    produce incorrect results if the application issues the following
    commands:

      glPolygonMode(GL_FRONT, GL_FILL);
      glPolygonMode(GL_BACK, GL_POINT);

    In this case you would want to fade if a vertex belonged to a
    back-facing triangle, but not if it could belong to a front-facing one.

    18) What is the deal with range and precision of colors once output from
        the vertex shader?

    DISCUSSION: Section 2.13.6 of the GL 1.4 spec specifies that all
    components of both the primary and secondary colors be clamped to the
    range [0,1]. Section 2.13.9 furthermore specifies that each color
    component be converted to a fixed-point value with enough bits to
    satisfy the frame buffer depth. Section 2.1.1 says that the maximum
    representable magnitude of a floating-point number for colors must be at
    least 2^10.

    It is desirable to bypass clamping of colors when an ARB_fragment_shader
    shader is also active. It has utility to be able to exceed the range
    [0,1] and deal with extended range colors in a fragment shader.

    Varying variables, including the built-in color variables, are declared
    as floating point vectors in the OpenGL Shading Language, and
    interpolated as floating-point values. It does not seem to make much
    sense to specify a conversion to fixed-point after the ARB vertex shader
    writes colors, then interpolate those fixed-point colors, then convert
    the interpolated values back to floating point for input in the ARB
    fragment shader.

    ARB_fragment_program leaves the primary and secondary colors as the only
    varying variables that have less range (2^10) than any other varying. It
    promoted texture coordinates to full citizens with a maximum
    representable magnitude of at least 2^32.

    There are three cases to consider:

      1) An ARB_vertex_shader shader writing colors that are consumed by an
         ARB_fragment_shader shader.
      2) An ARB_vertex_shader shader writing colors that are consumed by an
         ARB_fragment_program shader.
      3) An ARB_vertex_shader shader writing colors that are consumed by
         fixed-function fragment processing.

    An argument can be made that a shader writer can bypass the clamping and
    conversion to fixed-point by defining its own varying variables, and use
    that to interpolate colors. It can then use the built-in gl_FrontFacing
    in a fragment shader for front or back face color selection. This is
    certainly true, but it bypasses the (fixed-function) front and back face
    color selection, which happens in a stage after the vertex shader. This
    front/back face selection stage can only be used when writing to the
    vertex shader built-in gl_FrontColor, gl_BackColor,
    gl_FrontSecondaryColor and gl_BackSecondaryColor.

    RESOLUTION: We anticipate future extensions will generalize the final
    color-processing clamp with an enable/disable clamp. Therefore, this
    specification will leave the final color clamp and conversion to
    fixed-point in place for gl_FrontColor, gl_FrontSecondaryColor,
    gl_BackColor, and gl_BackSecondaryColor.

    19) How do I get a list of all attributes and their types used by a
        shader and when do I bind generic vertex attributes?

    DISCUSSION: GetActiveAttribARB will return the name of an attribute and
    its type declared and actually used in the shader, as determined by the
    compiler and linker. Looping over all attributes and calling
    GetActiveAttribARB will generate the list of attribute names and types
    used in a shader. This list is called the active attributes list.
    GetActiveAttribARB can be called after a link attempt. It is not
    necessary for the link to have succeeded. After all, one of the reasons
    the link failed could be that there are too many active attributes. It
    is not required to call BindAttribLocationARB before issuing
    GetActiveAttribARB. BindAttributeLocationARB can be called any time. In
    order to have a BindAttribLocationARB command take effect, the program
    object will have to be (re)linked. Thus the order of commands to get the
    list of active attributes could be: Link the program object, call
    GetActiveAttribARB as many times as needed, call BindAttribLocationARB
    one or more times, then call link again.

    It is allowed to issue BindAttribLocationARB before any vertex shader
    objects are attached to a program object. Hence it is allowed to bind
    any name to a location, including a name that is never used as an
    attribute in any vertex shader object.

    RESOLUTION: Resolved, call GetActiveAttribARB.

    20) Who assigns vertex attribute variable names to indices used in the
        VertexAttrib*ARB commands?

    DISCUSSION: Both the GL and the application can do this. The linker will
    assign indices to vertex attributes declared in a vertex shader. These
    values can be queried by the application and used to load values for the
    generic vertex attributes. Alternatively the application can override
    this assignment, and bind attribute variable names to any generic vertex
    attribute index of their choice, within the range 0 to
    MAX_VERTEX_ATTRIBS_ARB. An application would have to do this when
    building a display list, for example. In this case it is possible to
    generate the display list before the program object has even been
    created.

    Only indices for generic attributes can be queried, or set. Conventional
    attributes are handled by the GL, and guaranteed to not alias with
    generic attributes.

    RESOLUTION: Both the GL and the application.

    21) How should this extension handle changes to material state within
        Begin/End?

    DISCUSSION: Supporting per-vertex material properties places additional
    pressure on the number of per-vertex bindings an OpenGL implementation
    can support, which already is a scarce resource.

    RESOLUTION: Materials are declared as uniforms in the OpenGL Shading
    Language. Any changes to the material properties inside a Begin/End
    through Material commands, or indirectly through ColorMaterial and Color
    commands, are not guaranteed to actually update material state until the
    next End command. At that point, all material property state is
    guaranteed to be updated.

    In practice, material properties are usually not changed within
    Begin/End. Applications needing to change material properties inside a
    Begin/End in a vertex shader can work around this limitation by storing
    the color in a conventional or generic vertex attribute and modifying
    the vertex shader accordingly.

    22) What space are gl_Position and gl_ClipVertex in?

    DISCUSSION: The GL treats the values in the built-in output variable
    gl_Position as being in clip space, for the purpose of clipping against
    the clip volume. See Section 2.11 of the OpenGL 1.4 specification. The
    GL treats the values in the (optional) built-in output variable
    gl_ClipVertex as being in eye-space for clipping against a
    client-defined clip plane.

    RESOLUTION: clip-space and eye-space respectively.

    23) What texture operations are not affected by a vertex shader
    performing a texture lookup?

    RESOLUTION: Whether or not a vertex shader is active, the following
    operations still behave as specified:

      * texture image specification (pp. 119-128)
      * alternate texture image specification (pp. 128-132)
      * compressed texture image specification (pp. 132-135)
      * texture parameters behave as specified even when a texture is
        accessed from within a vertex shader (pp. 135-147)
      * texture state and proxy state (pp. 148-149)
      * texture object specification (pp. 149-152)
      * texture comparison modes (p. 157)

New Procedures and Functions

    void VertexAttrib1fARB(uint index, float v0)
    void VertexAttrib1sARB(uint index, short v0)
    void VertexAttrib1dARB(uint index, double v0)
    void VertexAttrib2fARB(uint index, float v0, float v1)
    void VertexAttrib2sARB(uint index, short v0, short v1)
    void VertexAttrib2dARB(uint index, double v0, double v1)
    void VertexAttrib3fARB(uint index, float v0, float v1, float v2)
    void VertexAttrib3sARB(uint index, short v0, short v1, short v2)
    void VertexAttrib3dARB(uint index, double v0, double v1, double v2)
    void VertexAttrib4fARB(uint index, float v0, float v1, float v2, float v3)
    void VertexAttrib4sARB(uint index, short v0, short v1, short v2, short v3)
    void VertexAttrib4dARB(uint index, double v0, double v1, double v2, double v3)
    void VertexAttrib4NubARB(uint index, ubyte x, ubyte y, ubyte z, ubyte w)

    void VertexAttrib1fvARB(uint index, const float *v)
    void VertexAttrib1svARB(uint index, const short *v)
    void VertexAttrib1dvARB(uint index, const double *v)
    void VertexAttrib2fvARB(uint index, const float *v)
    void VertexAttrib2svARB(uint index, const short *v)
    void VertexAttrib2dvARB(uint index, const double *v)
    void VertexAttrib3fvARB(uint index, const float *v)
    void VertexAttrib3svARB(uint index, const short *v)
    void VertexAttrib3dvARB(uint index, const double *v)
    void VertexAttrib4fvARB(uint index, const float *v)
    void VertexAttrib4svARB(uint index, const short *v)
    void VertexAttrib4dvARB(uint index, const double *v)
    void VertexAttrib4ivARB(uint index, const int *v)
    void VertexAttrib4bvARB(uint index, const byte *v)

    void VertexAttrib4ubvARB(uint index, const ubyte *v)
    void VertexAttrib4usvARB(uint index, const ushort *v)
    void VertexAttrib4uivARB(uint index, const uint *v)

    void VertexAttrib4NbvARB(uint index, const byte *v)
    void VertexAttrib4NsvARB(uint index, const short *v)
    void VertexAttrib4NivARB(uint index, const int *v)
    void VertexAttrib4NubvARB(uint index, const ubyte *v)
    void VertexAttrib4NusvARB(uint index, const ushort *v)
    void VertexAttrib4NuivARB(uint index, const uint *v)

    void VertexAttribPointerARB(uint index, int size, enum type, boolean normalized,
                                sizei stride, const void *pointer)

    void EnableVertexAttribArrayARB(uint index)
    void DisableVertexAttribArrayARB(uint index)

    void BindAttribLocationARB(handleARB programObj, uint index, const charARB *name)

    void GetActiveAttribARB(handleARB programObj, uint index, sizei maxLength,
                             sizei *length, int *size, enum *type, charARB *name)

    GLint GetAttribLocationARB(handleARB programObj, const charARB *name)

    void GetVertexAttribdvARB(uint index, enum pname, double *params)
    void GetVertexAttribfvARB(uint index, enum pname, float *params)
    void GetVertexAttribivARB(uint index, enum pname, int *params)
    void GetVertexAttribPointervARB(uint index, enum pname, void **pointer)

New Tokens


        VERTEX_SHADER_ARB                               0x8B31


        MAX_VERTEX_UNIFORM_COMPONENTS_ARB               0x8B4A
        MAX_VARYING_FLOATS_ARB                          0x8B4B
        MAX_VERTEX_ATTRIBS_ARB                          0x8869
        MAX_TEXTURE_IMAGE_UNITS_ARB                     0x8872
        MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB              0x8B4C
        MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB            0x8B4D
        MAX_TEXTURE_COORDS_ARB                          0x8871


        VERTEX_PROGRAM_POINT_SIZE_ARB                   0x8642
        VERTEX_PROGRAM_TWO_SIDE_ARB                     0x8643


        OBJECT_ACTIVE_ATTRIBUTES_ARB                    0x8B89
        OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB          0x8B8A


        VERTEX_ATTRIB_ARRAY_ENABLED_ARB                 0x8622
        VERTEX_ATTRIB_ARRAY_SIZE_ARB                    0x8623
        VERTEX_ATTRIB_ARRAY_STRIDE_ARB                  0x8624
        VERTEX_ATTRIB_ARRAY_TYPE_ARB                    0x8625
        VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB              0x886A
        CURRENT_VERTEX_ATTRIB_ARB                       0x8626


        VERTEX_ATTRIB_ARRAY_POINTER_ARB                 0x8645


        FLOAT                                           0x1406
        FLOAT_VEC2_ARB                                  0x8B50
        FLOAT_VEC3_ARB                                  0x8B51
        FLOAT_VEC4_ARB                                  0x8B52
        FLOAT_MAT2_ARB                                  0x8B5A
        FLOAT_MAT3_ARB                                  0x8B5B
        FLOAT_MAT4_ARB                                  0x8B5C

