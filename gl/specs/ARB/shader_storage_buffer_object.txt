Name

    ARB_shader_storage_buffer_object

Name Strings

    GL_ARB_shader_storage_buffer_object

Contact

    Pat Brown, NVIDIA (pbrown 'at' nvidia.com)

Contributors

    Jeff Bolz, NVIDIA
    Piers Daniell, NVIDIA
    Christophe Riccio, AMD
    Graham Sellers, AMD
    Bruce Merry
    John Kessenich

Notice

    Copyright (c) 2012-2014 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete.
    Approved by the ARB on 2012/06/12.

Version

    Last Modified Date:         April 28, 2014
    Revision:                   16

Number

    ARB Extension #137

Dependencies

    OpenGL 4.0 (either core or compatibility profile) is required.

    OpenGL 4.3 or ARB_program_interface_query is required.

    This extension is written against the OpenGL 4.2 (Compatibility Profile)
    Specification.

    This extension interacts with OpenGL 4.3 and ARB_compute_shader.

    This extension interacts with OpenGL 4.3 and ARB_program_interface_query.

    This extension interacts with NV_bindless_texture.

Overview

    This extension provides the ability for OpenGL shaders to perform random
    access reads, writes, and atomic memory operations on variables stored in
    a buffer object.  Application shader code can declare sets of variables
    (referred to as "buffer variables") arranged into interface blocks in a
    manner similar to that done with uniform blocks in OpenGL 3.1.  In both
    cases, the values of the variables declared in a given interface block are
    taken from a buffer object bound to a binding point associated with the
    block.  Buffer objects used in this extension are referred to as "shader
    storage buffers".  

    While the capability provided by this extension is similar to that
    provided by OpenGL 3.1 and ARB_uniform_buffer_object, there are several
    significant differences.  Most importantly, shader code is allowed to
    write to shader storage buffers, while uniform buffers are always
    read-only.  Shader storage buffers have a separate set of binding points,
    with different counts and size limits.  The maximum usable size for shader
    storage buffers is implementation-dependent, but its minimum value is
    substantially larger than the minimum for uniform buffers.  

    The ability to write to buffer objects creates the potential for multiple
    independent shader invocations to read and write the same underlying
    memory.  The same issue exists with the ARB_shader_image_load_store
    extension provided in OpenGL 4.2, which can write to texture objects and
    buffers.  In both cases, the specification makes few guarantees related to
    the relative order of memory reads and writes performed by the shader
    invocations.  For ARB_shader_image_load_store, the OpenGL API and shading
    language do provide some control over memory transactions; those
    mechanisms also affect reads and writes of shader storage buffers.  In the
    OpenGL API, the glMemoryBarrier() call can be used to ensure that certain
    memory operations related to commands issued prior the barrier complete
    before other operations related to commands issued after the barrier.
    Additionally, the shading language provides the memoryBarrier() function
    to control the relative order of memory accesses within individual shader
    invocations and provides various memory qualifiers controlling how the
    memory corresponding to individual variables is accessed.


New Procedures and Functions

    void ShaderStorageBlockBinding(uint program, uint storageBlockIndex, 
                                   uint storageBlockBinding);

New Tokens


        SHADER_STORAGE_BUFFER                           0x90D2


        SHADER_STORAGE_BUFFER_BINDING                   0x90D3


        SHADER_STORAGE_BUFFER_START                     0x90D4
        SHADER_STORAGE_BUFFER_SIZE                      0x90D5


        MAX_VERTEX_SHADER_STORAGE_BLOCKS                0x90D6
        MAX_GEOMETRY_SHADER_STORAGE_BLOCKS              0x90D7
        MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS          0x90D8
        MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS       0x90D9
        MAX_FRAGMENT_SHADER_STORAGE_BLOCKS              0x90DA
        MAX_COMPUTE_SHADER_STORAGE_BLOCKS               0x90DB
        MAX_COMBINED_SHADER_STORAGE_BLOCKS              0x90DC
        MAX_SHADER_STORAGE_BUFFER_BINDINGS              0x90DD
        MAX_SHADER_STORAGE_BLOCK_SIZE                   0x90DE
        SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT          0x90DF


        SHADER_STORAGE_BARRIER_BIT                      0x2000        


        MAX_COMBINED_SHADER_OUTPUT_RESOURCES            0x8F39 (alias)

