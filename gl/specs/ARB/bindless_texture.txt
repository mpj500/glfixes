Name

    ARB_bindless_texture

Name Strings

    GL_ARB_bindless_texture

Contact

    Jeff Bolz, NVIDIA Corporation (jbolz 'at' nvidia.com)
    Pat Brown, NVIDIA Coproration (pbrown 'at' nvidia.com)

Contributors

    Graham Sellers, AMD
    Pierre Boudier, AMD
    Daniel Koch, NVIDIA

Notice

    Copyright (c) 2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete. Approved by the ARB on June 3, 2013.
    Ratified by the Khronos Board of Promoters on July 19, 2013.

Version

    Last Modified Date:   June 13, 2014
    Author Revision:      4

Number

    ARB Extension #152

Dependencies

    This extension is written against the OpenGL 4.0 (Compatibility Profile)
    and OpenGL Shading Language 4.00 Specifications.

    OpenGL 4.0 or later versions is required.

    This extension interacts with OpenGL 4.0 (Core Profile).

    This extension interacts with OpenGL 3.3 and ARB_sampler_objects.

    This extension interacts with OpenGL 4.2, ARB_shader_image_load_store, and
    EXT_shader_image_load_store.

    This extension interacts with NV_vertex_attrib_integer_64bit.

    This extension interacts with NV_gpu_shader5.

    This extension interacts with EXT_direct_state_access.

    This extension interacts with ARB_seamless_cube_map and
    AMD_seamless_cubemap_per_texture.

    This extension interacts with NV_gpu_program4, NV_gpu_program5, and
    EXT_shader_image_load_store.

    This extension interacts with GLSL 4.20.

    This extension interacts with NV_bindless_texture.


Overview

    This extension allows OpenGL applications to access texture objects in
    shaders without first binding each texture to one of a limited number of
    texture image units.  Using this extension, an application can query a
    64-bit unsigned integer texture handle for each texture that it wants to
    access and then use that handle directly in GLSL or assembly-based
    shaders.  The ability to access textures without having to bind and/or
    re-bind them is similar to the capability provided by the
    NV_shader_buffer_load extension that allows shaders to access buffer
    objects without binding them.  In both cases, these extensions
    significantly reduce the amount of API and internal GL driver overhead
    needed to manage resource bindings.

    This extension also provides similar capability for the image load, store,
    and atomic functionality provided by OpenGL 4.2 and the
    ARB_shader_image_load_store and EXT_shader_image_load_store extensions,
    where a texture can be accessed without first binding it to an image unit.
    An image handle can be extracted from a texture object using an API with a
    set of parameters similar to those for BindImageTextureEXT.

    This extension adds no new data types to GLSL.  Instead, it uses existing
    sampler and image data types and allows them to be populated with texture
    and image handles.  This extension does permit sampler and image data
    types to be used in more contexts than in unextended GLSL 4.00.  In
    particular, sampler and image types may be used as shader inputs/outputs,
    temporary variables, and uniform block members, and may be assigned to by
    shader code.  Constructors are provided to convert unsigned integer values
    to and from sampler and image data types.  Additionally, new APIs are
    provided to load values for sampler and image uniforms with 64-bit
    handle inputs.  The use of existing integer-based Uniform* APIs is still
    permitted, in which case the integer specified will identify a texture
    image or image unit.  For samplers and images with values specified as
    texture image or image units, the GL implemenation will translate the unit
    number to an internal handle as required.

    To access texture or image resources using handles, the handles must first
    be made resident.  Accessing a texture or image by handle without first
    making it resident can result in undefined results, including program
    termination.  Since the amount of texture memory required by an
    application may exceed the amount of memory available to the system, this
    extension provides API calls allowing applications to manage overall
    texture memory consumption by making a texture resident and non-resident
    as required.


New Procedures and Functions

    uint64 GetTextureHandleARB(uint texture);
    uint64 GetTextureSamplerHandleARB(uint texture, uint sampler);

    void MakeTextureHandleResidentARB(uint64 handle);
    void MakeTextureHandleNonResidentARB(uint64 handle);

    uint64 GetImageHandleARB(uint texture, int level, boolean layered,
                             int layer, enum format);

    void MakeImageHandleResidentARB(uint64 handle, enum access);
    void MakeImageHandleNonResidentARB(uint64 handle);

    void UniformHandleui64ARB(int location, uint64 value);
    void UniformHandleui64vARB(int location, sizei count, const uint64 *value);
    void ProgramUniformHandleui64ARB(uint program, int location,
                                     uint64 value);
    void ProgramUniformHandleui64vARB(uint program, int location,
                                      sizei count, const uint64 *values);

    boolean IsTextureHandleResidentARB(uint64 handle);
    boolean IsImageHandleResidentARB(uint64 handle);


    // Inherited from NV_vertex_attrib_integer_64bit:

    void VertexAttribL1ui64ARB(uint index, uint64EXT x);
    void VertexAttribL1ui64vARB(uint index, const uint64EXT *v);
    void GetVertexAttribLui64vARB(uint index, enum pname, uint64EXT *params);


New Tokens



        UNSIGNED_INT64_ARB                              0x140F


