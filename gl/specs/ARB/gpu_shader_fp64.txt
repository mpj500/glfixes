Name

    ARB_gpu_shader_fp64

Name Strings

    GL_ARB_gpu_shader_fp64

Contact

    Pat Brown, NVIDIA Corporation (pbrown 'at' nvidia.com)

Contributors

    Barthold Lichtenbelt, NVIDIA
    Bill Licea-Kane, AMD
    Bruce Merry, ARM
    Chris Dodd, NVIDIA
    Eric Werness, NVIDIA
    Graham Sellers, AMD
    Greg Roth, NVIDIA
    Jeff Bolz, NVIDIA
    Nick Haemel, AMD
    Pierre Boudier, AMD
    Piers Daniell, NVIDIA

Notice

    Copyright (c) 2010-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete. Approved by the ARB at the 2010/01/22 F2F meeting.
    Approved by the Khronos Board of Promoters on March 10, 2010.
    
Version

    Last Modified Date:         August 27, 2012
    NVIDIA Revision:            11

Number

    ARB Extension #89

Dependencies

    This extension is written against the OpenGL 3.2 (Compatibility Profile)
    Specification.

    This extension is written against version 1.50 (revision 09) of the OpenGL
    Shading Language Specification.

    OpenGL 3.2 and GLSL 1.50 are required.

    This extension interacts with EXT_direct_state_access.

    This extension interacts with NV_shader_buffer_load.

Overview

    This extension allows GLSL shaders to use double-precision floating-point
    data types, including vectors and matrices of doubles.  Doubles may be
    used as inputs, outputs, and uniforms.  

    The shading language supports various arithmetic and comparison operators
    on double-precision scalar, vector, and matrix types, and provides a set
    of built-in functions including:

      * square roots and inverse square roots;

      * fused floating-point multiply-add operations;

      * splitting a floating-point number into a significand and exponent
        (frexp), or building a floating-point number from a significand and
        exponent (ldexp);

      * absolute value, sign tests, various functions to round to an integer
        value, modulus, minimum, maximum, clamping, blending two values, step
        functions, and testing for infinity and NaN values;

      * packing and unpacking doubles into a pair of 32-bit unsigned integers;

      * matrix component-wise multiplication, and computation of outer
        products, transposes, determinants, and inverses; and

      * vector relational functions.

    Double-precision versions of angle, trigonometry, and exponential
    functions are not supported.

    Implicit conversions are supported from integer and single-precision
    floating-point values to doubles, and this extension uses the relaxed
    function overloading rules specified by the ARB_gpu_shader5 extension to
    resolve ambiguities.

    This extension provides API functions for specifying double-precision
    uniforms in the default uniform block, including functions similar to the
    uniform functions added by EXT_direct_state_access (if supported).

    This extension provides an "LF" suffix for specifying double-precision
    constants.  Floating-point constants without a suffix in GLSL are treated
    as single-precision values for backward compatibility with versions not
    supporting doubles; similar constants are treated as double-precision
    values in the "C" programming language.

    This extension does not support interpolation of double-precision values;
    doubles used as fragment shader inputs must be qualified as "flat".
    Additionally, this extension does not allow vertex attributes with 64-bit
    components.  That support is added separately by EXT_vertex_attrib_64bit.

IP Status

    No known IP claims.

New Procedures and Functions

    void Uniform1d(int location, double x);
    void Uniform2d(int location, double x, double y);
    void Uniform3d(int location, double x, double y, double z);
    void Uniform4d(int location, double x, double y, double z, double w);
    void Uniform1dv(int location, sizei count, const double *value);
    void Uniform2dv(int location, sizei count, const double *value);
    void Uniform3dv(int location, sizei count, const double *value);
    void Uniform4dv(int location, sizei count, const double *value);

    void UniformMatrix2dv(int location, sizei count, boolean transpose, 
                          const double *value);
    void UniformMatrix3dv(int location, sizei count, boolean transpose, 
                          const double *value);
    void UniformMatrix4dv(int location, sizei count, boolean transpose, 
                          const double *value);
    void UniformMatrix2x3dv(int location, sizei count, boolean transpose, 
                            const double *value);
    void UniformMatrix2x4dv(int location, sizei count, boolean transpose, 
                            const double *value);
    void UniformMatrix3x2dv(int location, sizei count, boolean transpose, 
                            const double *value);
    void UniformMatrix3x4dv(int location, sizei count, boolean transpose, 
                            const double *value);
    void UniformMatrix4x2dv(int location, sizei count, boolean transpose, 
                            const double *value);
    void UniformMatrix4x3dv(int location, sizei count, boolean transpose, 
                            const double *value);

    void GetUniformdv(uint program, int location, double *params);

    (All of the following ProgramUniform* functions are supported if and only
     if EXT_direct_state_access is supported.)

    void ProgramUniform1dEXT(uint program, int location, double x);
    void ProgramUniform2dEXT(uint program, int location, double x, double y);
    void ProgramUniform3dEXT(uint program, int location, double x, double y,
                             double z);
    void ProgramUniform4dEXT(uint program, int location, double x, double y, 
                             double z, double w);
    void ProgramUniform1dvEXT(uint program, int location, sizei count,
                              const double *value);
    void ProgramUniform2dvEXT(uint program, int location, sizei count,
                              const double *value);
    void ProgramUniform3dvEXT(uint program, int location, sizei count,
                              const double *value);
    void ProgramUniform4dvEXT(uint program, int location, sizei count, 
                              const double *value);

    void ProgramUniformMatrix2dvEXT(uint program, int location, sizei count, 
                                    boolean transpose, const double *value);
    void ProgramUniformMatrix3dvEXT(uint program, int location, sizei count, 
                                    boolean transpose, const double *value);
    void ProgramUniformMatrix4dvEXT(uint program, int location, sizei count, 
                                    boolean transpose, const double *value);
    void ProgramUniformMatrix2x3dvEXT(uint program, int location, sizei count, 
                                      boolean transpose, const double *value);
    void ProgramUniformMatrix2x4dvEXT(uint program, int location, sizei count, 
                                      boolean transpose, const double *value);
    void ProgramUniformMatrix3x2dvEXT(uint program, int location, sizei count, 
                                      boolean transpose, const double *value);
    void ProgramUniformMatrix3x4dvEXT(uint program, int location, sizei count, 
                                      boolean transpose, const double *value);
    void ProgramUniformMatrix4x2dvEXT(uint program, int location, sizei count, 
                                      boolean transpose, const double *value);
    void ProgramUniformMatrix4x3dvEXT(uint program, int location, sizei count, 
                                      boolean transpose, const double *value);

New Tokens


        DOUBLE_VEC2                                     0x8FFC
        DOUBLE_VEC3                                     0x8FFD
        DOUBLE_VEC4                                     0x8FFE
        DOUBLE_MAT2                                     0x8F46
        DOUBLE_MAT3                                     0x8F47
        DOUBLE_MAT4                                     0x8F48
        DOUBLE_MAT2x3                                   0x8F49
        DOUBLE_MAT2x4                                   0x8F4A
        DOUBLE_MAT3x2                                   0x8F4B
        DOUBLE_MAT3x4                                   0x8F4C
        DOUBLE_MAT4x2                                   0x8F4D
        DOUBLE_MAT4x3                                   0x8F4E


