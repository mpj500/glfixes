Name

    ARB_texture_cube_map

Name Strings

    GL_ARB_texture_cube_map

Contact

    Michael Gold, NVIDIA (gold 'at' nvidia.com)

Notice

    Copyright (c) 1999-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete. Approved by ARB on 12/8/1999

Version

    Last Modified Date: December 14, 1999

Number

    ARB Extension #7

Dependencies

    None.

    Written based on the wording of the OpenGL 1.2.1 specification but
    not dependent on it.

Overview

    This extension provides a new texture generation scheme for cube
    map textures.  Instead of the current texture providing a 1D, 2D,
    or 3D lookup into a 1D, 2D, or 3D texture image, the texture is a
    set of six 2D images representing the faces of a cube.  The (s,t,r)
    texture coordinates are treated as a direction vector emanating from
    the center of a cube.  At texture generation time, the interpolated
    per-fragment (s,t,r) selects one cube face 2D image based on the
    largest magnitude coordinate (the major axis).  A new 2D (s,t) is
    calculated by dividing the two other coordinates (the minor axes
    values) by the major axis value.  Then the new (s,t) is used to
    lookup into the selected 2D texture image face of the cube map.

    Unlike a standard 1D, 2D, or 3D texture that have just one target,
    a cube map texture has six targets, one for each of its six 2D texture
    image cube faces.  All these targets must be consistent, complete,
    and have equal width and height (ie, square dimensions).

    This extension also provides two new texture coordinate generation modes
    for use in conjunction with cube map texturing.  The reflection map
    mode generates texture coordinates (s,t,r) matching the vertex's
    eye-space reflection vector.  The reflection map mode
    is useful for environment mapping without the singularity inherent
    in sphere mapping.  The normal map mode generates texture coordinates
    (s,t,r) matching the vertex's transformed eye-space
    normal.  The normal map mode is useful for sophisticated cube
    map texturing-based diffuse lighting models.

    The intent of the new texgen functionality is that an application using
    cube map texturing can use the new texgen modes to automatically
    generate the reflection or normal vectors used to look up into the
    cube map texture.

    An application note:  When using cube mapping with dynamic cube
    maps (meaning the cube map texture is re-rendered every frame),
    by keeping the cube map's orientation pointing at the eye position,
    the texgen-computed reflection or normal vector texture coordinates
    can be always properly oriented for the cube map.  However if the
    cube map is static (meaning that when view changes, the cube map
    texture is not updated), the texture matrix must be used to rotate
    the texgen-computed reflection or normal vector texture coordinates
    to match the orientation of the cube map.  The rotation can be
    computed based on two vectors: 1) the direction vector from the cube
    map center to the eye position (both in world coordinates), and 2)
    the cube map orientation in world coordinates.  The axis of rotation
    is the cross product of these two vectors; the angle of rotation is
    the arcsin of the dot product of these two vectors.

Issues

    Should we place the normal/reflection vector in the (s,t,r) texture
    coordinates or (s,t,q) coordinates?

      RESOLUTION:  (s,t,r).  Even if hardware uses "q" for the third
      component, the API should claim to support generation of (s,t,r)
      and let the texture matrix (through a concatenation with the
      user-supplied texture matrix) move "r" into "q".

    Should the texture coordinate generation functionality for cube
    mapping be specified as a distinct extension from the actual cube
    map texturing functionality?

      RESOLUTION:  NO.  Real applications and real implementations of
      cube mapping will tie the texgen and texture generation functionality
      together.  Applications won't have to query two separate
      extensions then.

      While applications will almost always want to use the texgen
      functionality for automatically generating the reflection or normal
      vector as texture coordinates (s,t,r), this extension does permit
      an application to manually supply the reflection or normal vector
      through glTexCoord3f explicitly.

      Note that the NV_texgen_reflection extension does "unbundle"
      the texgen functionality from cube maps.

    Should you be able to have some texture coordinates computing
    REFLECTION_MAP_ARB and others not?  Same question with NORMAL_MAP_ARB.

      RESOLUTION:  YES. This is the way that SPHERE_MAP works.  It is
      not clear that this would ever be useful though.

    Should something special be said about the handling of the q
    texture coordinate for this spec?

      RESOLUTION:  NO.  But the following paragraph is useful for
      implementors concerned about the handling of q.

      The REFLECTION_MAP_ARB and NORMAL_MAP_ARB modes are intended to supply
      reflection and normal vectors for cube map texturing hardware.
      When these modes are used for cube map texturing, the generated
      texture coordinates can be thought of as an reflection vector.
      The value of the q texture coordinate then simply scales the
      vector but does not change its direction.  Because only the vector
      direction (not the vector magnitude) matters for cube map texturing,
      implementations are free to leave q undefined when any of the s,
      t, or r texture coordinates are generated using REFLECTION_MAP_ARB
      or NORMAL_MAP_ARB.

    How should the cube faces be labeled?

      RESOLUTION:  Match the render man specification's names of "px"
      (positive X), "nx" (negative x), "py", "ny", "pz", and "nz".
      There does not actually need to be an "ordering for the faces"
      (Direct3D 7.0 does number their cube map faces.)  For this
      extension, the symbolic target names (TEXTURE_CUBE_MAP_POSITIVE_X_ARB,
      etc) is sufficient without requiring any specific ordering.

    What coordinate system convention should be used?  LHS or RHS?

      RESOLUTION:  The coordinate system is left-handed if you think
      of yourself within the cube.  The coordinate system is
      right-handed if you think of yourself outside the cube.

      This matches the convention of the RenderMan interface.  If
      you look at Figure 12.8 (page 265) in "The RenderMan Companion",
      think of the cube being folded up with the observer inside
      the cube.  Then the coordinate system convention is
      left-handed.

    The spec just linearly interpolates the reflection vectors computed
    per-vertex across polygons.  Is there a problem interpolating
    reflection vectors in this way?

      Probably.  The better approach would be to interpolate the eye
      vector and normal vector over the polygon and perform the reflection
      vector computation on a per-fragment basis.  Not doing so is likely
      to lead to artifacts because angular changes in the normal vector
      result in twice as large a change in the reflection vector as normal
      vector changes.  The effect is likely to be reflections that become
      glancing reflections too fast over the surface of the polygon.

      Note that this is an issue for REFLECTION_MAP_ARB, but not
      NORMAL_MAP_ARB.

    What happens if an (s,t,q) is passed to cube map generation that
    is close to (0,0,0), ie. a degenerate direction vector?

      RESOLUTION:  Leave undefined what happens in this case (but
      may not lead to GL interruption or termination).

      Note that a vector close to (0,0,0) may be generated as a
      result of the per-fragment interpolation of (s,t,r) between
      vertices.

    Do we need a distinct proxy texture mechanism for cube map
    textures?

      RESOLUTION:  YES.  Cube map textures take up six times the
      memory as a conventional 2D image texture so proxy 2D texture
      determinations won't be of value for a cube map texture.
      Cube maps need their own proxy target.

    Should we require the 2D texture image width and height to
    be identical (ie, square only)?

      RESOLUTION:  YES.  This limitation is quite a reasonable limitation
      and DirectX 7 has the same limitation.

      This restriction is enforced by generating an INVALID_VALUE
      when calling TexImage2D or CopyTexImage2D with a non-equal
      width and height.

      Some consideration was given to enforcing the "squarness"
      constraint as a texture consistency constraint.  This is
      confusing however since the squareness is known up-front
      at texture image specification time so it seems confusing
      to silently report the usage error as a texture consistency
      issue.

      Texture consistency still says that all the level 0 textures
      of all six faces must have the same square size.

    If some combination of 1D, 2D, 3D, and cube map texturing is
    enabled, which really operates?

      RESOLUTION:  Cube map texturing.  In OpenGL 1.2, 3D takes
      priority over 2D takes priority over 1D.  Cube mapping should
      take priority over all conventional n-dimensional texturing
      schemes.

    Does anything need to be said about combining cube mapping with
    multitexture?

      RESOLUTION:  NO.  Cube mapping should be available on all texture
      units.  The hardware should fully orthogonal in its handling of
      cube map textures.

    Does it make sense to support borders for cube map textures.

      Actually, it does.  It would be nice if the texture border pixels
      match the appropriate texels from the edges of the other cube map
      faces that they junction with.  For this reason, we'll leave the
      texture border capability implicitly supported.

    How does mipmap level-of-detail selection work for cube map
    textures?

      The existing spec's language about LOD selection is fine.

    Should the implementation dependent value for the maximum
    texture size for a cube map be the same as MAX_TEXTURE_SIZE?

      RESOLUTION: NO.  OpenGL 1.2 has a different MAX_3D_TEXTURE_SIZE
      for 3D textures, and cube maps should take six times more space
      than a 2D texture map of the same width & height.  The implementation
      dependent MAX_CUBE_MAP_TEXTURE_SIZE_ARB constant should be used for
      cube maps then.

      Note that the proxy cube map texture provides a better way to
      find out the maximum cube map texture size supported since the
      proxy mechanism can take into account the internal format, etc.

    In section 3.8.10 when the "largest magnitude coordinate direction"
    is choosen, what happens if two or more of the coordinates (rx,ry,rz)
    have the identical magnitude?

      RESOLUTION:  Implementations can define their own rule to choose
      the largest magnitude coordinate direction whne two or more of the
      coordinates have the identical magnitude.  The only restriction is
      that the rule must be deterministic and depend only on (rx,ry,rz).

      In practice, (s,t,r) is interpolated across polygons so the cases
      where |s|==|t|, etc. are pretty arbitary (the equality depends on
      interpolation precision).  This extension could mandate a particular
      rule, but that seems heavy-handed and there is no good reason that
      multiple vendors should be forced to implement the same rule.

    Should there be limits on the supported border modes for cube maps?

      RESOLUTION:  NO. The specificiation is written so that cube map
      texturing proceeds just like conventional 2D texture mapping once
      the face determination is made.

      Therefore, all OpenGL texture wrap modes should be supported though
      some modes are clearly inappropriate for cube maps.  The WRAP mode
      is almost certainly incorrect for cube maps.  Likewise, the CLAMP
      mode without a texture border is almost certainly incorrect for cube
      maps.  CLAMP when a texture border is present and CLAMP_TO_EDGE are
      both reasonably suited for cube maps.  Ideally, CLAMP with a texture
      border works best if the cube map edges can be replicated in the
      approriate texture borders of adjacent cube map faces.  In practice,
      CLAMP_TO_EDGE works reasonably well in most circumstances.

      Perhaps another extension could support a special cube map wrap
      mode that automatically wraps individual texel fetches to the
      appropriate adjacent cube map face.  The benefit from such a mode
      is small and the implementation complexity is involved so this wrap
      mode should not be required for a basic cube map texture extension.

    How is mipmap LOD selection handled for cube map textures?

      RESOLUTION:  The specification is written so that cube map texturing
      proceeds just like conventional 2D texture mapping once the face
      determination is made.

      Thereforce, the partial differentials in Section 3.8.5 (page
      126) should be evaluated for the u and v parameters based on the
      post-face determination s and t.

    In Section 2.10.3 "Normal Transformation", there are several versions
    of the eye-space normal vector to choose from.  Which one should
    the NORMAL_MAP_ARB texgen mode use?

       RESOLUTION:  nf.  The nf vector is the final normal, post-rescale
       normal and post-normalize.  In practice, the rescale normal and
       normalize operations do not change the direction of the vector
       so the choice of which version of transformed normal is used is
       not important for cube maps.

New Procedures and Functions

    None

New Tokens


        NORMAL_MAP_ARB                      0x8511
        REFLECTION_MAP_ARB                  0x8512



        TEXTURE_CUBE_MAP_ARB                0x8513


        TEXTURE_BINDING_CUBE_MAP_ARB        0x8514


        TEXTURE_CUBE_MAP_POSITIVE_X_ARB     0x8515
        TEXTURE_CUBE_MAP_NEGATIVE_X_ARB     0x8516
        TEXTURE_CUBE_MAP_POSITIVE_Y_ARB     0x8517
        TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB     0x8518
        TEXTURE_CUBE_MAP_POSITIVE_Z_ARB     0x8519
        TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB     0x851A


        PROXY_TEXTURE_CUBE_MAP_ARB          0x851B


        MAX_CUBE_MAP_TEXTURE_SIZE_ARB       0x851C

