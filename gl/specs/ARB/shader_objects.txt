Name

    ARB_shader_objects

Name Strings

    GL_ARB_shader_objects

Contributors

    Kurt Akeley
    Allen Akin
    Dave Baldwin
    Bob Beretta
    Pat Brown
    Matt Craighead
    Cass Everitt
    Mandar Godse
    Evan Hart
    Phil Huxley
    Deron Dann Johnson
    James Jones
    Dale Kirkland
    John Kessenich
    Steve Koren
    Jon Leech
    Bill Licea-Kane
    Barthold Lichtenbelt
    Kent Lin
    Benjamin Lipchak
    Rob Mace
    Michael McCool
    Teri Morrison
    Jeremy Morris
    Glenn Ortner
    Ian Romanick
    Randi Rost
    Jeremy Sandmel
    Folker Schamel
    Mik Wells

Contact

    Barthold Lichtenbelt, 3Dlabs, Inc. (barthold 'at' 3dlabs.com)
    Randi Rost, 3Dlabs, Inc. (rost 'at' 3dlabs.com)

Notice

    Copyright (c) 2003-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

IP Status

    As described in the Contributor License, which can be found at
    http://www.3dlabs.com/support/developer/ogl2/specs/3dlabs_contributor.pdf.

Status

    Complete. Approved by the ARB on June 11, 2003.
    Updated revision 0.89 approved by the ARB on June 17, 2004.

Version

    Last Modified Date: December 14, 2009
    Author Revision: 0.90

Number

    ARB Extension #30

Dependencies

    OpenGL 1.0 is required.

    This extension is written against version 1.10 of the OpenGL Shading
    Language Specification.

    The extension is written against the OpenGL 1.4 Specification.

Overview

    This extension adds API calls that are necessary to manage shader
    objects and program objects as defined in the OpenGL 2.0 white papers by
    3Dlabs.

    The generation of an executable that runs on one of OpenGL's
    programmable units is modeled to that of developing a typical C/C++
    application. There are one or more source files, each of which are
    stored by OpenGL in a shader object. Each shader object (source file)
    needs to be compiled and attached to a program object. Once all shader
    objects are compiled successfully, the program object needs to be linked
    to produce an executable. This executable is part of the program object,
    and can now be loaded onto the programmable units to make it part of the
    current OpenGL state. Both the compile and link stages generate a text
    string that can be queried to get more information. This information
    could be, but is not limited to, compile errors, link errors,
    optimization hints, etc. Values for uniform variables, declared in a
    shader, can be set by the application and used to control a shader's
    behavior.

    This extension defines functions for creating shader objects and program
    objects, for compiling shader objects, for linking program objects, for
    attaching shader objects to program objects, and for using a program
    object as part of current state. Functions to load uniform values are
    also defined. Some house keeping functions, like deleting an object and
    querying object state, are also provided.

    Although this extension defines the API for creating shader objects, it
    does not define any specific types of shader objects. It is assumed that
    this extension will be implemented along with at least one such
    additional extension for creating a specific type of OpenGL 2.0 shader
    (e.g., the ARB_fragment_shader extension or the ARB_vertex_shader
    extension).

Issues

    1) What to do if part of a shader pair is not present?

    DISCUSSION: There are several shader types that go together. For
    example, a VERTEX_SHADER and a FRAGMENT_SHADER form a pair that is part
    of the geometry pipeline. It is not required to supply both shader types
    of a pair in a program object.

    RESOLUTION: If one or the other of a pair is not present in the program
    object, OpenGL will substitute the standard 1.4 OpenGL pipeline for the
    one not present. The most likely place for this substitution to happen
    is the link stage. Note that it is defined elsewhere exactly what part
    of the OpenGL 1.4 pipeline a shader replaces.

    2) Should source code string passed to ShaderSourceARB be null
       terminated?

    DISCUSSION: Source code strings should not be required to end with the
    byte 0. This is a programming language dependent concept, and interferes
    with loading source code out of files. (Memory mapping read-only files
    leaves no ability to add a 0 at the end without an extra copy).
    Development of shaders can be from files, not necessarily from embedded
    source. If null termination was required a shader's source code would be
    read from a file, based on an address and a length, then get copied to
    add a 0 on, then are passed to the compiler which promptly goes and
    finds the 0, in order to get back to an address and a length. That is
    all useless work.

    RESOLUTION: It is allowed, but not required, to have a null termination
    at the end of the string. If the string is null terminated, OpenGL can
    find out the length of the string, and the length parameter passed in
    can be set to negative one.

    3) Should the string passed in to GetUniformLocationARB be null
       terminated?

    DISCUSSION: It is not very likely that this will be a memory mapped
    file, therefore null termination can be assumed.

    RESOLUTION: Yes.

    4) Should the string returned by GetInfoLog be null terminated?

    DISCUSSION: In this case it is useful to have the info string be null
    terminated, so it can be passed to printf() directly. All other strings
    returned by the GL are also null terminated.

    RESOLUTION: YES

    5) Should GetInfoLog also return the length of the string?

    DISCUSSION: This applies to an older version of GetInfoLog, but is no
    longer applicable.

    RESOLUTION: N/A

    6) Do we need a new GLcharARB data type to handle input strings?

    DISCUSSION: Currently there is no precedence of passing in strings into
    OpenGL. This exposes a deficiency in OpenGL data types. In C++ a literal
    string is of type char. OpenGL only has GLubyte and GLbyte data types,
    defined as being unsigned char and signed char respectively. This means
    that it is not possible to pass a literal string to OpenGL using either
    GLubyte or GLbyte. For example, GetUniformLocationARB(programObj,
    "Offset") needs to have the prototype GetUniformLocationARB(handleARB
    obj, const char *string).

    RESOLUTION: YES

    7) Do we load uniforms using their string representation?

    DISCUSSION: Loading uniforms is still performance sensitive, although
    not as much as vertex attributes. Passing in a string into the load
    uniform command seems too big of a performance hit. Every time the load
    is called the string needs to be parsed and the location for the data
    computed. It is better to move this performance cost outside the load
    uniform command into GetUniformLocationARB.

    RESOLUTION: NO.

    8) Should Uniform*ARB take a program object as a parameter?

    DISCUSSION: Again, this is a performance issue. If it does, the object
    passed in needs to be validated for every uniform loaded. Instead, move
    this validation cost outside the uniform command, and have the uniform
    command modify uniforms for the currently in use program object (Set by
    UseProgramObjectARB). The validation cost is now much lower. The program
    object is validated once, when calling UseProgramObjectARB.

    RESOLUTION: NO.

    9) Should uniform values be state per program object?

    DISCUSSION: Should values loaded for uniforms be kept in a program
    object, so that they are retained across program object switches? This
    is application friendly. However, loading uniforms becomes a bit more of
    a heavy weight operation because the OpenGL implementation now has to
    store its values with the program object, and reload when the program
    object is made current, even if the previous program object already had
    the same uniform values loaded.

    RESOLUTION: YES. We don't want to force an application to re-load its
    uniforms every time a program object is used.

    10) Should the name space for uniforms be global per program object?

    DISCUSSION: If one shader object references a uniform called "foo" and
    another shader object, attached to the same program object, also
    references "foo", are those shaders referencing the same uniform? If
    they do not reference the same uniform values, uniforms now need to be
    state per shader object and loaded per shader object. Also, if a vertex
    shader references "foo" and the accompanying fragment shader also
    references "foo", it would make sense to expect those to be the same
    uniform reference.

    RESOLUTION: YES.

    11) What to do if no value is loaded for a uniform?

    DISCUSSION: A program object can be used and rendering commenced without
    loading values for all the uniforms referenced in its shader objects.
    What to do in this case? Note that the values of the uniforms are state
    belonging to the program object. Once loaded, these values are reused
    whenever the program object is in use again. Should uniforms have an
    initial value?

    RESOLUTION: Uniforms are initialized to zero.

    12) Should it be allowed to load uniforms in a display list?

    DISCUSSION: Doing so will make the display list tied to a program
    object. The location passed in to the load uniform commands is program
    object specific. However, this can still be useful for some
    applications. If a program object is in use at CallList time which does
    not match that display list, then all bets are off. See also issue 30.

    RESOLUTION: YES

    13) Do we need uniforms that are local to a program object and uniforms
        that are globally accessible by all program objects?

    DISCUSSION: ARB_vertex_program has this functionality. It seems
    convenient to be able to set a uniform once, and have its value be
    accessible across many shaders (for example, a uniform used to set a
    light position). This type of global uniform could be a performance win
    as well, its value does not have to be cached by OpenGL per program
    object, and re-loaded at every program object switch.

    RESOLUTION: This is useful, but for this version of the spec this
    functionality is deferred.

    14) Do we need INT, FLOAT and BOOL versions of the load uniform
        commands?

    DISCUSSION: There are two types to keep separate. The type the uniform
    is declared in the shader, and the type of the data the application uses
    for uniform values. There are three basic uniform types that can be
    declared in a shader: Float, Int and Bool. Thus one can envision an API
    where the uniform type is encoded in the API name, besides the
    application's data type. For example, UniformInt3iv(). Where the word
    'Int' encodes the uniform type, and 'iv' the user input data type. On
    the other hand, the uniform type information is known to the GL, and
    therefore encoding it in the API name is redundant.

    RESOLUTION: We won't encode the uniform type in the API name.

    15) There is the potential for a huge explosion of load uniform
        commands, what to do?

    DISCUSSION: We need to be able to load a vec1, vec2, vec3, or vec4, or
    arrays of vec1, arrays of vec2, arrays of vec3 or arrays of vec4.
    Furtheremore, there is a need to also load 2x2, 3x3 and 4x4 matrices,
    and arrays of 2x2, arrays of 3x3 and arrays of 4x4 matrices. The input
    values to the load uniforms commands can (traditional OpenGL) come in
    bytes, shorts, ints, floats, doubles and unsigned bytes, unsigned shorts
    and unsigned ints.

    RESOLUTION: A suggested subset is in the New Procedures and Functions
    section below.

    16) Should a special INVALID_HANDLE for the data type handleARB be
        provided, or is 0 sufficient?

    DISCUSSION: 0 is fine. There are less code defects if code compares to
    zero than some invalid handle that is defined to zero anyway.
    Applications should not compare to NULL, since NULL is not necessarily
    defined to be zero in C, only in C++. Besides, a handleARB is an
    integer.

    RESOLUTION: YES.

    17) What happens if the currently in use program object is re-linked by
        calling LinkProgramARB?

    DISCUSSION: Consider that the currently in use program object has a
    uniform named "foo". The application changed some code around in that
    program object, and still has a uniform named "foo", then calls
    LinkProgramARB. After this link call the location of "foo" does not have
    to be the same as before the link call. If LinkProgramARB does not imply
    a call to UseProgramObjectARB, then a call to Uniform*ARB to load a
    value for "foo" is ill defined. In this case, does the application use
    the old location of "foo" or the new location?

    It is consistent with other parts of OpenGL to have updates to an object
    take effect after the update without issuing another command to make the
    update active, for example the TexSubImage* commands.

    RESOLUTION: The re-linked program will be used automatically, without
    requiring a new call to UseProgarmObjectARB.

    18) Should object handles be allocated by the application or by OpenGL?

    DISCUSSION: For current OpenGL objects such as textures and display
    lists, object Ids can be assigned by the application. The Id name space
    is unique for texture objects and display lists. This resulted in a
    different API for generating and managing texture Ids or Display List
    Ids.

    It is not desirable to keep the same mechanism for general object
    management. It prevents the definition of generic operations on objects
    such as deletion and querying. It prevents the OpenGL implementation
    from managing the name space the way it sees fit. It is much more common
    for the underlying library to allocate and manage handles and thereby
    keep control of the name space. It can make using a third party supplied
    library harder or even impossible.

    RESOLUTION: Object handles should be allocated and its name space
    managed by OpenGL, not by the application.

    19) Should a handle be opaque to the application?

    DISCUSSION: A handle is only read and written by OpenGL. Therefore the
    interpretation of the value of the handle does not need to be exposed to
    the application. However, we will expose how a handle is implemented.
    Certain implementation choices for handles, like a pointer, are
    discouraged. The practical solution seems to be to make a handle an
    integer.

    RESOLUTION: YES.

    20) Do we need a way to get the source code back from a shader object?

    DISCUSSION: To stay with the OpenGL philosophy that any state that can
    be set also be queried, we need such a get. This function will return
    the last set of strings stored in a shader object. Note that this set of
    strings is not necessarily the same as the set of strings that compiled
    and linked into program object currently in use.

    RESOLUTION: YES, this is achieved through GetShaderSourceARB.

    21) Are the limits on all resources an executable uses queriable and
        known to the application?

    DISCUSSION: Various proposals have been discussed. One very important
    consideration is to end up with a specification that provides
    application portability (e.g., ISVs do not need to support multiple
    rendering back ends in order to run on all the different flavors of
    hardware). ISVs definitely would prefer the specification to say that
    the OpenGL Shading Language implementation is responsible for ensuring
    that all valid shaders must run.

    RESOLUTION: Resources that are easy to count (number of uniforms
    available to a vertex shader, number of uniforms available to a fragment
    shader, number of vertex attributes, number of varyings, number of
    texture units) will have queriable limits. The application is
    responsible for working within these externally visible limits. The
    OpenGL Shading Language implementation is responsible for virtualizing
    resources that are not easy to count (for example, the number of machine
    instructions in the final executable, number of temporary registers used
    in the final executable, etc.). The expectation is that for any
    practical application an executable (generated by the link stage) will
    run.

    22) Should a higher level shading language be layered on top of OpenGL
        instead of being designed to fit within OpenGL?

    DISCUSSION: In the current design, the OpenGL Shading Language is
    integrated into OpenGL and just provides alternative methods to the
    state controlled pipeline of OpenGL 1.4. The Stanford approach is to
    layer their shading language on top of OpenGL. This has some advantages
    and disadvantages that will become apparent when the differences are
    examined.

    The Stanford approach uses a higher abstraction level. This helps with
    writing some kinds of programs where the abstractions match the problem
    domain. For example treating lights and surfaces as abstract entities
    makes some 3D graphics operations easier, however OpenGL is now being
    used for video and image processing where this abstraction is largely
    irrelevant. Similarly many games have shunned lighting via traditional
    means and use textures (light maps) instead.

    There is nothing in the OpenGL Shading Language or bindings that prevent
    higher levels of abstractions from being layered on top of a
    programmable OpenGL. We also wish to keep the overall abstraction level
    of OpenGL at its current level.

    The Stanford approach also provides for different computational
    frequencies. By having the higher levels of abstraction where one
    program defines the current graphics operation in total allows the
    compiler to separate out the parts that need to run at the primitive
    group level, primitive level, vertex level and fragment level. The
    compiler can therefore generate the code to run on the CPU, vertex
    processor and fragment processor as appropriate. This is obviously more
    complicated to implement than having the programmer specify the programs
    to run on each part of the pipeline (although some hints are still
    required by the Stanford language), although this does make the
    virtualization of the hardware easier as the compiler has the overall
    view.

    The major disadvantage of this is that it forces more intrusive changes
    to OpenGL to support the clear delineation of the primitives, vertices
    and fragment operations. Many of the core OpenGL features have been
    replaced.

    An advantage of the current approach is that the look and feel of OpenGL
    1.4 is maintained and it allows a graceful mix and match approach during
    the transition period from fixed functionality to full programmability.

    This is not a criticism of the Stanford work, as they had no choice but
    to layer on top of OpenGL.

    RESOLUTION: The OpenGL Shading Language should be built into OpenGL, and
    not layered on top. It is also noted that if this is not the case,
    OpenGL should still have a standard shading language.

    23) Should an error be set if a glUseProgramObjectARB call is made on a
        program object that has not been successfully linked?

    DISCUSSION: This was an issue when UseProgramObject returned a Boolean
    indicating success or failure. However, it no longer does, thus an error
    has to be generated.

    RESOLUTION: YES

    24) Do we need a way to get object code back, just like the model of C
        on host processors?

    DISCUSSION: Lots in email on the arb-gl2 mailing list. This is about
    lowest-level, machine specific code that may not even be portable within
    a family of cards from the same vendor. One main goal is to save
    compilation time. There seems to be general consensus that this has
    merit.

    RESOLUTION: This is an interesting capability to have, but will be
    deferred to the next release or could be added as a separate extension.

    25) How are samplers used to access textures?

    DISCUSSION: Samplers are special uniforms used in the OpenGL Shading
    Language to identify the texture object used for each texture lookup.
    The value of a sampler indicates the texture image unit being accessed.
    The type of the sampler identifies the target on that texture image
    unit. The texture object bound to that texture image unit's target is
    then used for the texture lookup. For example, a variable of type
    sampler2D selects target TEXTURE_2D on its texture image unit. Binding
    of texture objects to targets is done as usual with BindTexture.
    Selecting the texture image unit to bind is done as usual with
    ActiveTexture.

    The location of a sampler needs to be queried with
    GetUniformLocationARB, just like any uniform variable, and its value
    needs to be set by calling Uniform1i{v}ARB.

    In the future, sampler types might allow for binding a texture object
    directly, instead of binding to a texture image unit first, to get to a
    texture object.

    RESOLUTION: Resolved

    26) Do we need a validation command as a developers aid?

    DISCUSSION: The LinkProgramARB command will check if the code in all
    shaders in the program object will link. It will catch things like
    having too many active samplers, a mismatch between varyings in a vertex
    and fragment shader, etc. However, it will not check for any errors
    related to the values of uniforms or inconsistent OpenGL state that
    would result in undefined behavior or worse, prevent a program object
    from executing. A validation command could check for things like a
    mismatch between a shadow texture lookup and no TEXTURE_COMPARE_MODE
    set. Or check for values of samplers being out of range. Or check for
    samplers of different types being used to access the same texture image
    unit, etc. This validate command will at least do all the validation
    that needs to occur at render time, and it could do anything extra that
    might help the developer understand their shader(s) better. Note that it
    is not necessary to call validate, it only is a development tool.

    RESOLUTION: YES, this is a desirable feature.

    27) Should there be an info log per object?

    DISCUSSION: To store the info log per object created is consistent with
    the whole object model. However, it might not be useful to keep an info
    log around till the object is deleted. It does take resources away from
    the system. Hence we could keep one info log per object type (shader or
    program objects) as not to take too many resources.

    Alternatively, the specification could say that at least one info log is
    kept per object type, but that the GL implementation is free to keep
    more. This was considered in an earlier version of this specification,
    but broke down when considering the life time of an info log in a
    multi-context situation.

    Note that in either case the API definition for GetInfoLogARB does not
    change. The application passes in a handle for the object, and if the
    info log does not exist it returns an empty string.

    RESOLUTION: We will have an info log per object, and not worry about the
    resource usage.

    28) Is there a need to have a command to append source code to a shader
        object?

    DISCUSSION: AppendShaderARB facilitates applications that generate
    shaders on the fly. Developers can pass parts of a shader source to
    OpenGL this way. However, the application can do the same thing in its
    own memory buffer, and then pass the whole shader to OpenGL using
    ShaderSourceARB. The application usually doesn't have to copy or
    concatenate strings together. It can build a list of strings and pass
    those to OpenGL all at once using ShaderSourceARB.

    RESOLUTION: No, this is deemed not necessary.

    29) Should loading the source code into a shader object automatically
        invoke a compilation?

    DISCUSSION: Keeping the loading of source and compilation of the source
    as two distinctive API commands makes it possible for the application to
    control when an expensive operation like a compile is done. For example,
    it could first load all source for all its shaders at startup, and
    compile them as needed through the execution of the application. Keeping
    it separate leaves the most control to the application.

    RESOLUTION: No.

    30) What happens if an application tries to load more values in a
        uniform than its declared extent?

    DISCUSSION: It is possible to run off the end of a uniform, which could
    potentially corrupt other uniforms, or any data that is stored by OpenGL
    at the position next to the uniform.

    Since it is not known, nor desirable to dictate, where an implementation
    stores its uniforms, it cannot be defined what happens when a load
    uniform command runs off the end. While enforcing bounds checking is
    potentially expensive and can cost a good deal of performance, the
    safety provided by bounds checking is considered more important than the
    highest possible uniform loading performance.

    Note also that the OpenGL Shading Language states that it is undefined
    when a shader references an array element outside the array bounds.

    RESOLUTION: The GL implementation must do whatever bounds checking is
    necessary while loading uniforms. Applications that would like the
    highest API performance should strongly consider using vertex attributes
    for a small number of frequently changing values.

    31) Should UseProgramObjectARB be display-list-able?

    DISCUSSION: Consider a geometric object consisting of multiple
    primitives. The primitives within this geometric object are rendered
    using different shaders. The only way to encapsulate this into one
    display list is by allowing UseProgramObjectARB to be compiled into a
    display list. If this is not allowed, then the geometric object has to
    be broken up in potentially many display lists, creating a management
    nightmare for ISVs.

    ARB_vertex_program allows BindProgramARB to be compiled into a display
    list. Thus when using ARB_vertex_program it is possible to achieve the
    scenario described above.

    UseProgramObjectARB will generate a GL error if its operation failed, so
    that applications can still check if it succeeded.

    RESOLUTION: Yes

    32) Can you explain how uniform loading works?

    DISCUSSION: Uniform variables, including samplers, are named and
    declared in a shader. This name is a string and needs to be used in
    GetUniformLocationARB to retrieve a location ID. Once this location ID
    has been retrieved it won't change until the next call to
    LinkProgramARB. After LinkProgramARB has been issued, the application
    will have to query the location IDs of uniform variables again.
    LinkProgramARB will initialize all uniforms to zero. Note that
    GetUniformLocationARB will only return a location ID if the uniform is
    part of the set of active uniforms, else it will return -1. The set of
    active uniforms, for a given program object, can be queried with
    GetActiveUniformARB.

    Once the location ID is obtained, it can be used in the Uniform*ARB
    commands to load value(s) for the uniform. Note that the Uniform*ARB
    command used has to match the size and the type of the uniform variable.

    GetUniformLocationARB can only retrieve location IDs for uniforms
    declared as a basic type (float, int, bool and vectors thereof) and
    arrays of basic types. It is not possible to query the location ID of a
    structure, for example. The application will have to break down the
    structure into its fields until it has reached a basic type or an array
    of basic type. It does this by using the "." (dot) and "[]" operations
    in the name string passed to GetUniformLocationARB. It is possible to
    query the location ID of an element K in an array. It is possible to use
    that location ID to load multiple values into an array starting at that
    location K. However, it is not possible to take that location ID and add
    an integer N to that location ID to advance to element K + N in that
    array. The application will have to query the location ID of array
    element K + N separately.

    For example, consider the following structure:

    struct {
        struct {
            float a;
            float b[10];
        } c[2];
        vec2 d;
    } e;

    loc1 = GetUniformLocationARB(programObject, "e.d") is a valid command.
    loc2 = GetUniformLocationARB(programObject, "e.c[0]") is not valid.
    loc3 = GetUniformLocationARB(programObject, "e.c[0].b") is a valid command.
    loc4 = GetUniformLocationARB(programObject, "e.c[0].b[2]") is a valid command.

    The location loc2 cannot be retrieved because "e.c[0]" references a
    structure.

    Uniform2fARB(loc1, 1.0f, 2.0f) is a valid command.
    Uniform2iARB(loc1, 1, 2) is not. loc1 references a vec2, not an ivec2.
    Uniform1fARB(loc1, 1.0f) is not. loc1 references a vec2, not a float.
    Uniform1fvARB(loc3, 10, floatPtr) is a valid command.
    Uniform1fvARB(loc4, 10, floatPtr) is not. It runs off the end of the array.
    Uniform1fvARB(loc4, 8, floatPtr) is a valid command.

    RESOLUTION: Yes

    33) Should automatic conversion of input data types be done when loading
        uniforms?

    DISCUSSION: In other words, if the application passes an integer to the
    uniform loading commands, and the uniform is declared as a float, should
    automatic type conversion of that integer to a float occur? The vertex
    attribute loading commands do this, for example.

    OpenGL specifies that this kind of type conversion is dependent on the
    usage of the data. Color, normals and depth components are normalized
    and converted to floats as specified in Table 2.6. Other components are
    not normalized before conversion to float. However, generally it is not
    known what a uniform is used for.

    It is hard to imagine that it is useful for an application to pass in
    data that is declared as a different type in the shader. In that case
    the type of the uniform in the shader could be matched to the
    application's data type instead.

    RESOLUTION: NO. If the basic type of the uniform is float, then
    Uniform*f{v}ARB will have to be used. If the basic type of the uniform
    is integer, then Uniform*i{v}ARB will have to be used. If the basic type
    of the uniform is a sampler, then Uniform1i{v}ARB will have to be used.

    Since there is no Boolean type in C (and we are defining C bindings) but
    there is a Boolean type in the OpenGL Shading Language, type conversion
    needs to be done. It is allowed to either pass in floats or integers if
    the uniform is declared as a boolean. If the basic type of the uniform
    is a Boolean, then either Uniform*f{v}ARB or Uniform*i{v}ARB can be
    used.

    Note that the uniform loading API can later be extended to allow for
    automatic type conversion, with and without normalization, if it turns
    out that is desired.

    34) Why introduce the new terms "Use" and "Create"?

    DISCUSSION: This question refers to glUseProgramObjectARB,
    glCreateShaderObjectARB and glCreateProgramOBjectARB. We could have
    defined glNewShaderObjectARB, glNewProgramObjectARB and left off the
    "Use" in glUseProgramOBjectARB, resulting in glProgramObjectARB.

    RESOLUTION: "New" is used for an existing function name (glNewList) that
    takes a name as input, instead of returning a handle. We deliberately
    chose "Create" for functions that return handles. Similarly "Use" is
    used in a function name that takes a handle as input. Different names
    make it clear to the developer that there are different semantics.

    35) How is a uniform array treated when only some of the array elements
        are actually used?

    DISCUSSION: We have two goals in mind:

      1) To be able to always load a uniform array starting from offset 0
         into the array.
      2) To keep the list of active uniforms as small as possible.

    RESOLUTION: For a uniform array declared in a shader,
    GetActiveUniformARB() will return the name of the array, its basic type
    and a count. This count is determined by the highest element used in the
    shader (as determined by the linker / compiler). If the shader doesn't
    use the array at all, then the GL should obviously not report it as an
    active uniform. Loading more data for the array, using Uniform*ARB, than
    the count returned by GetActiveUniformARB is allowed. The extra data is
    silently ignored (sent to the bit-bucket).

    For example, consider the array:

        uniform vec3 a[10];

    Which is used in a shader that uses elements 3 and 7 in this array.
    GetActiveUniformARB will return:

        "a" - the name of the array
        8 - The size of the array (based on the highest element used, 7)
        FLOAT_VEC3_ARB - The type

    Since array elements 0 through 7 are active, the application can query
    the locations for elements 0, 1, 2, 3, 4, 5, 6, 7 using
    GetUniformLocationARB().

    Loading data for this array using a count of 10 (not 8) is allowed. Thus
    it is legal to issue:

        location = GetUniformLocation(progObj, "a");
        LoadUniform3fv(location, 10, dataPtr);

    This will load data into array elements 0 through 7, since only array
    elements 0 through 7 are active, and will ignore the rest of the data.

    Array data is queried one element at a time. In order to query any
    uniform, a location needs to be provided by the application. Therefore,
    in this example, the application can query data for array elements 0
    through 7, but not for elements 8 and 9.

    This makes array loading portable, independent of the smartness of the
    compiler / linker. It also encourages shader writers to start using
    array elements starting at zero, and work their way upwards, to get
    maximum resource efficiency from the OpenGL implementation. It also
    works nicely with auto-sized uniform arrays (an array declared with
    empty brackets "[]" and indexed only with compile time constants).

    36) Should a location of -1 passed in to Uniform*ARB generate a GL error?

    DISCUSSION: The Uniform*API commands will set an INVALID_OPERATION error
    when passing in a location that does not exist. GetUniformLocationARB
    will return -1 if the string passed in is not an active uniform, or if
    it starts with the prefix "gl_". (This means you cannot get a location
    for active built-in uniforms, for example gl_ModelviewMatrix).

    If you're looping over GetUniformLocationARB and passing the result to
    one of the Uniform*ARB commands, and if any -1 location passed to
    Uniform*ARB will generate a GL error, then this means that you should
    really bracket your Uniform*ARB command with a 'if (location != -1)
    statement. It seems desireable to not generate a GL error when -1 is
    passed in as a location to Uniform*ARB. The data passed in should then
    be silently ignored.

    RESOLUTION. NO. Note that this has changed since the version 0.87 (which
    was published in the extension registry). That version did set an error
    when passing in a location of -1.

    37) What should the behavior of glDeleteObject(0) be?

    DISCUSSION: It would be desirable to allow 0 as a valid input value, and
    not raise an error.

    RESOLUTION: glDeleteObject() will silently ignore deleting the value 0.
    This is consistent with glDeleteTextures() that also silently ignores
    deleting the value 0.

    38) It is unclear how GetUniform*ARB works for matrices. Is the data
        returned in column or row major order?

    DISCUSSION: glGet(MODEL_VIEW_MATRIX) returns data in column major order.
    It was discussed, but rejected, to add two new commands to return
    matrices in column or row major order:

    void GetUniformMatrixfvARB(handleARB programObj, int location,
                               boolean transpose, float *params)
    void GetUniformMatrixivARB(handleARB programObj, int location,
                               boolean transpose, float *params)

    RESOLUTION: GetUniformARB will return data in column major order,
    regardles of the transpose flag used to set the matrix in the
    LoadUniform*ARB commands.

    39) Do "const" qualified variables consume uniform word storage, or not?

    RESOLUTION: They do not.

    40) What happens when a program object currently in use is re-linked,
        and this re-link fails?

    DISCUSSION: This should not affect the executable(s), part of the
    current rendering state. As opposed to revert to fix pipeline for
    example.

    RESOLUTION: The currently active executable code will be kept until
    changed or the program has been linked successfully.

    41) What happens when an empty program object (one with no shader
        objects attached) is linked?

    DISCUSSION: Linking a program object with just a vertex shader will get
    you fixed- function fragment processing. Vice versa, linking a program
    object with just a fragment shader gets you fixed-function vertex
    processing.

    RESOLUTION: This will succeed and in this case you get the fixed
    pipeline for both vertex and fragment processing if UseProgramObject()
    is issued for this program object.

    42) How to indicate the first element of an array when requesting a
        uniform location?

    DISCUSSION: There is a desire to have the location of the first element
    of an array be indicated either using the name of the uniform array, or
    by using the name appended with "[0]".

    That would mean the following:

        uniform s a[1]; // Where 's' is some struct with a field 'f' that is a float.

    The following string combinations could be formed to pass into
    GetUniformLocation:

        a[0].f
        a.f

    If 'f' is an array float f[1] then the following string combinations
    could be formed to pass into GetUniformLocation:

        a[0].f[0]
        a[0].f
        a.f[0]
        a.f

    RESOLUTION: The spec is changed so that in the middle of a string it is
    mandatory to use [0]. Thus that means that only the following two
    strings are valid to pass to GetUniformLocation:

        a[0].f
        a[0].f[0]

    43) What does GetActiveUniformARB() report for the following two
        uniforms?

    DISCUSSION: Consider shader code with:

        uniform float a[1];
        uniform float a;

    The size reported by GetActiveUniformARB() will be '1', and the type
    reported will be float. The string reported can be 'a' in both cases, or
    can be 'a[0]' in the array case. In other words, from this data it is
    not clear to the application if 'a' is an array of size one or a scalar.
    Reporting 'a[0]' is the recommended way for the array case. Technically
    it doesn't really matter, since it is legal to address the first element
    of an array with 'a' or 'a[0]' and pass either string into
    GetUniformLocation.

    RESOLUTION: The GL implementation can report either string. However, it
    is recommended to return 'a[0]'.

    44) Do GL enables affect the built-in state available to a shader?

    DISCUSSION: The lighting state, for example, is still tracked and kept
    current even when lighting, or a specific light, is disabled. This goes
    for all built-in state listed in Chapter 7.5 of the OpenGL Shading
    Language Specification. Do realize that the enables
    VERTEX_PROGRAM_POINT_SIZE and VERTEX_PROGRAM_TWO_SIDE do need to be
    enabled by the application, to get their desired effect.

    RESOLUTION: Enable state is a piece of orthogonal state that is not
    available to a shader. The enable state does not affect the built-in
    state that is available to a shader, which is listed in Chapter 7.5 of
    the OpenGL Shading Language specification.

    45) Please give an example of using the uniform API.

    DISCUSSION: Below are two examples. The first one queries each active
    uniform, then loads a value for it. The second example works of a list
    of uniforms, and queries their locations. Some of the uniforms in that
    list might not be active.

    //
    // Example code that queries active uniforms, then loads their values
    //
    void
    example1(GLhandleARB programObject)
    {
        int    i, count, size, type, linked, location;
        char   uniformName[1000];

        // Link the program object and make sure it succeeded.
        glLinkProgramARB(programObject);
        glGetObjectParameterivARB(programObject, GL_OBJECT_LINK_STATUS_ARB, &linked);

        if (!linked) {
            return;
        }

        // Install the executables in the program object as part of current state.
        glUseProgramObjectARB(programObject);

        // Check for GL Errors

        // Setup uniform values in the array 'colorInterior'.

        // Query the number of active uniforms
        glGetObjectParameterivARB(programObject, GL_OBJECT_ACTIVE_UNIFORMS_ARB,
                                  &count);

        // Loop over each of the active uniforms, and set their value
        for (i = 0; i < count; i++)
        {
            glGetActiveUniformARB(programObject, i, 1000, NULL, &size, &type,
                                  uniformName);
            printf("active uniform: %s\n",uniformName);

            location = glGetUniformLocationARB(programObject, uniformName);

            if (type == GL_FLOAT_VEC3_ARB) {
                float  *data;

                // Allocate data based on 'size'
                // do some kind of hash lookup on the uniform name to get the
                // data to load for the uniform.
                lookupUniformData(uniformName, data);

                // This a vec3, therefore need to use the '3f' or '3fv' version
                // of the uniform loading commands.
                glUniform3fvARB(location, size, data);
            } // else : Setup more types here
        }
    }


    //
    // Example code that has a list of uniforms, and loads values for each uniform
    // in the list. Not all uniforms have to be active ones.
    //
    void
    example2(GLhandleARB programObject)
    {
        int     i, count, linked, location;
        char  **uniformName;
        float  *data;

        // Link the program object and make sure it succeeded.
        glLinkProgramARB(programObject);
        glGetObjectParameterivARB(programObject, GL_OBJECT_LINK_STATUS_ARB, &linked);

        if (!linked) {
            return;
        }

        // Install the executables in the program object as part of current state.
        glUseProgramObjectARB(programObject);

        // Check for GL Errors

        // Setup uniform values in the array 'data'.
        // Setup 'count' and the array 'uniformName'

        // Loop over the list of uniforms in uniformName, and set their value
        for (i = 0; i < count; i++)
        {
            // Location will be -1 if the uniform is not active, but that is OK
            // the uniform loading commands will silently ignore a location of -1.
            location = glGetUniformLocationARB(programObject, uniformName[i]);

            // This a a vec3, therefore need to use the '3f' or '3fv' version of
            // the uniform loading command.
            glUniform3fvARB(location, 1, &data[i * 3]);
        }
    }

    46) Should we add capability to query if an object is dirty?

    DISCUSSION: Specifically, do we add a way to query if a program object
    needs relinking? Do we add a way to query if a shader object needs
    re-compilation?

    RESOLUTION: No, the application can keep track of this information as
    well. Mipmap state consistency is not queriable either, for example.

New Procedures and Functions

    void DeleteObjectARB(handleARB obj)

    handleARB GetHandleARB(enum pname)

    void DetachObjectARB(handleARB containerObj, handleARB attachedObj)

    handleARB CreateShaderObjectARB(enum shaderType)

    void ShaderSourceARB(handleARB shaderObj, sizei count, const charARB **string,
                         const int *length)

    void CompileShaderARB(handleARB shaderObj)

    handleARB CreateProgramObjectARB(void)

    void AttachObjectARB(handleARB containerObj, handleARB obj)

    void LinkProgramARB(handleARB programObj)

    void UseProgramObjectARB(handleARB programObj)

    void ValidateProgramARB(handleARB programObj)

    void Uniform1fARB(int location, float v0)
    void Uniform2fARB(int location, float v0, float v1)
    void Uniform3fARB(int location, float v0, float v1, float v2)
    void Uniform4fARB(int location, float v0, float v1, float v2, float v3)

    void Uniform1iARB(int location, int v0)
    void Uniform2iARB(int location, int v0, int v1)
    void Uniform3iARB(int location, int v0, int v1, int v2)
    void Uniform4iARB(int location, int v0, int v1, int v2, int v3)

    void Uniform1fvARB(int location, sizei count, const float *value)
    void Uniform2fvARB(int location, sizei count, const float *value)
    void Uniform3fvARB(int location, sizei count, const float *value)
    void Uniform4fvARB(int location, sizei count, const float *value)

    void Uniform1ivARB(int location, sizei count, const int *value)
    void Uniform2ivARB(int location, sizei count, const int *value)
    void Uniform3ivARB(int location, sizei count, const int *value)
    void Uniform4ivARB(int location, sizei count, const int *value)

    void UniformMatrix2fvARB(int location, sizei count, boolean transpose, const float *value)
    void UniformMatrix3fvARB(int location, sizei count, boolean transpose, const float *value)
    void UniformMatrix4fvARB(int location, sizei count, boolean transpose, const float *value)

    void GetObjectParameterfvARB(handleARB obj, enum pname, float *params)
    void GetObjectParameterivARB(handleARB obj, enum pname, int *params)

    void GetInfoLogARB(handleARB obj, sizei maxLength, sizei *length, charARB *infoLog)

    void GetAttachedObjectsARB(handleARB containerObj, sizei maxCount, sizei *count,
                              handleARB *obj)

    int GetUniformLocationARB(handleARB programObj, const charARB *name)

    void GetActiveUniformARB(handleARB programObj, uint index, sizei maxLength,
                             sizei *length, int *size, enum *type, charARB *name)

    void GetUniformfvARB(handleARB programObj, int location, float *params)
    void GetUniformivARB(handleARB programObj, int location, int *params)

    void GetShaderSourceARB(handleARB obj, sizei maxLength, sizei *length,
                            charARB *source)

New Tokens


        PROGRAM_OBJECT_ARB                              0x8B40


        OBJECT_TYPE_ARB                                 0x8B4E
        OBJECT_SUBTYPE_ARB                              0x8B4F
        OBJECT_DELETE_STATUS_ARB                        0x8B80
        OBJECT_COMPILE_STATUS_ARB                       0x8B81
        OBJECT_LINK_STATUS_ARB                          0x8B82
        OBJECT_VALIDATE_STATUS_ARB                      0x8B83
        OBJECT_INFO_LOG_LENGTH_ARB                      0x8B84
        OBJECT_ATTACHED_OBJECTS_ARB                     0x8B85
        OBJECT_ACTIVE_UNIFORMS_ARB                      0x8B86
        OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB            0x8B87
        OBJECT_SHADER_SOURCE_LENGTH_ARB                 0x8B88


        SHADER_OBJECT_ARB                               0x8B48


        FLOAT                                           0x1406
        FLOAT_VEC2_ARB                                  0x8B50
        FLOAT_VEC3_ARB                                  0x8B51
        FLOAT_VEC4_ARB                                  0x8B52
        INT                                             0x1404
        INT_VEC2_ARB                                    0x8B53
        INT_VEC3_ARB                                    0x8B54
        INT_VEC4_ARB                                    0x8B55
        BOOL_ARB                                        0x8B56
        BOOL_VEC2_ARB                                   0x8B57
        BOOL_VEC3_ARB                                   0x8B58
        BOOL_VEC4_ARB                                   0x8B59
        FLOAT_MAT2_ARB                                  0x8B5A
        FLOAT_MAT3_ARB                                  0x8B5B
        FLOAT_MAT4_ARB                                  0x8B5C
        SAMPLER_1D_ARB                                  0x8B5D
        SAMPLER_2D_ARB                                  0x8B5E
        SAMPLER_3D_ARB                                  0x8B5F
        SAMPLER_CUBE_ARB                                0x8B60
        SAMPLER_1D_SHADOW_ARB                           0x8B61
        SAMPLER_2D_SHADOW_ARB                           0x8B62
        SAMPLER_2D_RECT_ARB                             0x8B63
        SAMPLER_2D_RECT_SHADOW_ARB                      0x8B64

