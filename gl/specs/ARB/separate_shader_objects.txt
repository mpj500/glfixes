Name

    ARB_separate_shader_objects

Name Strings

    GL_ARB_separate_shader_objects

Contact

    Mark Kilgard, NVIDIA (mjk 'at' nvidia.com)
    Greg Roth, NVIDIA (groth 'at' nvidia.com)
    Pat Brown, NVIDIA (pbrown 'at' nvidia.com)

Contributors

    Bruce Merry, ARM
    Daniel Koch, TransGaming
    Eric Werness, NVIDIA
    Graham Sellers, AMD
    Greg Roth, NVIDIA
    Jason Green, TransGaming
    John Kessenich, Intel
    Jon Leech
    Kevin Rogovin 
    Nick Haemel, AMD
    Robert Ohannessian

Notice

    Copyright (c) 2010-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete. Approved by the ARB on June 9, 2010.
    Approved by the Khronos Board of Promoters on July 23, 2010.

Version

    Last Modified Date:  1 August 2011
    Version:             25

Number

    ARB Extension #97

Dependencies

    Written based on the wording of the OpenGL 4.0 Compatibility
    Profile (March 11, 2010) specification.

    Written based on the wording of The OpenGL Shading Language 4.00.8
    (March 10, 2010) specification.

    This extension requires OpenGL 2.0 or ARB_shader_objects.

    This extension interacts with OpenGL 4.0 (Core Profile).

    This extension interacts with GLSL 1.40 (and earlier).

    This extension interacts with ARB_geometry_shader4,
    EXT_geometry_shader4, and/or NV_geometry_shader4.

    This extension depends on ARB_explicit_attrib_location.

    This extension interacts with ARB_tessellation_shader or OpenGL 4.0.

    This extension interacts with GL_ARB_gpu_shader_fp64 or OpenGL 4.0.

    This extension interacts with ARB_explicit_attrib_location,
    ARB_vertex_attrib_64bit, OpenGL 3.3, and OpenGL 4.1.

    This extension interacts with the EXT_separate_shader_objects extension.

    This extension interacts with ARB_vertex_program, ARB_fragment_program,
    NV_gpu_program4 and related assembly extensions.

Overview

    Conventional GLSL requires multiple shader stages (vertex,
    fragment, geometry, tessellation control, and tessellation
    evaluation) to be linked into a single monolithic program object to
    specify a GLSL shader for each stage.

    While GLSL's monolithic approach has some advantages for
    optimizing shaders as a unit that span multiple stages, all
    existing GPU hardware supports the more flexible mix-and-match
    approach.

    Shaders written for HLSL9, Cg, the prior OpenGL assembly program
    extensions, and game console favor a more flexible "mix-and-match"
    approach to specifying shaders independently for these different
    shader stages.  Many developers build their shader content around
    the mix-and-match approach where they can use a single vertex shader
    with multiple fragment shaders (or vice versa).

    This extension adopts a "mix-and-match" shader stage model for GLSL
    allowing multiple different GLSL program objects to be bound at once
    each to an individual rendering pipeline stage independently of
    other stage bindings. This allows program objects to contain only
    the shader stages that best suit the applications needs.

    This extension introduces the program pipeline object that serves as
    a container for the program bound to any particular rendering stage.
    It can be bound, unbound, and rebound to simply save and restore the
    complete shader stage to program object bindings.  Like framebuffer
    and vertex array objects, program pipeline objects are "container"
    objects that are not shared between contexts.

    To bind a program object to a specific shader stage or set of
    stages, UseProgramStages is used.  The VERTEX_SHADER_BIT,
    GEOMETRY_SHADER_BIT, FRAGMENT_SHADER_BIT, TESS_CONTROL_SHADER_BIT,
    and TESS_EVALUATION_SHADER_BIT tokens refer to the conventional
    vertex, geometry, fragment, tessellation control and tessellation
    evaluation stages respectively. ActiveShaderProgram specifies the
    program that Uniform* commands will update.

    While ActiveShaderProgram allows the use of conventional Uniform*
    commands to update uniform variable values for separable program
    objects, this extension provides a preferrable interface in a set
    of ProgramUniform* commands that update the same uniform variables
    but take a parameter indicating the program object to be updated,
    rather than updating the currently active program object. These
    commands mirror those introduced in EXT_direct_state_access.

    While glActiveShaderProgram provides a selector for setting and
    querying uniform values of a program object, the glProgramUniform*
    commands provide a selector-free way to modify uniforms of a GLSL
    program object without an explicit bind. This selector-free model
    reduces API overhead and provides a cleaner interface for
    applications.

    Separate linking creates the possibility that certain output varyings
    of a shader may go unread by the subsequent shader inputting varyings.
    In this case, the output varyings are simply ignored.  It is also
    possible input varyings from a shader may not be written as output
    varyings of a preceding shader.  In this case, the unwritten input
    varying values are undefined.

    This extension builds on the proof-of-concept provided by
    EXT_separate_shader_objects which demonstrated that separate
    shader objects can work for GLSL.  EXT_separate_shader_objects
    was a response to repeated requests for this functionality from
    3D developers.

    This ARB version addresses several "loose ends" in the prior
    EXT extension.  In particular, it allows user-defined varyings
    with explicitly defined locations or implicitly assigned locations.

    This ARB extension extends the GLSL language's use of layout
    qualifiers to provide cross-stage interfacing.
    
IP Status

    No known IP claims.

New Procedures and Functions

    void UseProgramStages(uint pipeline, bitfield stages,
                          uint program);

    void ActiveShaderProgram(uint pipeline, uint program);

    uint CreateShaderProgramv(enum type, sizei count,
                              const char **strings);

    void BindProgramPipeline(uint pipeline);

    void DeleteProgramPipelines(sizei n, const uint *pipelines);

    void GenProgramPipelines(sizei n, uint *pipelines);

    boolean IsProgramPipeline(uint pipeline);

    void ProgramParameteri(uint program, enum pname, int value);

    void GetProgramPipelineiv(uint pipeline, enum pname, int *params);

    void ProgramUniform1i(uint program, int location,
                          int x);
    void ProgramUniform2i(uint program, int location,
                          int x, int y);
    void ProgramUniform3i(uint program, int location,
                          int x, int y, int z);
    void ProgramUniform4i(uint program, int location,
                          int x, int y, int z, int w);

    void ProgramUniform1ui(uint program, int location,
                           uint x);
    void ProgramUniform2ui(uint program, int location,
                           uint x, uint y);
    void ProgramUniform3ui(uint program, int location,
                           uint x, uint y, uint z);
    void ProgramUniform4ui(uint program, int location,
                           uint x, uint y, uint z, uint w);

    void ProgramUniform1f(uint program, int location,
                          float x);
    void ProgramUniform2f(uint program, int location,
                          float x, float y);
    void ProgramUniform3f(uint program, int location,
                          float x, float y, float z);
    void ProgramUniform4f(uint program, int location,
                          float x, float y, float z, float w);

    void ProgramUniform1d(uint program, int location,
                          double x);
    void ProgramUniform2d(uint program, int location,
                          double x, double y);
    void ProgramUniform3d(uint program, int location,
                          double x, double y, double z);
    void ProgramUniform4d(uint program, int location,
                          double x, double y, double z, double w);

    void ProgramUniform1iv(uint program, int location,
                           sizei count, const int *value);
    void ProgramUniform2iv(uint program, int location,
                           sizei count, const int *value);
    void ProgramUniform3iv(uint program, int location,
                           sizei count, const int *value);
    void ProgramUniform4iv(uint program, int location,
                           sizei count, const int *value);

    void ProgramUniform1uiv(uint program, int location,
                            sizei count, const uint *value);
    void ProgramUniform2uiv(uint program, int location,
                            sizei count, const uint *value);
    void ProgramUniform3uiv(uint program, int location,
                            sizei count, const uint *value);
    void ProgramUniform4uiv(uint program, int location,
                            sizei count, const uint *value);

    void ProgramUniform1fv(uint program, int location,
                           sizei count, const float *value);
    void ProgramUniform2fv(uint program, int location,
                           sizei count, const float *value);
    void ProgramUniform3fv(uint program, int location,
                           sizei count, const float *value);
    void ProgramUniform4fv(uint program, int location,
                           sizei count, const float *value);

    void ProgramUniform1dv(uint program, int location,
                           sizei count, const double *value);
    void ProgramUniform2dv(uint program, int location,
                           sizei count, const double *value);
    void ProgramUniform3dv(uint program, int location,
                           sizei count, const double *value);
    void ProgramUniform4dv(uint program, int location,
                           sizei count, const double *value);

    void ProgramUniformMatrix2fv(uint program, int location,
                                 sizei count, boolean transpose,
                                 const float *value);
    void ProgramUniformMatrix3fv(uint program, int location,
                                 sizei count, boolean transpose,
                                 const float *value);
    void ProgramUniformMatrix4fv(uint program, int location,
                                 sizei count, boolean transpose,
                                 const float *value);

    void ProgramUniformMatrix2dv(uint program, int location,
                                 sizei count, boolean transpose,
                                 const double *value);
    void ProgramUniformMatrix3dv(uint program, int location,
                                 sizei count, boolean transpose,
                                 const double *value);
    void ProgramUniformMatrix4dv(uint program, int location,
                                 sizei count, boolean transpose,
                                 const double *value);

    void ProgramUniformMatrix2x3fv(uint program, int location,
                                   sizei count, boolean transpose,
                                   const float *value);
    void ProgramUniformMatrix3x2fv(uint program, int location,
                                   sizei count, boolean transpose,
                                   const float *value);
    void ProgramUniformMatrix2x4fv(uint program, int location,
                                   sizei count, boolean transpose,
                                   const float *value);
    void ProgramUniformMatrix4x2fv(uint program, int location,
                                   sizei count, boolean transpose,
                                   const float *value);
    void ProgramUniformMatrix3x4fv(uint program, int location,
                                   sizei count, boolean transpose,
                                   const float *value);
    void ProgramUniformMatrix4x3fv(uint program, int location,
                                   sizei count, boolean transpose,
                                   const float *value);

    void ProgramUniformMatrix2x3dv(uint program, int location,
                                   sizei count, boolean transpose,
                                   const double *value);
    void ProgramUniformMatrix3x2dv(uint program, int location,
                                   sizei count, boolean transpose,
                                   const double *value);
    void ProgramUniformMatrix2x4dv(uint program, int location,
                                   sizei count, boolean transpose,
                                   const double *value);
    void ProgramUniformMatrix4x2dv(uint program, int location,
                                   sizei count, boolean transpose,
                                   const double *value);
    void ProgramUniformMatrix3x4dv(uint program, int location,
                                   sizei count, boolean transpose,
                                   const double *value);
    void ProgramUniformMatrix4x3dv(uint program, int location,
                                   sizei count, boolean transpose,
                                   const double *value);

   void ValidateProgramPipeline(uint pipeline );

   void GetProgramPipelineInfoLog(uint pipeline, sizei bufSize,
                                  sizei *length, char *infoLog);

New Tokens


        VERTEX_SHADER_BIT                      0x00000001
        FRAGMENT_SHADER_BIT                    0x00000002
        GEOMETRY_SHADER_BIT                    0x00000004
        TESS_CONTROL_SHADER_BIT                0x00000008
        TESS_EVALUATION_SHADER_BIT             0x00000010
        ALL_SHADER_BITS                        0xFFFFFFFF


        PROGRAM_SEPARABLE                      0x8258


        ACTIVE_PROGRAM                         0x8259


        PROGRAM_PIPELINE_BINDING               0x825A

