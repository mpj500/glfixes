Name

    ARB_color_buffer_float

Name Strings

    GL_ARB_color_buffer_float
    WGL_ARB_pixel_format_float
    GLX_ARB_fbconfig_float

Contributors

    Pat Brown, NVIDIA
    James Jones, NVIDIA
    Jon Leech
    Rob Mace, ATI
    V Moya
    Brian Paul, Tungsten Graphics

Contact

    Dale Kirkland, NVIDIA (dkirkland 'at' nvidia.com)

Notice

    Copyright (c) 2004-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete. Approved by the ARB on October 22, 2004.

Version

    Based on the ATI_pixel_format_float extension, version 5
    Enables based on work by Pat Brown from the color_clamp_control proposal

    Last Modified Date:  April 1, 2015
    Version:             9

Number

    ARB Extension #39

Dependencies

    This extension is written against the OpenGL 2.0 Specification
    but will work with the OpenGL 1.5 Specification.

    WGL_ARB_pixel_format is required.

    This extension interacts with ARB_fragment_program.

    This extension interacts with ARB_fragment_shader.

    This extension interacts with NV_float_buffer.

    This extension interacts with ATI_pixel_format_float.

Overview

    The standard OpenGL pipeline is based on a fixed-point pipeline.
    While color components are nominally floating-point values in the
    pipeline, components are frequently clamped to the range [0,1] to
    accomodate the fixed-point color buffer representation and allow
    for fixed-point computational hardware.

    This extension adds pixel formats or visuals with floating-point
    RGBA color components and controls for clamping of color
    components within the pipeline.

    For a floating-point RGBA pixel format, the size of each float
    components is specified using the same attributes that are used
    for defining the size of fixed-point components.  32-bit
    floating-point components are in the standard IEEE float format.
    16-bit floating-point components have 1 sign bit, 5 exponent bits,
    and 10 mantissa bits.

    Clamping control provides a way to disable certain color clamps
    and allow programs, and the fixed-function pipeline, to deal in
    unclamped colors.  There are controls to modify clamping of vertex
    colors, clamping of fragment colors throughout the pipeline, and
    for pixel return data.

    The default state for fragment clamping is "FIXED_ONLY", which
    has the behavior of clamping colors for fixed-point color buffers
    and not clamping colors for floating-pont color buffers.

    Vertex colors are clamped by default.


IP Status

    SGI owns US Patent #6,650,327, issued November 18, 2003. SGI
    believes this patent contains necessary IP for graphics systems
    implementing floating point (FP) rasterization and FP framebuffer
    capabilities.

    SGI will not grant the ARB royalty-free use of this IP for use in
    OpenGL, but will discuss licensing on RAND terms, on an individual
    basis with companies wishing to use this IP in the context of
    conformant OpenGL implementations. SGI does not plan to make any
    special exemption for open source implementations.

    Contact Doug Crisman at SGI Legal for the complete IP disclosure.

Issues

    1. How is this extension different from the ATI_pixel_format_float
       extension?

       RESOLVED:  By default, this extension behaves like the
       ATI_pixel_format_float, but also adds additional controls for
       color clamping.

    2. Should the clamp controls be automatically inferred based on
       the format of the color buffer or textures used?

       RESOLVED:  Explicit controls should be supported -- this allows
       the use of floating-point buffers to emulate fixed-point
       operation, and allows for operating on unclamped values even
       when rendering to a fixed-point framebuffer.

       However, a default clamping mode called "FIXED_ONLY" is defined
       that enables clamping only when rendering to a fixed-point color
       buffer, which is the default for fragment processing.  This is
       done to maintain compatibility with previous extensions
       (ATI_pixel_format_float), and to allow applications to switch
       between fixed- and floating-point color buffers without having
       to change the clamping mode on each switch.

    3. How does the clamping control affect the blending equation?

       RESOLVED:  For fixed-point color buffers, the inputs and the
       result of the blending equation are clamped.  For floating-point
       color buffers, no clamping occurs.

    4. Should the requirements for the representable range of color
       components be increased?

       RESOLVED:  No.  Such a spec change would be complicated, since
       the required precision may vary based on color buffer precision.
       Despite the fact that there is no spec requirement, GL
       implementations should have at least as much precision/range in
       their colors as can be found in the framebuffer.

    5. Should the vertex color clamping control apply to RasterPos?
       WindowPos?

       RESOLVED:  Yes to both.  RasterPos is processed just like a
       vertex, so the vertex color clamping control applies
       automatically.  The WindowPos language in the OpenGL 2.0
       specification explicitly refers to color clamping.  Instead,
       we modify the language to perform normal processing, but with
       lighting forced off.  This will result in the color clamping
       logic applying.

    6. What control should apply to DrawPixels RGBA components?

       RESOLVED:  The fragment color clamp control.

    7. Should this extension modify the clamping of the texture
       environment color components?  TEXTURE_ENV_COLOR components
       are currently specified to be clamped to [0,1] when TexEnv is
       called.

       RESOLVED:  Yes.  The texture environment color is no longer
       clamped when specified.  If fragment color clamping is enabled,
       it will be clamped to [0,1] on use.

    8. In texture environment application, should color components used
       as an interpolation factor (e.g., alpha) be clamped to [0,1]?

       RESOLVED:  No.  For interpolation-type blends, the weighting
       factor is normally in the range [0,1].  But the math is well-
       defined in the cases where it falls outside this range.  When
       fragment color clamping is enabled, all sources are clamped to
       [0,1], so this is not an issue.

   9. In the COMBINE texture environment mode, should any of the
       source argument operands be clamped to [0,1] even when fragment
       clamping is disabled?  For example, ONE_MINUS_* mappings are
       simple in a fixed-point pipeline are simple, but more
       complicated in a floating-point one.

       RESOLVED:  No.  The math behind ONE_MINUS_* is well-defined for
       all inputs.

   10. Should the clamping controls affect the texture comparison mode
       for shadow mapping?

       RESOLVED:  No.  The r coordinate should still be clamped to
       [0,1] to match the depth texture.  The result of the
       comparison will naturally lie in the range [0,1].

   11. Should the clamping controls affect the result of color sum?

       RESOLVED:  Yes.

   12. Should the clamping controls affect the computed fog factor?

       RESOLVED:  No.  The fog factor is not a color -- it is used to
       blend between the fragment color and the fog color.  The factor
       should always be clamped to [0,1].

   13. Should this extension modify the clamping of the fog color
       components?  FOG_COLOR components are specified to be clamped
       to [0,1] when Fogfv is called.

       RESOLVED:  Yes.  Fog color components are no longer clamped
       when specified, but will be clamped when fog is applied if
       fragment color clamping is enabled.

   14. How does this extension interact with antialiasing application
       (Section 3.12 of the OpenGL 2.0 spec)?

       RESOLVED:  Multiply floating-point alpha by coverage, even if
       the alpha value is not being used as opacity.  If applications
       don't want this multiplication, they should not render
       antialiased primitives. No spec language changes are needed
       here.

   15. How does this extension interact with multisample point fade
       (Section 3.13 of the OpenGL 2.0 spec)?

       RESOLVED:  Multiply floating-point alpha by the fade factor,
       even if the alpha value is not being used as opacity.  If
       applications don't want this multiplication, they should not
       use multisample point fade.  No spec language changes are
       needed here.

   16. Should this extension modify the clamping of the alpha test
       reference value?

       RESOLVED:  Yes.  The reference value is not clamped when
       specified, by may be clamped when it is used.

   17. Should this extension modify the clamping of the constant blend
       color components?

       RESOLVED:  Yes.  The blend color is not clamped when specified.
       When rendering to a fixed-point framebuffer, the blend color
       will be clamped as part of the blending operation.

   18. Should this extension modify the clamping of clear colors?

       RESOLVED:  Yes.  The clear color is not clamped when specified.
       When clearing color buffers, the clear color is converted to
       the format of the color buffer.

   19. Should we provide a control to disable implicit clamping of
       ReadPixels data?  If so, how should it be specified?

       RESOLVED:  Yes.  It is explicitely controlled by the target
       CLAMP_READ_COLOR_ARB of the ClampColorARB function and clamps
       the color during the final conversion.

   20. How does this extension interact with CopyPixels?

       RESOLVED: It has no special interaction.  CopyPixels is specified
       as roughly a ReadPixels/DrawPixels sequence, but the read color
       clamp modified by this specification occur during final
       conversion and therefore would not apply. The fragment color
       clamp does affect the DrawPixels portion of the operation,
       however.  The net result is that calling CopyPixels with a
       floating-point framebuffer will clamp color components if
       fragment color clamping is enabled.

   21. Should these clamping controls interact with PushAttrib and
       PopAttrib? If so, what group should they belong to?

       RESOLVED:  For consistency, yes.  Historically, all enables are
       pushed and popped with both the enable bit and a second bit
       corresponding to the function performed by the enable.  The
       present spec calls for pushing the vertex color clamp with the
       lighting group and the fragment and read color clamp with the
       color-buffer group (for lack of a better choice).

   22. Should this extension require a floating-point color buffer
       or texture?

       RESOLVED:  No.  This extension provides the ability to pass an
       unclamped color between vertex and fragment programs/shaders,
       which may be useful. This was possible prior to this extension,
       by passing the color data as texture coordinates or named
       varying variables (for vertex/fragment shaders).

   23. Does this extension interact with the ARB_vertex_program or
       ARB_vertex_shader extensions?

       RESOLVED:  Only in the most trivial way.  Both of these
       extensions refer to the color clamping logic (Section 2.14.6
       in the OpenGL 2.0 specification).  This extension modifies that
       logic to be under control of the CLAMP_VERTEX_COLOR_ARB enable.
       It follows that this enable also controls the clamping of vertex
       program or vertex shader results.

   24. Does this extension interact with the ARB_fragment_program or
       ARB_fragment_shader extensions?

       RESOLVED:  Yes.  The only interaction is that the fragment color
       clamp enable determines if the final color(s) produced by the
       fragment program/shader has its components clamped to [0,1].

       However, the fragment color clamp enable affects only the final
       result; it does NOT affect any computations performed during
       program execution. Note that the same clamping can be done
       explicitly in a fragment program or shader.
       ARB_fragment_program provides the "_SAT" opcode suffix to clamp
       instruction results to [0,1].

   25. Should this extension modify the clamping of the texture border
       color components?

       RESOLVED:  Not by this extension.  See the ARB_texture_float
       extension.

   26. When using vertex and fragment programs/shaders, should color
       clamping be specified in the shader instead?

       RESOLVED:  No.  All the existing program/shader extensions call
       for the color outputs to be clamped to [0,1], except that
       previous floating-point color buffer extensions disabled the
       clamp of fragment program/shader outputs.

       While it would be straightforward to have required that vertex
       or fragment programs manually clamp their outputs if desired,
       adding such a requirement at this point would pose compatibility
       issues.  It would probably require introduction of a special
       directive to indicate that colors are unclamped.

       If a GL implementation internally performs color clamping in a
       vertex or fragment program, it may be necessary to recompile the
       program if the corresponding clamp enable changes.

   27. If certain colors in the OpenGL state vector were clamped in
       previous versions of the spec, but now have the clamping
       removed, do queries need to return clamped values for
       compatibility with older GL versions? Should we add new query
       tokens to return unclamped values?

       RESOLVED: To minimize impact on this specification while allowing
       for compatibility with older GL versions, the values of the
       vertex/fragment color clamp enables should affect queries of such
       state.  If the corresponding color clamp is enabled, components
       will be clamped to [0,1] when returned.  Since color clamping is
       enabled by default for fixed-point color buffers, the removal of
       the clamps will not be observable by applications unless they
       disable one or both clamps or choose a floating-point buffer
       (which will not happen for "old" applications).

       Note that this spec relaxes the clamp on the current raster
       color, but we don't need to add a clamp on the corresponding
       query.  The current raster color is clamped when the GL computes
       it, unless vertex color clamping is disabled by the application.

   28. At what precision should alpha test be carried out?  At the
       precision of the framebuffer?  Or some other unspecified
       precision?  What happens if you have a framebuffer with no
       alpha?

       RESOLVED: No specific precision requirements are added, except
       that the reference value used in the alpha test should be
       converted to the same precision and in the same manner as the
       fragment's alpha. This requirement is intended to avoid cases
       where the act of converting the alpha value of a fragment to
       fixed-point (or lower-precision floating-point) might change the
       result of the test.

   29. How does this extension interact with accumulation buffers?

       RESOLVED: This extension does not modify the nature of
       accumulation buffers.  Adding semantics for floating-point
       accumulation buffers is left for a possible future extension.
       The clamp on the RETURN operation is controlled by the fragment
       color clamp enable.

   30. How does this extension interact with OpenGL FEEDBACK mode?

       RESOLVED: OpenGL FEEDBACK mode returns colors after clipping,
       which is done after the vertex color clamping.  Therefore, the
       colors returned will be clamped to [0,1] if and only if vertex
       color clamping is enabled.  No spec language changes are
       necessary.

   31. Should we relax the language in Section 2.14.9 (Final Color
       Processing) to not require conversion to fixed-point?

       RESOLVED: Adding floating-point vertex colors requires that
       this language be modified.  Even for the clamped case, it seems
       reasonable for implementations to simply clamp a floating-point
       value to [0,1] without converting to a fixed-point
       representation.  This specification makes converting colors to
       fixed-point optional.  Colors will obviously still be converted
       to fixed-point eventually if the framebuffer is fixed-point.

   32. What should be done about the "preserving the bits" requirement
       for Color*{ub,us,ui} commands in Section 2.14.9?

       RESOLVED: If colors are represented as floats internally and
       the frame-buffer is fixed-point, do we require that the MSBs of
       fixed-point colors that don't go through lighting, and
       non-trivial interpolation, or any non-trivial fragment operations
       show up in the MSBs of the framebuffer?

   33. How does this extension interact with multisample
       ALPHA_TO_COVERAGE, where an alpha value expected to be in the
       range [0,1] is turned into a set of coverage bits?

       UNRESOLVED: For the purposes of generating sample coverage from
       fragment alpha, the alpha values are effectively clamped to
       [0,1].  Negative alpha values correspond to no coverage; alpha
       values greater than one correspond to full coverage.

   34. What happens if there are no color buffers in the framebuffer
       and a clamp control is set to FIXED_ONLY?

       RESOLVED: The present language treats a zero-bit color buffer
       as fixed-point.

   35. Should the clamping of fragment shader output gl_FragData[n]
       be controlled by the fragment color clamp.

       RESOLVED: Since the destination of the FragData is a color
       buffer, the fragment color clamp control should apply.

   36. Should logical operations be disabled for floating-point
       color buffers.

       RESOLVED:  Yes.  This matches the behavior in the ATI
       specification.

   37. Is it expected that a floating-point color read from a
       floating-point color buffer exactly match a floating-point
       color in a fragment?  Will the alpha test of GL_EQUAL
       be expected to work?

       RESOLVED: This behavior is not required by this extension.
       Floating-point data may have different precision at different
       parts of the pipeline.

   38. How does this extension handle the case where a floating-point
       and a fixed-point buffer exists?

       RESOLVED: For vertex colors, clamping occurs if any color
       buffer are floating point.   Fragment colors are handled
       based on the format (fixed or float) of the color buffer
       that they will be drawn to.

New Procedures and Functions

    void ClampColorARB(enum target, enum clamp);

New Tokens


        RGBA_FLOAT_MODE_ARB                     0x8820


        CLAMP_VERTEX_COLOR_ARB                  0x891A
        CLAMP_FRAGMENT_COLOR_ARB                0x891B
        CLAMP_READ_COLOR_ARB                    0x891C


        FIXED_ONLY_ARB                          0x891D


        WGL_TYPE_RGBA_FLOAT_ARB                 0x21A0


        GLX_RGBA_FLOAT_TYPE_ARB                 0x20B9


        GLX_RGBA_FLOAT_BIT_ARB                  0x00000004

