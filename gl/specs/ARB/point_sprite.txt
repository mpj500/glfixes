Name

    ARB_point_sprite

Name Strings

    GL_ARB_point_sprite

Contact

    Matt Craighead, NVIDIA Corporation (mcraighead 'at' nvidia.com)
    Mark Kilgard, NVIDIA Corporation (mjk 'at' nvidia.com)
    Pat Brown, NVIDIA Corporation (pbrown 'at' nvidia.com)

Notice

    Copyright (c) 2003-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

IP Status

    No known IP issues.

Status

    Approved by the ARB on July 24, 2003.

Version

    Last Modified Date:  July 22, 2003
    Revision:            7

Number

    ARB Extension #35

Dependencies

    Written based on the wording of the OpenGL 1.4 specification.

    NV_point_sprite affects the definition of this extension.

Overview

    Applications such as particle systems have tended to use OpenGL quads
    rather than points to render their geometry, since they would like
    to use a custom-drawn texture for each particle, rather than the
    traditional OpenGL round antialiased points, and each fragment in
    a point has the same texture coordinates as every other fragment.

    Unfortunately, specifying the geometry for these quads can be
    expensive, since it quadruples the amount of geometry required, and
    may also require the application to do extra processing to compute
    the location of each vertex.

    The purpose of this extension is to allow such applications to use
    points rather than quads.  When GL_POINT_SPRITE_ARB is enabled,
    the state of point antialiasing is ignored.  For each texture unit,
    the app can then specify whether to replace the existing texture
    coordinates with point sprite texture coordinates, which are
    interpolated across the point.

Issues

    *   Should this spec say that point sprites get converted into quads?

        RESOLVED: No, this would make the spec much uglier, because then
        we'd have to say that polygon smooth and stipple get turned off,
        etc.  Better to provide a formula for computing the texture
        coordinates and leave them as points.

    *   How are point sprite texture coordinates computed?

        RESOLVED: They move smoothly as the point moves around on the
        screen, even though the pixels touched by the point do not.  The
        exact formula is given in the spec below.  

        A point sprite can be thought of as a quad whose upper-left corner has
        (s,t) texture coordinates of (0,0) and whose lower-right corner has
        texture coordinates of (1,1), as illustrated in the following figure.
        In the figure "P" is the center of the point sprite, and "O" is the
        origin (0,0) of the window coordinate system.  Note that the y window
        coordinate increases from bottom-to-top but the t texture coordinate
        of point sprites increases from top-to-bottom.

              ^
            +y| (0,0)
              |   +-----+
              |   |     |   
              |   |  P  |   
              |   |     |
              |   +-----+
              |       (1,1)
              |              +x
              O--------------->

        Applications using a single texture for both point sprites and other
        geometry need to account for the fixed coordinate mapping of point
        sprites.

    *   Is the ARB specification different from the NV version?

        RESOLVED:  Yes.  The point sprite R mode has been removed.  The
        wording has also been updated to reflect version 1.4 of the core
        OpenGL specification however.  The enumerant values are unchanged.

    *   How do point sizes for point sprites work?

        RESOLVED: This specification treats point sprite sizes like
        antialiased point sizes, but with more leniency.  Implementations
        may choose to not clamp the point size to the antialiased point
        size range.  The set of point sprite sizes available must be
        a superset of the antialiased point sizes.  However, whereas
        antialiased point sizes are all evenly spaced by the point size
        granularity, point sprites can have an arbitrary set of sizes.
        This lets implementations use, e.g., floating-point sizes.

    *   Should there be a way to query the list of supported point sprite
        sizes?

        RESOLVED: No.  If an implementation were to use, say, a single-
        precision IEEE float to represent point sizes, the list would be
        rather long.

    *   Do mipmaps apply to point sprites?

        RESOLVED: Yes.  They are similar to quads in this respect.

    *   What of this extension's state is per-texture unit and what
        of this extension's state is state is global?

        RESOLVED: The GL_POINT_SPRITE_ARB enable is global.  The
        COORD_REPLACE_ARB state is per-texture unit (state set by TexEnv is
        per-texture unit).

    *   Should there be a global on/off switch for point sprites, or
        should the per-unit enable imply that switch?

        RESOLVED: There is a global switch to turn it on and off.  This
        is probably more convenient for both driver and app, and it
        simplifies the spec.

    *   What should the TexEnv mode for point sprites be called?

        RESOLVED: COORD_REPLACE_ARB.

    *   What is the interaction with multisample points, which are round?

        RESOLVED: Point sprites are rasterized as squares, even in
        multisample mode.  Leaving them as round points would make the
        feature useless.

    *   How does the point sprite extension interact with fragment
        program extensions (ARB_fragment_program, NV_fragment_program,
        etc)?

        RESOLVED: The primary issue is how the interpolated texture
        coordinate set appears when fragment attribute variables
        (ARB terminology) or fragment program attribute registers (NV
        terminology) are accessed.

        When point sprite is enabled and the GL_COORD_REPLACE_ARB state for
        a given texture unit is GL_TRUE, the texture coordinate set for
        that texture unit is (s,t,0,1) where the point sprite-overridden
        s and t are described in the amended Section 3.3 below.  The
        important point is that r and q are forced to 0 and 1, respectively. 

        For fragment program extensions, r and q correspond to the z and w
        components of the respective fragment attribute.

    *   How does this extension interact with PolygonMode?

        RESOLVED:  If a polygon is rendered in point mode and POINT_SPRITE_ARB
        is enabled, its vertices will be rendered as point sprites.

    *   How does this extension interact with the point size attenuation
        functionality in ARB_point_parameters and OpenGL 1.4?

        RESOLVED:  Point sprites sizes are attenuated just like the sizes of
        non-sprite points.

    *   What push/pop attribute bits control the state of this extension?

        RESOLVED:  POINT_BIT for all the state.  Also ENABLE_BIT for
        the POINT_SPRITE_ARB enable.

    *   How are point sprites clipped?

        RESOLVED:  Point sprites are transformed as points, and standard point
        clipping operations are performed.  This can cause point sprites that
        move off the edge of the screen to disappear abruptly, in the same way
        that regular points do.  As with any other primitive, standard
        per-fragment clipping operations (scissoring, window ownership test)
        still apply.

New Procedures and Functions

    None

New Tokens


        POINT_SPRITE_ARB                               0x8861


        COORD_REPLACE_ARB                              0x8862




