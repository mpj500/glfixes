Name

    ARB_pixel_buffer_object

Name Strings

    GL_ARB_pixel_buffer_object

Notice

    Copyright (c) 2004-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete. Approved by ARB on December 7, 2004.

Contributors

    Ralf Biermann
    Nick Carter
    Derek Cornish
    Matt Craighead
    Mark Kilgard
    Dale Kirkland
    Jon Leech
    Brian Paul
    Thomas Roell
    Ian Romanick
    Jeremy Sandmel
    Shazia Rahman

Contact

    Mark J. Kilgard, NVIDIA Corporation (mjk 'at' nvidia.com)
    Ralf Biermann, NVIDIA Corporation (rbiermann 'at' nvidia.com)
    Derek Cornish, NVIDIA Corporation (dcornish 'at' nvidia.com)

IP Status

    None.

Version

    Last Modified Date: October 8, 2013
    Revision: 1.2

Number

    ARB Extension #42

Dependencies

    Written based on the wording of the OpenGL 2.0 specification.

    Assumes support for (at least) OpenGL 1.5 or the
    ARB_vertex_buffer_object extension.

    NV_pixel_data_range affects the definition of this extension.

    EXT_pixel_buffer_object interacts with this extension.

Overview

    This extension expands on the interface provided by the
    ARB_vertex_buffer_object extension (and later integrated into OpenGL
    1.5) in order to permit buffer objects to be used not only with vertex
    array data, but also with pixel data.  The intent is to provide more
    acceleration opportunities for OpenGL pixel commands.

    While a single buffer object can be bound for both vertex arrays and
    pixel commands, we use the designations vertex buffer object (VBO)
    and pixel buffer object (PBO) to indicate their particular usage in
    a given situation.

    Recall that buffer objects conceptually are nothing more than arrays
    of bytes, just like any chunk of memory.  ARB_vertex_buffer_object
    allows GL commands to source data from a buffer object by binding the
    buffer object to a given target and then overloading a certain set of
    GL commands' pointer arguments to refer to offsets inside the buffer,
    rather than pointers to user memory.  An offset is encoded in a
    pointer by adding the offset to a null pointer.

    This extension does not add any new functionality to buffer objects
    themselves.  It simply adds two new targets to which buffer objects
    can be bound: GL_PIXEL_PACK_BUFFER and GL_PIXEL_UNPACK_BUFFER.  When a
    buffer object is bound to the GL_PIXEL_PACK_BUFFER target, commands
    such as glReadPixels pack (write) their data into a buffer object.
    When a buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target,
    commands such as glDrawPixels and glTexImage2D unpack (read) their
    data from a buffer object.

    There are a several approaches to improve graphics performance
    with PBOs.  Some of the most interesting approaches are:

    - Streaming texture updates:  If the application uses
      glMapBuffer/glUnmapBuffer to write its data for glTexSubImage into
      a buffer object, at least one of the data copies usually required
      to download a texture can be eliminated, significantly increasing
      texture download performance.

    - Streaming draw pixels: When glDrawPixels sources client memory,
      OpenGL says the client memory can be modified immediately after the
      glDrawPixels command returns without disturbing the drawn image.
      This typically necessitates unpacking and copying the image prior
      to glDrawPixels returning.  However, when using glDrawPixels with
      a pixel pack buffer object, glDrawPixels may return prior to image
      unpacking because future modification of the buffer data requires
      explicit commands (glMapBuffer, glBufferData, or glBufferSubData).

    - Asynchronous glReadPixels:  If an application needs to read back a
      number of images and process them with the CPU, the existing GL
      interface makes it nearly impossible to pipeline this operation.
      The driver will typically send the hardware a readback command
      when glReadPixels is called, and then wait for all of the data to
      be available before returning control to the application.  Then,
      the application can either process the data immediately or call
      glReadPixels again; in neither case will the readback overlap with
      the processing.  If the application issues several readbacks
      into several buffer objects, however, and then maps each one to
      process its data, then the readbacks can proceed in parallel with
      the data processing.

    - Render to vertex array:  The application can use a fragment
      program to render some image into one of its buffers, then read
      this image out into a buffer object via glReadPixels.  Then, it can
      use this buffer object as a source of vertex data.

Issues

    1)  How does this extension relate to ARB_vertex_buffer_object?

        It builds on the ARB_vertex_buffer_object framework by adding
        two new targets that buffers can be bound to.

    2)  How does this extension relate to NV_pixel_data_range?

        This extension relates to NV_pixel_data_range in the same way
        that ARB_vertex_buffer_object relates to NV_vertex_array_range.
        To paraphrase the ARB_vertex_buffer_object spec, here are the
        main differences:

        - Applications are no longer responsible for memory management
          and synchronization.

        - Applications may still access high-performance memory directly,
          but this is optional, and such access is more restricted.

        - Buffer changes (glBindBuffer) are generally expected to be
          very lightweight, rather than extremely heavyweight
          (glPixelDataRangeNV).

        - A platform-specific allocator such as wgl/glXAllocateMemoryNV
          is no longer required.

    3)  Can a given buffer be used for both vertex and pixel data?

        RESOLVED: YES.  All buffers can be used with all buffer bindings,
        in whatever combinations the application finds useful.  Consider
        yourself warned, however, by the following issue.

    4)  May implementations make use of the target as a hint to select
        an appropriate memory space for the buffer?

        RESOLVED: YES, as long as such behavior is transparent to the
        application.  Some implementations may choose, for example, that
        they would rather stream vertex data from AGP memory, element
        (index) data from video memory, and pixel data from video memory.
        In fact, one can imagine arbitrarily complicated heuristics for
        selecting the memory space, based on factors such as the target,
        the "usage" argument, and the application's observed behavior.

        While it is entirely legal to create a buffer object by binding
        it to GL_ARRAY_BUFFER and loading it with data, then using it
        with the GL_PIXEL_UNPACK_BUFFER_ARB or GL_PIXEL_PACK_BUFFER_ARB
        binding, such behavior is liable to confuse the driver and may
        hurt performance.  If the driver implemented the hypothetical
        heuristic described earlier, such a buffer might have already
        been located in AGP memory, and so the driver would have to choose
        between two bad options: relocate the buffer into video memory, or
        accept lower performance caused by streaming pixel data from AGP.

    5)  Should all pixel path commands be supported, or just a subset
        of them?

        RESOLVED: ALL.  While there is little reason to believe that,
        say, glConvolutionFilter2D would benefit from this extension,
        there is no reason _not_ to support it.  The complete list of
        commands affected by this extension is listed in issues 17 and 18.

    6)  Should glPixelMap and glGetPixelMap be supported?

        RESOLVED: YES.  They're not really pixel path operations, but,
        again, there is no good reason to omit operations, and they _are_
        operations that pass around big chunks of pixel-related data.
        If we support glPolygonStipple, surely we should support this.

    7)  How does the buffer binding state push/pop?

        RESOLVED: As part of the pixel store client state.  This is
        analogous to how the ARB_vertex_buffer_object bindings
        pushed/popped as part of the vertex array client state.

    8)  Should NV_pixel_data_range (PDR) be used concurrently with pixel
        buffer objects ?

        RESOLVED: NO. While it would be possible to allocate a memory
        range for PDR, using a pointer into this memory range with one
        of the commands affected by PBOs will not work if a pixel buffer
        object other than zero is bound to the buffer binding point
        affecting the command.

        Pixel buffer objects always have higher precedence than PDR.

    9)  Should the INVALID_OPERATION error be generated if a pixel
        command would access data outside the range of the bound PBO?

        RESOLVED:  YES.  This requires considering the command parameters
        (such as width/height/depth/format/type/pointer), the current
        pixel store (pack/unpack) state, and the command operation itself
        to determine the maximum addressed byte for the pixel command.

        Brian Paul strongly recommends this behavior.

        This behavior should increase the reliability of using PBO and
        guard against programmer mistakes.

        This is particularly important for glReadPixels where returning
        data into a region outside the PBO could cause corruption of
        application memory.

        Such bounds checking is substantially more expensive for VBO
        accesses because bounds checking on a per-vertex element basis
        for each of multiple enabled vertex arrays prior to performing
        the command compromises the performance justification of VBO.

    10) If a pixel command with a bound PBO accesses data outside the
        range of the PBO, thereby generating a GL_INVALID_OPERATION error,
        can the pixel command end up being partially processed?

        RESOLVED:  NO.  As for all GL errors excepting GL_OUT_OF_MEMORY
        situations, "the command generating the error is ignored so that
        it has no effect on GL state or framebuffer contents."

        This means implementations must determine before the pixel command
        is performed whether the resulting read or write operations on
        the bound PBO will exceed the size of the PBO.

        This means an implementation is NOT allowed to detect out of
        bounds accesses in the middle of performing the command.

    11) How expensive is it to predetermine whether a pixel command
        accessing a PBO would have an out of bounds access?

        See the "Appendix on Pack/Unpack Range" to see the computations
        involved in computing the access limit.

        Implementations can further specialize and optimize the check
        to make this out of bounds checking negligible for any sizable
        pixel payload.

    12) Should feedback and select buffers output results into a
        buffer object?

        RESOLVED:  That might be useful for a future extension but is
        not appropriate for this extension.  New targets (other than
        PIXEL_PACK_BUFFER_ARB and PIXEL_UNPACK_BUFFER_ARB) make sense.

    13) Should NV_pixel_data_range interactions be documented in
        this specification?

        RESOLVED:  YES.  Interactions with NV_pixel_data_range are
        important to document to facilitate developers migrating to
        the multi-vendor ARB_pixel_buffer_object extension.  Discussion of
        interactions is limited to the issues and example usage sections.

        Other ARB specifications follow this policy, and Jon Leech agrees
        with this policy.

    14) Should an INVALID_OPERATION error be generated if the offset
        within a pixel buffer to a datum comprising of N basic machine
        units is not a multiple of N?

        RESOLVED:  YES.  This was stated for VBOs but no error was
        defined if the rule was violated.  Perhaps this needs to be
        better specified for VBO.

        For PBO, it is reasonable and cheap to enforce the alignment rule.
        For pixel commands it means making sure the offset is evenly
        divisible by the component or group size in basic machine units.

        This check is independent of the pixel store state because the
        pixel store state is specified in terms of pixels (not basic
        machine units) so pixel store addressing cannot create an
        unaligned access as long as the base offset is aligned.

        Certain commands (specifically glPolygonStipple,
        glGetPolygonStipple, glBitmap, glCompressedTexImage1D,
        glCompressedTexImage2D, glCompressedTexImage3D,
        glCompressedTexSubImage1D, glCompressedTexSubImage2D,
        glCompressedTexSubImage3D, and glGetCompressedTexImage) are not
        affected by this error because the data accessed is addressed
        at the granularity of basic machine units.

    15) Various commands do not make explicit reference to supporting
        packing or unpacking from a pixel buffer object but rather specify
        that parameters are handled in the same manner as glDrawPixels,
        glReadPixels, or the glCompressedTexImage commands.  So do such
        commands (example: glCompressedTexSubImage2D) use pixel buffers?

        RESOLVED:  YES.  Commands that have their behavior defined based
        on commands that read or write from pixel buffers will themselves
        read or write from pixel buffers.  Relying on this reduces the
        amount of specification language to be updated.

    16) What is the complete list of commands that can unpack (read)
        pixels from the current pixel unpack buffer object?

            glBitmap
            glColorSubTable
            glColorTable
            glCompressedTexImage1D
            glCompressedTexImage2D
            glCompressedTexImage3D
            glCompressedTexSubImage1D
            glCompressedTexSubImage2D
            glCompressedTexSubImage3D
            glConvolutionFilter1D
            glConvolutionFilter2D
            glDrawPixels
            glPixelMapfv
            glPixelMapuiv
            glPixelMapusv
            glPolygonStipple
            glSeparableFilter2D
            glTexImage1D
            glTexImage2D
            glTexImage3D
            glTexSubImage1D
            glTexSubImage2D
            glTexSubImage3D

    17) What is the complete list of commands that can pack (write)
        pixels into the current pixel pack buffer object?

            glGetCompressedTexImage
            glGetConvolutionFilter
            glGetHistogram
            glGetMinmax
            glGetPixelMapfv
            glGetPixelMapuiv
            glGetPixelMapusv
            glGetPolygonStipple
            glGetSeparableFilter,
            glGetTexImage
            glReadPixels

    18) How does support for pixel buffer objects affect the GLX protocol?

        UNRESOLVED:  See the "GLX Protocol" section.

    19) Prior to this extension, passing zero for the data argument of
        glTexImage1D, glTexImage2D, and glTexImage3D defined a texture
        image level without supplying an image.  How does this behavior
        change with this extension?

        RESOLVED:  The "unspecified image" behavior of the glTexImage
        calls only applies when bound to a zero pixel unpack buffer
        object.

        When bound to a non-zero pixel unpack buffer object, the data
        argument to these calls is treated as an offset rather than
        a pointer so zero is a reasonable and even likely value that
        corresponds to the very beginning of the buffer object's data.

        So to create a texture image level with unspecified image data,
        you MUST bind to the zero pixel unpack buffer object.

        See the ammended language at the end of section 3.8.1.

    20) How does this extension support video frame grabbers?

        RESOLVED:  This extension extends buffer objects so they can
        operate with pixel commands, rather than just vertex array
        commands.

        We anticipate that a future extension may provide a mechanism
        for transferring video frames from video frame grabber hardware
        or vertices from motion capture hardware (or any other source
        of aquired real-time data) directly into a buffer object to
        eliminate a copy.  Ideally, such transfers would be possible
        without requiring mapping of the buffer object.  But this
        extension does not provide such functionality.

        We anticipate such functionality to involve binding a buffer
        object to a new target type, configuring a source (or sink) for
        data (video frames, motion capture vertex sets, etc.), and then
        commands to initiate data transfers to the bound buffer object.

    21) Can this ARB extension share the same enumerants with the EXT
        version of this functionality?

        RESOLVED:  YES.  The ARB extension is functionally compatible
        with EXT_pixel_buffer_object except that the ARB version adds
        additional error checks for alignment and buffer bounds checking.

        The EXT behavior in the case of alignment violations and buffer
        bounds overflow are technically undefined.  The ARB extension
        simply defines the EXT extension's undefined behavior to be an
        OpenGL error.

        Using the same enumerants with firmed up error checking (that
        would otherwise indicate buggy usage) is preferable to two sets
        of enumerants where the older EXT set simply allows sloppy usage.

    22) The expected usage parameters (GL_STREAM_DRAW, etc.) for
        glBufferData are not clearly specified.  How can they be improved?

        RESOLVED:  To improve the clarity, replace the phrase "specified
        once" with "specified once per repetition of the usage pattern" so
        that it is clear for the STREAM_* usage modes (and the STATIC_*
        usage modes too, just much less frequently) that the repeated
        specification is part of a pattern and it is expected that the
        buffer can be, and will be for the STREAM_* usage patterns,
        specified again after being used and this is likely to repeat.

        Additionally, the *_COPY and *_DRAW usage patterns can source
        the data with "a GL drawing command" but also with image
        specification commands so change this phrase to "a GL drawing
        or image specification command."

    23) Is this the "right" way to expose render-to-vertex-array?

        DISCUSSION:  You can use this extension to render an image
        into a framebuffer, copy the pixels into a buffer object with
        glReadPixels, and then configure vertex arrays to source the pixel
        data as vertex attributes.  This necessarily involves a copy
        from the framebuffer to the buffer object.  Future extensions
        may provide mechanisms for copy-free render-to-vertex-array
        capabilities but that is not a design goal of this extension.

New Procedures and Functions

    None.


New Tokens


        PIXEL_PACK_BUFFER_ARB                        0x88EB
        PIXEL_UNPACK_BUFFER_ARB                      0x88EC


        PIXEL_PACK_BUFFER_BINDING_ARB                0x88ED
        PIXEL_UNPACK_BUFFER_BINDING_ARB              0x88EF


