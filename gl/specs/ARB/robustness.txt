Name

    ARB_robustness

Name Strings

    GL_ARB_robustness

Contributors

    Acorn Pooley, NVIDIA
    Anton Staaf, Google
    Barthold Lichtenbelt, NVIDIA
    Bruce Merry, ARM
    Chris Marrin, Apple
    Greg Roth, NVIDIA
    Jeff Bolz, NVIDIA
    Jon Leech 
    Kenneth Russell, Google
    Kent Miller, Apple
    Piers Daniell, NVIDIA
    Vladimir Vukicevic, Mozilla

Contact

    Mark Kilgard, NVIDIA (mjk 'at' nvidia.com)

Notice

    Copyright (c) 2010-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete. Approved by the ARB on June 9, 2010.
    Approved by the Khronos Board of Promoters on July 23, 2010.

Version

    Last Modified Date:  June 25, 2014
    Version:             18

Number

    ARB Extension #105

Dependencies

    This extension is written against the OpenGL 3.2 Compatibility
    Profile Specification but can apply to OpenGL 1.1 and up.

    This specification interacts with the ARB_imaging subset of the OpenGL
    3.2 Compatibility Profile.

    This specification interacts with the OpenGL 3.2 Core Profile.

    This specification interacts with EXT_direct_state_access.

    GLX_ARB_create_context_robustness and
    WGL_ARB_create_context_robustness are used to determine if a context
    implementing this extension supports robust buffer access, and if it
    supports reset notification. Equivalent platform-dependent
    mechanisms in other window-system integration layers such as EGL and
    AGL may exist for those platforms.

Overview

    Several recent trends in how OpenGL integrates into modern computer
    systems have created new requirements for robustness and security
    for OpenGL rendering contexts.
    
    Additionally GPU architectures now support hardware fault detection;
    for example, video memory supporting ECC (error correcting codes)
    and error detection.  OpenGL contexts should be capable of recovering
    from hardware faults such as uncorrectable memory errors.  Along with
    recovery from such hardware faults, the recovery mechanism can
    also allow recovery from video memory access exceptions and system
    software failures.  System software failures can be due to device
    changes or driver failures.

    Demands for increased software robustness and concerns about malware
    exploiting buffer overflows have lead API designers to provide
    additional "safe" APIs that bound the amount of data returned by
    an API query.  For example, the safer "snprintf" or "_snprintf"
    routines are prefered over "sprintf".
    
    The OpenGL API has many such robustness perils.  OpenGL queries
    return (write) some number of bytes to a buffer indicated by a
    pointer parameter.  The exact number of bytes written by existing
    OpenGL queries is not expressed directly by any specific parameter;
    instead the number of bytes returned is a complex function of one
    or more query arguments, sometimes context state such as pixel
    store modes or the active texture selector, and the current state
    of an object (such as a texture level's number of total texels).
    By the standards of modern API design, such queries are not "safe".
    Making these queries safer involves introducing a new query API with
    an additional parameter that specifies the number of bytes in the
    buffer and never writing bytes beyond that limit.

    Multi-threaded use of OpenGL contexts in a "share group" allow
    sharing of objects such as textures and programs.  Such sharing in
    conjunction with concurrent OpenGL commands stream execution by two
    or more contexts introduces hazards whereby one context can change
    objects in ways that can cause buffer overflows for another context's
    OpenGL queries.

    The original ARB_vertex_buffer_object extension includes an issue
    that explicitly states program termination is allowed when
    out-of-bounds vertex buffer object fetches occur. Modern GPUs
    capable of DirectX 10 enforce the well-defined behavior of always
    returning zero values for indices or non-fixed components in this
    case. Older GPUs may require extra checks to enforce well-defined
    (and termination free) behavior, but this expense is warranted when
    processing potentially untrusted content.

    The intent of this extension is to address some specific robustness
    goals:

    *   For all existing OpenGL queries, provide additional "safe" APIs 
        that limit data written to user pointers to a buffer size in 
        bytes that is an explicit additional parameter of the query.

    *   Provide a mechanism for an OpenGL application to learn about
        graphics resets that affect the context.  When a graphics reset
        occurs, the OpenGL context becomes unusable and the application
        must create a new context to continue operation. Detecting a
        graphics reset happens through an inexpensive query.

    *   Provide an enable to guarantee that out-of-bounds buffer object
        accesses by the GPU will have deterministic behavior and preclude
        application instability or termination due to an incorrect buffer
        access.  Such accesses include vertex buffer fetches of
        attributes and indices, and indexed reads of uniforms or
        parameters from buffers.

    In one anticipated usage model, WebGL contexts may make use of these
    robust features to grant greater stability when using untrusted code.
    WebGL contexts cannot call OpenGL commands directly but rather must
    route all OpenGL API calls through the web browser.  It is then the
    web browser that configures the context, using the commands in this
    extension, to enforce safe behavior. In this scenario, the WebGL
    content cannot specify or change the use of this extension's features
    itself; the web browser enforces this policy.

    There are other well-known robustness issues with the OpenGL API
    which this extension does not address.  For example, selector-based
    OpenGL commands are a well-known source of programming errors.
    Code to manipulate texture state may assume the active texture
    selector is set appropriately when an intervening function call
    obscures a change to the active texture state resulting in
    incorrectly updated or queried state.  The EXT_direct_state_access
    extension introduces selector-free OpenGL commands and queries to
    address that particular issue so this extension does not.

    The intent of this extension is NOT to deprecate any existing API
    and thereby introduce compatibility issues and coding burdens on
    existing code, but rather to provide new APIs to ensure a level of
    robustness commensurate with the expectations of modern applications
    of OpenGL.

IP Status

    No known IP claims.

New Procedures and Functions

    GRAPHICS RESET DETECTION AND RECOVERY

        enum GetGraphicsResetStatusARB();

    SIZED BUFFER QUERIES

    OpenGL 1.0 sized buffer queries

        void GetnMapdvARB(enum target, enum query, sizei bufSize, double *v);
        void GetnMapfvARB(enum target, enum query, sizei bufSize, float *v);
        void GetnMapivARB(enum target, enum query, sizei bufSize, int *v);

        void GetnPixelMapfvARB(enum map, sizei bufSize, float *values);
        void GetnPixelMapuivARB(enum map, sizei bufSize, uint *values);
        void GetnPixelMapusvARB(enum map, sizei bufSize, ushort *values);

        void GetnPolygonStippleARB(sizei bufSize, ubyte *pattern);

        void GetnTexImageARB(enum target, int level, enum format,
                             enum type, sizei bufSize, void *img);

        void ReadnPixelsARB(int x, int y, sizei width, sizei height,
                            enum format, enum type, sizei bufSize,
                            void *data);

    ARB_imaging sized buffer queries

        void GetnColorTableARB(enum target, enum format, enum type,
                               sizei bufSize, void *table);
        void GetnConvolutionFilterARB(enum target, enum format,
                                      enum type, sizei bufSize, void *image);
        void GetnSeparableFilterARB(enum target, enum format, enum type,
                                    sizei rowBufSize, void *row,
                                    sizei columnBufSize, void *column,
                                    void *span);
        void GetnHistogramARB(enum target, boolean reset, enum format,
                              enum type, sizei bufSize, void *values);
        void GetnMinmaxARB(enum target, boolean reset, enum format,
                           enum type, sizei bufSize, void *values);

    OpenGL 1.3 sized buffer queries

        void GetnCompressedTexImageARB(enum target, int lod,
                                       sizei bufSize, void *img);

    OpenGL 2.0 sized buffer queries

        void GetnUniformfvARB(uint program, int location, sizei bufSize,
                              float *params);
        void GetnUniformivARB(uint program, int location, sizei bufSize,
                              int *params);
        void GetnUniformuivARB(uint program, int location, sizei bufSize,
                               uint *params);
        void GetnUniformdvARB(uint program, int location, sizei bufSize,
                              double *params);

New Tokens


        NO_ERROR                                        0x0000
        GUILTY_CONTEXT_RESET_ARB                        0x8253
        INNOCENT_CONTEXT_RESET_ARB                      0x8254
        UNKNOWN_CONTEXT_RESET_ARB                       0x8255


        RESET_NOTIFICATION_STRATEGY_ARB                 0x8256


        LOSE_CONTEXT_ON_RESET_ARB                       0x8252
        NO_RESET_NOTIFICATION_ARB                       0x8261


        CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB          0x00000004


