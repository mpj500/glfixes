Name

    ARB_clip_control

Name Strings

    GL_ARB_clip_control

Contact

    Mark J. Kilgard, NVIDIA Corporation (mjk 'at' nvidia.com)

Contributors

    Timo Suoranta, Broadcom
    Piers Daniell, NVIDIA
    Stefan DÃ¶singer, CodeWeavers
    Jeff Bolz, NVIDIA
    John McDonald, NVIDIA
    Brian Paul, VMware, Mesa3D
    Jason Mitchell, Valve
    Alex Corscadden, VMware
    Simon Bennett, VMware
    Mark Callow, HI Corporation
    Patrick Doane, Blizzard
    Pat Brown, NVIDIA

Notice

    Copyright (c) 2014 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

    Complete. 
    Approved by the ARB on June 26, 2014.
    Ratified by the Khronos Board of Promoters on August 7, 2014.

Version

    Last Modified Date:  2014/07/30
    NVIDIA Revision:     17

Number

    ARB Extension #160

Dependencies

    Written based on the wording of the OpenGL 4.4 (Compatibility Profile)
    specification.

Overview

    This extension provides additional clip control modes to configure how
    clip space is mapped to window space.  This extension's goal is to 1)
    allow OpenGL to effectively match Direct3D's coordinate system
    conventions, and 2) potentially improve the numerical precision of the Z
    coordinate mapping.

    Developers interested in this functionality may be porting content
    from Direct3D to OpenGL and/or interested in improving the numerical
    accuracy of depth testing, particularly with floating-point depth
    buffers.

    OpenGL's initial and conventional clip control state is configured by:

        glClipControl(GL_LOWER_LEFT, GL_NEGATIVE_ONE_TO_ONE);

    where geometry with (x,y) normalized device coordinates of (-1,-1)
    correspond to the lower-left corner of the viewport and the near and far
    planes correspond to z normalized device coordinates of -1 and +1,
    respectively.

    This extension can be used to render content used in a Direct3D
    application in OpenGL in a straightforward way without modifying vertex or
    matrix data.  When rendering into a window, the command

        glClipControl(GL_LOWER_LEFT, GL_ZERO_TO_ONE);

    configures the near clip plane to correspond to a z normalized device
    coordinate of 0 as in Direct3D.  Geometry with (x,y) normalized device
    coordinates of (-1,-1) correspond to the lower-left corner of the viewport
    in Direct3D, so no change relative to OpenGL conventions is needed there.
    Other state related to screen-space coordinates may need to be modified
    for the application to map from Direct3D to OpenGL window coordinate
    conventions.  For example, the viewport rectangle in Direct3D needs to be
    inverted within the window to work properly in OpenGL windowed rendering:

       glViewport(d3d_viewport_x, 
                  window_height - (d3d_viewport_y + d3d_viewport_height),
                  d3d_viewport_width, d3d_viewport_height);

    When rendering Direct3D content into a framebuffer object in OpenGL, there
    is one complication -- how to get a correct image *out* of the related
    textures.  Direct3D applications would expect a texture coordinate of
    (0,0) to correspond to the upper-left corner of a rendered image, while
    OpenGL FBO conventions would map (0,0) to the lower-left corner of the
    rendered image.  For applications wishing to use Direct3D content with
    unmodified texture coordinates, the command

        glClipControl(GL_UPPER_LEFT, GL_ZERO_TO_ONE);

    configures the OpenGL to invert geometry vertically inside the viewport.
    Content at the top of the viewport for Direct3D will be rendered to the
    bottom of the viewport from the point of view of OpenGL, but will have a
    <t> texture coordinate of zero in both cases.  When operating in this
    mode, applications need not invert the programmed viewport rectangle as
    recommended for windowed rendering above.

    Applications happy with OpenGL's origin conventions but seeking
    potentially improved depth precision can configure clip controls using:

        glClipControl(GL_LOWER_LEFT, GL_ZERO_TO_ONE);

    to avoid the loss of precision from the DepthRange transformation
    (which by default is z_window = z_ndc * 0.5 + 0.5).

New Procedures and Functions

    void ClipControl(enum origin, enum depth);

New Tokens


        LOWER_LEFT                                  0x8CA1
        UPPER_LEFT                                  0x8CA2


        NEGATIVE_ONE_TO_ONE                         0x935E
        ZERO_TO_ONE                                 0x935F


        CLIP_ORIGIN                                 0x935C
        CLIP_DEPTH_MODE                             0x935D

