Name

    NV_bindless_texture

Name Strings

    GL_NV_bindless_texture

Contact

    Jeff Bolz, NVIDIA Corporation (jbolz 'at' nvidia.com)
    Pat Brown, NVIDIA Coproration (pbrown 'at' nvidia.com)

Contributors

    Daniel Koch, NVIDIA

Status

    Shipping

Version

    Last Modified Date:   June 13, 2014
    Author Revision:      3

Number

    OpenGL Extension #418
    OpenGL ES Extension #197

Dependencies

    This extension is written against the OpenGL 4.0 (Compatibility Profile)
    and OpenGL Shading Language 4.00 Specifications.

    OpenGL 4.0 or later is required for an OpenGL implementation.

    The GLSL portion of this extension requires NV_gpu_shader5, or a similar
    extension providing 64-bit integer support in the shading language.

    This extension interacts with OpenGL 4.0 (Core Profile).

    This extension interacts with OpenGL 3.3 and ARB_sampler_objects.

    This extension interacts with OpenGL 4.2, ARB_shader_image_load_store, and
    EXT_shader_image_load_store.

    This extension interacts with NV_vertex_attrib_integer_64bit.

    This extension interacts with NV_gpu_shader5.

    This extension interacts with EXT_direct_state_access.

    This extension interacts with ARB_seamless_cube_map and
    AMD_seamless_cubemap_per_texture.

    This extension interacts with NV_gpu_program4, NV_gpu_program5, and
    EXT_shader_image_load_store.

    This extension interacts with GLSL 4.20.

    OpenGL ES 3.0 or later is required for an OpenGL ES implementation.

    This extension interacts with OpenGL ES 3.1.

    This extension interacts with OES_shader_image_atomic.

    This extension interacts with EXT_texture_cube_map_array.

    This extension interacts with EXT_texture_buffer.

    This extension interacts with EXT_shader_io_blocks.

Overview

    This extension allows OpenGL applications to access texture objects in
    shaders without first binding each texture to one of a limited number of
    texture image units.  Using this extension, an application can query a
    64-bit unsigned integer texture handle for each texture that it wants to
    access and then use that handle directly in GLSL or assembly-based
    shaders.  The ability to access textures without having to bind and/or
    re-bind them is similar to the capability provided by the
    NV_shader_buffer_load extension that allows shaders to access buffer
    objects without binding them.  In both cases, these extensions
    significantly reduce the amount of API and internal GL driver overhead
    needed to manage resource bindings.

    This extension also provides similar capability for the image load, store,
    and atomic functionality provided by OpenGL 4.2, OpenGL ES 3.1 and the
    ARB_shader_image_load_store and EXT_shader_image_load_store extensions,
    where a texture can be accessed without first binding it to an image unit.
    An image handle can be extracted from a texture object using an API with a
    set of parameters similar to those for BindImageTextureEXT.

    This extension adds no new data types to GLSL.  Instead, it uses existing
    sampler and image data types and allows them to be populated with texture
    and image handles.  This extension does permit sampler and image data
    types to be used in more contexts than in unextended GLSL 4.00.  In
    particular, sampler and image types may be used as shader inputs/outputs,
    temporary variables, and uniform block members, and may be assigned to by
    shader code.  Constructors are provided to convert 64-bit unsigned integer
    values to and from sampler and image data types.  Additionally, new APIs
    are provided to load values for sampler and image uniforms with 64-bit
    handle inputs.  The use of existing integer-based Uniform* APIs is still
    permitted, in which case the integer specified will identify a texture
    image or image unit.  For samplers and images with values specified as
    texture image or image units, the GL implemenation will translate the unit
    number to an internal handle as required.

    To access texture or image resources using handles, the handles must first
    be made resident.  Accessing a texture or image by handle without first
    making it resident can result in undefined results, including program
    termination.  Since the amount of texture memory required by an
    application may exceed the amount of memory available to the system, this
    extension provides API calls allowing applications to manage overall
    texture memory consumption by making a texture resident and non-resident
    as required.


New Procedures and Functions

    uint64 GetTextureHandleNV(uint texture);
    uint64 GetTextureSamplerHandleNV(uint texture, uint sampler);

    void MakeTextureHandleResidentNV(uint64 handle);
    void MakeTextureHandleNonResidentNV(uint64 handle);

    uint64 GetImageHandleNV(uint texture, int level, boolean layered,
                            int layer, enum format);

    void MakeImageHandleResidentNV(uint64 handle, enum access);
    void MakeImageHandleNonResidentNV(uint64 handle);

    void UniformHandleui64NV(int location, uint64 value);
    void UniformHandleui64vNV(int location, sizei count, const uint64 *value);
    void ProgramUniformHandleui64NV(uint program, int location,
                                    uint64 value);
    void ProgramUniformHandleui64vNV(uint program, int location,
                                     sizei count, const uint64 *values);

    boolean IsTextureHandleResidentNV(uint64 handle);
    boolean IsImageHandleResidentNV(uint64 handle);


New Tokens



