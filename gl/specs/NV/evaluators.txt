Name

    NV_evaluators

Name Strings

    GL_NV_evaluators

Contact

    Matt Craighead, NVIDIA Corporation (mcraighead 'at' nvidia.com)
    Mark J. Kilgard, NVIDIA Corporation (mjk 'at' nvidia.com)

Notice

    Copyright NVIDIA Corporation, 2000, 2001.

IP Status

    NVIDIA Proprietary.

Status

    Discontinued.

    NVIDIA no longer supports this extension in driver updates after
    November 2002.  Instead, use conventional OpenGL evaluators or
    tessellate surfaces within your application.

Version

    NVIDIA Date: January 3, 2003
    $Date$ $Revision$
    $Id: //sw/main/docs/OpenGL/specs/old/GL_NV_evaluators.txt#2 $

Number

    225

Dependencies

    Written based on the wording of the OpenGL 1.2.1 specification.

    Assumes support for the ARB_multitexture extension.

    NV_vertex_program affects the definition of this extension.

Overview

    OpenGL evaluators provide applications with the capability to
    specify polynomial or rational curves and surfaces using control
    points relative to the Bezier basis.  The curves and surfaces are
    then drawn by evaluating the polynomials provided at various values
    for the u parameter of a curve or the (u,v) parameters of a surface.
    A tensor product formulation is used for the surfaces.

    For various historical reasons, evaluators have not been
    particularly popular as an interface for drawing curves and surfaces.
    This extension proposes a new interface for surfaces that provides a
    number of significant enhancements to the functionality provided by
    the original OpenGL evaluators.

    Many implementations never optimized evaluators, so applications
    often implemented their own algorithms instead.  This extension
    relaxes some restrictions that make it difficult to optimize
    evaluators.

    Also, new vertex attributes have been added to OpenGL through
    extensions, including multiple sets of texture coordinates, a
    secondary color, a fog coordinate, a vertex weight, and others.
    The extensions which added these vertex attributes never bothered
    to update the functionality of evaluators, since they were used so
    little in the first place.  In turn, evaluators have become more and
    more out of date, making it even less likely that developers will
    want to use them.  Most of the attributes are not a big loss, but
    support for multiple sets of texture coordinates would be absolutely
    essential to developers considering the use of evaluators.

    OpenGL evaluators only support rectangular patches, not triangular
    patches.  Although triangular patches can be converted into
    rectangular patches, direct support for triangular patches is likely
    to be more efficient.

    The tessellation algorithm used is too inflexible for most purposes;
    only the number of rows and columns can be specified.  Adjacent
    patches must then have identical numbers of rows and columns, or
    severe cracking will occur.  Ideally, a number of subdivisions could
    be specified for all four sides of a rectangular patch and for all
    three of a triangular patch.  This extension goes one step further
    and allows those numbers to be specified in floating-point, providing
    a mechanism for smoothly changing the level of detail of the surface.

    Meshes evaluated with EvalMesh are required to match up exactly
    with equivalent meshes evaluated with EvalCoord or EvalPoint.
    This makes it difficult or impossible to use optimizations such as
    forward differencing.

    Finally, little attention is given to some of the difficult problems
    that can arise when multiple patches are drawn.  Depending on the
    way evaluators are implemented, and depending on the orientation of
    edges, numerical accuracy problems can cause cracks to appear between
    patches with the same boundary control points.  This extension makes
    guarantees that an edge shared between two patches will match up
    exactly under certain conditions.

Issues

    *   Should one-dimensional evaluators be supported?

        RESOLVED: No.  This extension is intended for surfaces only.

    *   Should we support triangular patches?

        RESOLVED: Yes.  Otherwise, applications will have to convert
        them to rectangular patches themselves.  We can do this more
        efficiently.

    *   What domain should triangular patches be defined on?

        RESOLVED: (0,0),(1,0),(0,1).

    *   What memory layout should we use for triangular patch control
        points?

        RESOLVED: Both a[i][j], where i+j <= n, and a packed format are
        supported.

    *   Is it worth it to have "evaluator objects"?

        RESOLVED: No.  We will leave these out for now.

    *   Should we support the original evaluators' ability to specify
        a map from an arbitrary (u1,v1) to an arbitrary (u2,v2)?

        RESOLVED: No.  Maps will always extend from (0,0) to (1,1)
        and will always be evaluated from (0,0) to (1,1).

    *   Should the new interface support an EvalCoord-like syntax?

        RESOLVED: No.  We are only interested in evaluating an entire
        mesh at once.

    *   Should we support the "mode" parameter to the existing EvalMesh2,
        which allows the mesh to be tessellated in wireframe or as points?

        RESOLVED: No.  We will leave in the parameter and require that
        it be FILL, though, to leave room for a future extension.

    *   Should there be a new interface to specify control points or should
        Map2{fd} be reused?

        RESOLVED: A new interface.  There are enough changes compared to
        the original evaluators that we can't reuse the old interface
        without causing more problems.  For example, the target
        parameter of Map2{fd} is really a cross of target and index
        in MapControlPointsNV, and so it ends up creating an excessive
        number of enumerants.

    *   How should grids be specified?

        RESOLVED: A MapParameter command.  This is better than a new
        MapGrid- style command because it can be extended to include
        new parameter types.

    *   Should there be any rules about the order of generation of
        primitives within a single patch?

        RESOLVED: No.  The tessellation algorithm itself is not even
        specified, so it makes no sense to do this.  Applications must
        not depend on the order in which the primitives are drawn.

    *   Should the stride for MapControlPointsNV be specified in basic
        machine units (i.e. unsigned bytes) or in floats/doubles?

        RESOLVED: ubytes.  Most of the rest of OpenGL (vertex arrays,
        pixel path, etc.) uses ubytes; evaluators are actually
        inconsistent.

    *   How much leeway should implementations be given to choose their own
        algorithm for tessellation?

        RESOLVED: The integral tessellation scheme will require a
        specific tessellation of the boundary edges of the patch, but the
        interior tessellation is implementation-specific.  The fractional
        tessellation scheme will only require a minimum number of segments
        along each edge.  In either case, a minimum number of triangles
        for the entire patch is specified.

    *   Should there be rules to ensure that the triangles will be
        oriented in a consistent fashion?

        RESOLVED: Yes.  This is essential for features such as backface
        culling to work properly.  The rule given ensures that the
        orientation will be identical to the orientation used for the
        original evaluators.

    *   Should there be a separate MAX_EVAL_ORDER for rational surfaces?

        RESOLVED: Yes.  Rational surfaces require additional calculation to
        be done by the implementation, especially if AUTO_NORMAL is
        enabled.  Furthermore, the most useful rational surfaces are of low
        order.  For example, all the conic sections are quadratic rational
        surfaces.

    *   Should there be enables similar to AUTO_NORMAL that generate
        partials of U (tangents), partials of V, and/or binormals?

        RESOLVED:  No.  The application is responsible for configuring
        the evaluators appropriately.

        The auto normal functionality is supported because it is fairly
        complicated and was already a core part of OpenGL for evaluators.
        Plus there is already a "normal" vertex attribute for it to
        automatically generate.

        The partials of U and partials of V are fairly straightforward
        to evaluate (just take the derivative of the bivariate polynomial
        in terms of either U or V) plus there is not a particular vertex
        attribute associated with each of these.

New Procedures and Functions

    void MapControlPointsNV(enum target, uint index, enum type,
                            sizei ustride, sizei vstride,
                            int uorder, int vorder,
                            boolean packed,
                            const void *points)

    void MapParameterivNV(enum target, enum pname, const int *params)
    void MapParameterfvNV(enum target, enum pname, const float *params)

    void GetMapControlPointsNV(enum target, uint index, enum type,
                               sizei ustride, sizei vstride,
                               boolean packed, void *points)

    void GetMapParameterivNV(enum target, enum pname, int *params)
    void GetMapParameterfvNV(enum target, enum pname, float *params)
    void GetMapAttribParameterivNV(enum target, uint index, enum pname,
                                   int *params)
    void GetMapAttribParameterfvNV(enum target, uint index, enum pname,
                                   float *params)

    void EvalMapsNV(enum target, enum mode)

New Tokens


        EVAL_2D_NV                            0x86C0
        EVAL_TRIANGULAR_2D_NV                 0x86C1


        MAP_TESSELLATION_NV                   0x86C2


        MAP_ATTRIB_U_ORDER_NV                 0x86C3
        MAP_ATTRIB_V_ORDER_NV                 0x86C4


        EVAL_FRACTIONAL_TESSELLATION_NV       0x86C5

        EVAL_VERTEX_ATTRIB0_NV                0x86C6
        EVAL_VERTEX_ATTRIB1_NV                0x86C7
        EVAL_VERTEX_ATTRIB2_NV                0x86C8
        EVAL_VERTEX_ATTRIB3_NV                0x86C9
        EVAL_VERTEX_ATTRIB4_NV                0x86CA
        EVAL_VERTEX_ATTRIB5_NV                0x86CB
        EVAL_VERTEX_ATTRIB6_NV                0x86CC
        EVAL_VERTEX_ATTRIB7_NV                0x86CD
        EVAL_VERTEX_ATTRIB8_NV                0x86CE
        EVAL_VERTEX_ATTRIB9_NV                0x86CF
        EVAL_VERTEX_ATTRIB10_NV               0x86D0
        EVAL_VERTEX_ATTRIB11_NV               0x86D1
        EVAL_VERTEX_ATTRIB12_NV               0x86D2
        EVAL_VERTEX_ATTRIB13_NV               0x86D3
        EVAL_VERTEX_ATTRIB14_NV               0x86D4
        EVAL_VERTEX_ATTRIB15_NV               0x86D5


        MAX_MAP_TESSELLATION_NV               0x86D6
        MAX_RATIONAL_EVAL_ORDER_NV            0x86D7

