Name

    NV_gpu_shader5

Name Strings

    GL_NV_gpu_shader5

Contact

    Pat Brown, NVIDIA Corporation (pbrown 'at' nvidia.com)

Contributors

    Barthold Lichtenbelt, NVIDIA
    Chris Dodd, NVIDIA
    Eric Werness, NVIDIA
    Greg Roth, NVIDIA
    Jeff Bolz, NVIDIA
    Piers Daniell, NVIDIA
    Daniel Rakos, AMD

Status

    Shipping.

Version

    Last Modified Date:         09/11/2014
    NVIDIA Revision:            8

Number

    389

Dependencies

    This extension is written against the OpenGL 3.2 (Compatibility Profile)
    Specification.

    This extension is written against version 1.50 (revision 09) of the OpenGL
    Shading Language Specification.

    OpenGL 3.2 and GLSL 1.50 are required.

    ARB_gpu_shader5 is required.

    This extension interacts with ARB_gpu_shader5.

    This extension interacts with ARB_gpu_shader_fp64.

    This extension interacts with ARB_tessellation_shader.

    This extension interacts with NV_shader_buffer_load.

    This extension interacts with EXT_direct_state_access.

    This extension interacts with EXT_vertex_attrib_64bit and
    NV_vertex_attrib_integer_64bit.


Overview

    This extension provides a set of new features to the OpenGL Shading
    Language and related APIs to support capabilities of new GPUs.  Shaders
    using the new functionality provided by this extension should enable this
    functionality via the construct

      #extension GL_NV_gpu_shader5 : require     (or enable)

    This extension was developed concurrently with the ARB_gpu_shader5
    extension, and provides a superset of the features provided there.  The
    features common to both extensions are documented in the ARB_gpu_shader5
    specification; this document describes only the addition language features
    not available via ARB_gpu_shader5.  A shader that enables this extension
    via an #extension directive also implicitly enables the common
    capabilities provided by ARB_gpu_shader5.

    In addition to the capabilities of ARB_gpu_shader5, this extension
    provides a variety of new features for all shader types, including:

      * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector
        data types, including uniform API, uniform buffer object, and shader
        input and output support;

      * the ability to aggregate samplers into arrays, index these arrays with
        arbitrary expressions, and not require that non-constant indices be
        uniform across all shader invocations;

      * new built-in functions to pack and unpack 64-bit integer types into a
        two-component 32-bit integer vector;

      * new built-in functions to pack and unpack 32-bit unsigned integer
        types into a two-component 16-bit floating-point vector;

      * new built-in functions to convert double-precision floating-point
        values to or from their 64-bit integer bit encodings;

      * new built-in functions to compute the composite of a set of boolean
        conditions a group of shader threads;

      * vector relational functions supporting comparisons of vectors of 8-,
        16-, and 64-bit integer types or 16-bit floating-point types; and

      * extending texel offset support to allow loading texel offsets from
        regular integer operands computed at run-time, except for lookups with
        gradients (textureGrad*).

    This extension also provides additional support for processing patch
    primitives (introduced by ARB_tessellation_shader).
    ARB_tessellation_shader requires the use of a tessellation evaluation
    shader when processing patches, which means that patches will never
    survive past the tessellation pipeline stage.  This extension lifts that
    restriction, and allows patches to proceed further in the pipeline and be
    used

      * as input to a geometry shader, using a new "patches" layout qualifier;

      * as input to transform feedback;

      * by fixed-function rasterization stages, in which case the patches are
        drawn as independent points.

    Additionally, it allows geometry shaders to read per-patch attributes
    written by a tessellation control shader using input variables declared
    with "patch in".


New Procedures and Functions

    void Uniform1i64NV(int location, int64EXT x);
    void Uniform2i64NV(int location, int64EXT x, int64EXT y);
    void Uniform3i64NV(int location, int64EXT x, int64EXT y, int64EXT z);
    void Uniform4i64NV(int location, int64EXT x, int64EXT y, int64EXT z,
                       int64EXT w);
    void Uniform1i64vNV(int location, sizei count, const int64EXT *value);
    void Uniform2i64vNV(int location, sizei count, const int64EXT *value);
    void Uniform3i64vNV(int location, sizei count, const int64EXT *value);
    void Uniform4i64vNV(int location, sizei count, const int64EXT *value);

    void Uniform1ui64NV(int location, uint64EXT x);
    void Uniform2ui64NV(int location, uint64EXT x, uint64EXT y);
    void Uniform3ui64NV(int location, uint64EXT x, uint64EXT y, uint64EXT z);
    void Uniform4ui64NV(int location, uint64EXT x, uint64EXT y, uint64EXT z,
                       uint64EXT w);
    void Uniform1ui64vNV(int location, sizei count, const uint64EXT *value);
    void Uniform2ui64vNV(int location, sizei count, const uint64EXT *value);
    void Uniform3ui64vNV(int location, sizei count, const uint64EXT *value);
    void Uniform4ui64vNV(int location, sizei count, const uint64EXT *value);

    void GetUniformi64vNV(uint program, int location, int64EXT *params);


    (The following function is also provided by NV_shader_buffer_load.)

    void GetUniformui64vNV(uint program, int location, uint64EXT *params);


    (All of the following ProgramUniform* functions are supported if and only
     if EXT_direct_state_access is supported.)

    void ProgramUniform1i64NV(uint program, int location, int64EXT x);
    void ProgramUniform2i64NV(uint program, int location, int64EXT x,
                              int64EXT y);
    void ProgramUniform3i64NV(uint program, int location, int64EXT x, 
                              int64EXT y, int64EXT z);
    void ProgramUniform4i64NV(uint program, int location, int64EXT x, 
                              int64EXT y, int64EXT z, int64EXT w);
    void ProgramUniform1i64vNV(uint program, int location, sizei count,
                               const int64EXT *value);
    void ProgramUniform2i64vNV(uint program, int location, sizei count,
                               const int64EXT *value);
    void ProgramUniform3i64vNV(uint program, int location, sizei count,
                               const int64EXT *value);
    void ProgramUniform4i64vNV(uint program, int location, sizei count,
                               const int64EXT *value);

    void ProgramUniform1ui64NV(uint program, int location, uint64EXT x);
    void ProgramUniform2ui64NV(uint program, int location, uint64EXT x, 
                               uint64EXT y);
    void ProgramUniform3ui64NV(uint program, int location, uint64EXT x, 
                               uint64EXT y, uint64EXT z);
    void ProgramUniform4ui64NV(uint program, int location, uint64EXT x, 
                               uint64EXT y, uint64EXT z, uint64EXT w);
    void ProgramUniform1ui64vNV(uint program, int location, sizei count,
                                const uint64EXT *value);
    void ProgramUniform2ui64vNV(uint program, int location, sizei count,
                                const uint64EXT *value);
    void ProgramUniform3ui64vNV(uint program, int location, sizei count,
                                const uint64EXT *value);
    void ProgramUniform4ui64vNV(uint program, int location, sizei count, 
                                const uint64EXT *value);


New Tokens


        INT64_NV                                        0x140E
        UNSIGNED_INT64_NV                               0x140F

        INT8_NV                                         0x8FE0
        INT8_VEC2_NV                                    0x8FE1
        INT8_VEC3_NV                                    0x8FE2
        INT8_VEC4_NV                                    0x8FE3
        INT16_NV                                        0x8FE4
        INT16_VEC2_NV                                   0x8FE5
        INT16_VEC3_NV                                   0x8FE6
        INT16_VEC4_NV                                   0x8FE7
        INT64_VEC2_NV                                   0x8FE9
        INT64_VEC3_NV                                   0x8FEA
        INT64_VEC4_NV                                   0x8FEB
        UNSIGNED_INT8_NV                                0x8FEC
        UNSIGNED_INT8_VEC2_NV                           0x8FED
        UNSIGNED_INT8_VEC3_NV                           0x8FEE
        UNSIGNED_INT8_VEC4_NV                           0x8FEF
        UNSIGNED_INT16_NV                               0x8FF0
        UNSIGNED_INT16_VEC2_NV                          0x8FF1
        UNSIGNED_INT16_VEC3_NV                          0x8FF2
        UNSIGNED_INT16_VEC4_NV                          0x8FF3
        UNSIGNED_INT64_VEC2_NV                          0x8FF5
        UNSIGNED_INT64_VEC3_NV                          0x8FF6
        UNSIGNED_INT64_VEC4_NV                          0x8FF7
        FLOAT16_NV                                      0x8FF8
        FLOAT16_VEC2_NV                                 0x8FF9
        FLOAT16_VEC3_NV                                 0x8FFA
        FLOAT16_VEC4_NV                                 0x8FFB



          


