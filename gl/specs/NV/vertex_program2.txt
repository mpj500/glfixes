Name

    NV_vertex_program2

Name Strings

    GL_NV_vertex_program2

Contact

    Pat Brown, NVIDIA Corporation (pbrown 'at' nvidia.com)
    Mark Kilgard, NVIDIA Corporation (mjk 'at' nvidia.com)

Notice

    Copyright NVIDIA Corporation, 2000-2002.

IP Status

    NVIDIA Proprietary.

Status

    Implemented in CineFX (NV30) Emulation driver, August 2002.
    Shipping in Release 40 NVIDIA driver for CineFX hardware, January 2003.

Version

    Last Modified Date:  03/18/2008
    NVIDIA Revision:     33

Number

    287

Dependencies

    Written based on the wording of the OpenGL 1.3 Specification and requires
    OpenGL 1.3.

    Written based on the wording of the NV_vertex_program extension
    specification, version 1.0.

    NV_vertex_program is required.

Overview

    This extension further enhances the concept of vertex programmability
    introduced by the NV_vertex_program extension, and extended by
    NV_vertex_program1_1.  These extensions create a separate vertex program
    mode where the configurable vertex transformation operations in unextended
    OpenGL are replaced by a user-defined program.

    This extension introduces the VP2 execution environment, which extends the
    VP1 execution environment introduced in NV_vertex_program.  The VP2
    environment provides several language features not present in previous
    vertex programming execution environments:

      * Branch instructions allow a program to jump to another instruction
        specified in the program.

      * Branching support allows for up to four levels of subroutine
        calls/returns.

      * A four-component condition code register allows an application to
        compute a component-wise write mask at run time and apply that mask to
        register writes.  

      * Conditional branches are supported, where the condition code register
        is used to determine if a branch should be taken.

      * Programmable user clipping is supported support (via the CLP0-CLP5
        clip distance registers).  Primitives are clipped to the area where
        the interpolated clip distances are greater than or equal to zero.

      * Instructions can perform a component-wise absolute value operation on
        any operand load.

    The VP2 execution environment provides a number of new instructions, and
    extends the semantics of several instructions already defined in
    NV_vertex_program.

      * ARR:  Operates like ARL, except that float-to-int conversion is done
        by rounding.  Equivalent results could be achieved (less efficiently)
        in NV_vertex program using an ADD/ARL sequence and a program parameter
        holding the value 0.5.

      * BRA, CAL, RET:  Branch, subroutine call, and subroutine return
        instructions.

      * COS, SIN:  Adds support for high-precision sine and cosine
        computations.

      * FLR, FRC:  Adds support for computing the floor and fractional portion
        of floating-point vector components.  Equivalent results could be
        achieved (less efficiently) in NV_vertex_program using the EXP
        instruction to compute the fractional portion of one component at a
        time.

      * EX2, LG2:  Adds support for high-precision exponentiation and
        logarithm computations.

      * ARA:  Adds pairs of components of an address register; useful for
        looping and other operations.

      * SEQ, SFL, SGT, SLE, SNE, STR:  Add six new "set on" instructions,
        similar to the SLT and SGE instructions defined in NV_vertex_program.
        Equivalent results could be achieved (less efficiently) in
        NV_vertex_program with multiple SLT, SGE, and arithmetic instructions.

      * SSG:  Adds a new "set sign" operation, which produces a vector holding
        negative one for negative components, zero for components with a value
        of zero, and positive one for positive components.  Equivalent results
        could be achieved (less efficiently) in NV_vertex_program with
        multiple SLT, SGE, and arithmetic instructions.

      * The ARL instruction is extended to operate on four components instead
        of a single component.

      * All instructions that produce integer or floating-point result vectors
        have variants that update the condition code register based on the
        result vector.

    This extension also raises some of the resource limitations in the
    NV_vertex_program extension.

      * 256 program parameter registers (versus 96 in NV_vertex_program).

      * 16 temporary registers (versus 12 in NV_vertex_program).

      * Two four-component integer address registers (versus one
        single-component register in NV_vertex_program).

      * 256 total vertex program instructions (versus 128 in
        NV_vertex_program).
      
      * Including loops, programs can execute up to 64K instructions.


Issues

    This extension builds upon the NV_vertex_program extension.  Should this
    specification contain selected edits to the NV_vertex_program
    specification or should the specs be unified?

      RESOLVED:  Since NV_vertex_program and NV_vertex_program2 programs share
      many features, the main section of this specification is unified and
      describes both types of programs.  Other sections containing
      NV_vertex_program features that are unchanged by this extension will not
      be edited.

    How can a program use condition codes to avoid extra computations?

      Consider the example of evaluating the OpenGL lighting model for a
      given light.  If the diffuse dot product is negative (roughly 1/2 the
      time for random geometry), the only contribution to the light is
      ambient.  In this case, condition codes and branching can skip over a
      number of unneeded instructions.
      
          # R0 holds accumulated light color
          # R2 holds normal
          # R3 holds computed light vector
          # R4 holds computed half vector
          # c[0] holds ambient light/material product
          # c[1] holds diffuse light/material product
          # c[2].xyz holds specular light/material product
          # c[2].w   holds specular exponent
          DP3C R1.x, R2, R3;            # diffuse dot product
          ADD  R0, R0, c[0];            # accumulate ambient
          BRA  pointsAway (LT.x)        # skip rest if diffuse dot < 0
          MOV  R1.w, c[2].w;
          DP3  R1.y, R2, R4;            # specular dot product
          LIT  R1, R1;                  # compute expontiated specular
          MAD  R4, c[1], R0.y;          # accumulate diffuse
          MAD  R4, c[2], R0.z;          # accumulate specular
        pointsAway:
          ...                           # continue execution

    How can a program use subroutines?

      With subroutines, a program can encapsulate a small piece of
      functionality into a subroutine and call it multiple times, as in CPU
      code.  Applications will need to identify the registers used to pass
      data to and from the subroutine.  

      Subroutines could be used for applications like evaluating lighting
      equations for a single light.  With conditional branching and
      subroutines, a variable number of lights (which could even vary
      per-vertex) can be easily supported.
    
        accumulate:
          # R0 holds the accumulated result
          # R1 holds the value to add
          ADD R0, R1;
          RET;

          # Compute floor(A)*B by repeated addition using a subroutine.  Yes,
          # this is a stupid example. 
          #
          # c[0] holds (A,B,0,1).
          # R0 holds the accumulated result
          # R1 holds B, the value to accumulate.
          # R2 holds the number of iterations remaining.
          MOV R0, c[0].z;               # start with zero
          MOV R1, c[0].y;
          FLRC R2.x, c[0].x;
          BRA done (LE.x);
        top:
          CAL accumulate;
          ADDC R2.x, R2.x, -c[0].w;     # decrement count
          BRA top (GT.x);
        done:
          ...

    How can conventional OpenGL clip planes be supported in vertex programs?

      The clip distance in the OpenGL specification can be evaluated with a
      simple DP4 instruction that writes to one of the six clip distance
      registers.  Primitives will automatically be clipped to the half-space
      where o[CLPx] >= 0, which matches the definition in the spec.

          # R0 holds eye coordinates
          # c[0] holds eye-space clip plane coefficients
          DP4 o[CLP0].x, R0, c[0];

      Note that the clip plane or clip distance volume corresponding to the
      o[CLPn] register used must be enabled, or no clipping will be performed.

      The clip distance registers allow for clip distance volumes to be
      computed more-or-less arbitrarily.  To approximate clipping to a sphere
      of radius <n>, the following code can be used.

          # R0 holds eye coordinates
          # c[0].xyz holds sphere center
          # c[0].w holds the square of the sphere radius
          SUB R1.xyz, R0, c[0];            # distance vector
          DP3 R1.w, R1, R1;                # compute distance squared
          SUB o[CLP0].x, c[0].w, R1.w;     # compute r^2 - d^2

      Since the clip distance is interpolated linearly over a primitive, the
      clip distance evaluated at a point will represent a piecewise-linear
      approximation of the true distance.  The approximation will become
      increasingly more accurate as the primitive is tesselated more finely.

    How can looping be achieved in vertex programs?

      Simple loops can be achieved using a general purpose floating-point
      register component as a counter.  The following code calls a function
      named "function" <n> times, where <n> is specified in a program
      parameter register component.

          # c[0].x holds the number of iterations to execute.
          # c[1].x holds the constant 1.0.
          MOVC R15.x, c[0].x;
        startLoop:
          CAL  function (GT.x);             # if (counter > 0) function();
          SUBC R15.x, R15.x, c[1].x;        # counter = counter - 1;
          BRA  startLoop (GT.x);            # if (counter > 0) goto start;
        endLoop:
          ...

      More complex loops (where a separate index may be needed for indexed
      addressing into the program parameter array) can be achieved using the
      ARA instruction, which will add the x/z and y/w components of an address
      register.

          # c[0].x holds the number of iterations to execute
          # c[0].y holds the initial index value
          # c[0].z holds the constant -1.0 (used for the iteration count)
          # c[0].w holds the index step value
          ARLC A1, c[0];
        startLoop:
          CAL  function (GT.x);             # if (counter > 0) function();
                                            # Note: A1.y can be used for
                                            # indexing in function().
          ARAC A1.xy, A1;                   # counter = counter - 1;
                                            # index += loopStep;
          BRA  startLoop (GT.x);            # if (counter > 0) goto start;
        endLoop:
          ...
          
    Should this specification add support for vertex state programs beyond the
    VP1 execution environment?

      No.  Vertex state programs are a little-used feature of
      NV_vertex_program and don't perform particularly well.  They are still
      supported for compatibility with the original NV_vertex_program spec,
      but they will not be extended to support new features.

    How are NaN's be handled in the "set on" instructions (SEQ, SGE, SGT, SLE,
    SLT, SNE)?  What about MIN, MAX?  SSG?  When doing condition code tests?

      Any of these instructions involving a NaN operand will produce a NaN
      result.  This behavior differs from the NV_fragment_program extension.
      There, SEQ, SGE, SGT, SLE, and SLT will produce 0.0 if either operand is
      a NaN, and SNE will produce 1.0 if either operand is a NaN.

      For condition code updates, NaN values will result in "UN" condition
      codes.  All conditionals using a "UN" condition code, except "TR" and
      "NE" will evaluate to false.  This behavior is identical to the
      functionality in NV_fragment_program.

    How can the various features of this extension be used to provide skinning
    functionality similar to that in ARB_vertex_blend and ARB_matrix_palette?
    And how can that functionality be extended?

      Assume an implementation that allows application of up to 8 matrices at
      once.  Further assume that v[12].xyzw and v[13].xyzw hold the set of 8
      weights, and v[14].xyzw and v[15].xyzw hold the set of 8 matrix indices.
      Furthermore, assume that the palette of matrices are stored/tracked at
      c[0], c[4], c[8], and so on.  As an additional optimization, an
      application can specify that fewer than 8 matrices should be applied by
      storing a negative palette index immediately after the last index is
      applied.

      Skinning support in this example can be provided by the following code:

          ARLC A0, v[14];                 # load 4 palette indices at once
          DP4 R1.x, c[A0.x+0], v[0];      # 1st matrix transform
          DP4 R1.y, c[A0.x+1], v[0];
          DP4 R1.z, c[A0.x+2], v[0];
          DP4 R1.w, c[A0.x+3], v[0];
          MUL R0, R1, v[12].x;            # accumulate weighted sum in R0
          BRA end (LT.y);                 # stop on a negative matrix index
          DP4 R1.x, c[A0.y+0], v[0];      # 2nd matrix transform
          DP4 R1.y, c[A0.y+1], v[0];
          DP4 R1.z, c[A0.y+2], v[0];
          DP4 R1.w, c[A0.y+3], v[0];
          MAD R0, R1, v[12].y, R0;        # accumulate weighted sum in R0
          BRA end (LT.z);                 # stop on a negative matrix index

          ...                             # 3rd and 4th matrix transform

          ARLC A0, v[15];                 # load next four palette indices
          BRA end (LT.x);
          DP4 R1.x, c[A0.x+0], v[0];      # 5th matrix transform
          DP4 R1.y, c[A0.x+1], v[0];
          DP4 R1.z, c[A0.x+2], v[0];
          DP4 R1.w, c[A0.x+3], v[0];
          MAD R0, R1, v[13].x, R0;        # accumulate weighted sum in R0
          BRA end (LT.y);                 # stop on a negative matrix index

          ...                             # 6th, 7th, and 8th matrix transform
        
        end:
          ...                             # any additional instructions

      The amount of code used by this example could further be reduced using a
      subroutine performing four transformations at a time:

          ARLC A0, v[14];  # load first four indices
          CAL  skin4;      # do first four transformations
          BRA  end (LT);   # end if any of the first 4 indices was < 0
          ARLC A0, v[15];  # load second four indices
          CAL  skin4;      # do second four transformations
        end:
          ...              # any additional instructions

    Why does the RCC instruction exist?

      RESOLVED:  To perform numeric operations that will avoid overflow and
      underflow issues.

    Should the specification provide more examples?

      RESOLVED:  It would be nice.


New Procedures and Functions

    None.


New Tokens



