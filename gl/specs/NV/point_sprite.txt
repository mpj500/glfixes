Name

    NV_point_sprite

Name Strings

    GL_NV_point_sprite

Contact

    Matt Craighead, NVIDIA Corporation (mcraighead 'at' nvidia.com)

Notice

    Copyright NVIDIA Corporation, 2001, 2002.

IP Status

    No known IP issues.

Status

    Shipping (version 1.1)

Version

    NVIDIA Date: March 6, 2003 (version 1.3)

Number

    262

Dependencies

    Written based on the wording of the OpenGL 1.3 specification.

    Assumes support for the EXT_point_parameters extension.

Overview

    Applications such as particle systems usually must use OpenGL quads
    rather than points to render their geometry, since they would like to
    use a custom-drawn texture for each particle, rather than the
    traditional OpenGL round antialiased points, and each fragment in
    a point has the same texture coordinates as every other fragment.

    Unfortunately, specifying the geometry for these quads can be quite
    expensive, since it quadruples the amount of geometry required, and
    it may also require the application to do extra processing to compute
    the location of each vertex.

    The goal of this extension is to allow such apps to use points rather
    than quads.  When GL_POINT_SPRITE_NV is enabled, the state of point
    antialiasing is ignored.  For each texture unit, the app can then
    specify whether to replace the existing texture coordinates with
    point sprite texture coordinates, which are interpolated across the
    point.  Finally, the app can set a global parameter for the way to
    generate the R coordinate for point sprites; the R coordinate can
    either be zero, the input S coordinate, or the input R coordinate.
    This allows applications to use a 3D texture to represent a point
    sprite that goes through an animation, with filtering between frames,
    for example.

Issues

    *   Should this spec say that point sprites get converted into quads?

        RESOLVED: No, this would make the spec much uglier, because then
        we'd have to say that polygon smooth and stipple get turned off,
        etc.  Better to provide a formula for computing the texture
        coordinates and leave them as points.

    *   How are point sprite texture coordinates computed?

        RESOLVED: They move smoothly as the point moves around on the
        screen, even though the pixels touched by the point do not.  The
        exact formula is given in the spec.  Note that point sprites' T
        texture coordinate decreases, not increases, with Y; that is,
        point sprite textures go top-down, not bottom-up.

    *   How do point sizes for point sprites work?

        RESOLVED: The original NV_point_sprite spec treated point sprites
        as being sized like aliased points, i.e., integral sizes only.
        This was a mistake, because it can lead to visible popping
        artifacts.  In addition, it limits the size of points
        unnecessarily.

        This revised specification treats point sprite sizes more like
        antialiased point sizes, but with more leniency.  Implementations
        may choose to not clamp the point size to the antialiased point
        size range.  The set of point sprite sizes available must be a
        superset of the antialiased point sizes.  However, whereas
        antialiased point sizes are all evenly spaced by the point size
        granularity, point sprites can have an arbitrary set of sizes.
        This lets implementations use, e.g., floating-point sizes.

        It is anticipated that this behavior change will not cause any
        problems for compatibility.  In fact, it should be beneficial to
        quality.

    *   Should there be a way to query the list of supported point sprite
        sizes?

        RESOLVED: No.  If an implementation were to use, say, a single-
        precision IEEE float to represent point sizes, the list would be
        rather long.

    *   Do mipmaps apply to point sprites?

        RESOLVED: Yes.  They are similar to quads in this respect.

    *   What of this extension's state is per-texture unit and what
        of this extension's state is state is global?

        RESOLVED: The GL_POINT_SPRITE_NV enable and POINT_SPRITE_R_MODE_NV
        state are global.  The COORD_REPLACE_NV state is per-texture unit
        (state set by TexEnv is per-texture unit).

    *   Should we create an entry point for the R mode?

        RESOLVED: No, we take advantage of the existing glPointParameter
        interface.  Unfortunately, EXT_point_parameters does not define a
        PointParameteri entry point.  This extension adds one.  It could
        live without, but it's a little annoying to have to use a float
        interface to specify an enumerant.

        This is definitely not TexEnv state, because it is global, not
        per texture unit.

    *   What should the suffix for PointParameteri[v] be?

        RESOLVED: NV.  This is an NV extension, and therefore any new
        entry points must be NV also.  This is a bit less aesthetically
        pleasing than matching the EXT suffixes of EXT_point_parameters,
        but it is the right thing to do.

    *   Should there be a global on/off switch for point sprites, or
        should the per-unit enable imply that switch?

        RESOLVED: There is a global switch to turn it on and off.  This
        is probably more convenient for both driver and app, and it
        simplifies the spec.

    *   What should the TexEnv mode for point sprites be called?

        RESOLVED: After much deliberation, COORD_REPLACE_NV seems to be
        appropriate.

    *   What is the motivation for each of the three point sprite R
        modes?

        The R mode is most convenient for applications that may already
        be drawing their own "point sprites" by rendering quads.  These
        applications already need to put the R coordinate in R, and they
        do not need to change their code.

        The S mode is most convenient for applications that do not use
        vertex programs, because it allows them to use TexCoord1 rather
        than TexCoord3 to specify their third texture coordinate.  This
        reduces the size of the vertex data.  Applications that use
        vertex programs are largely unaffected by this, because they can
        map the input S texture coordinate into the output R coordinate
        if they so desire.

        The zero mode may allow some applications to more easily obtain
        the behavior they want out of the dot product functionality of
        the NV_texture_shader extension.  It reduces these dot products
        from three-component dot products into two-component dot
        products.  In some implementations, it may also have higher
        performance than the other modes.

        There is no mode corresponding to the T or Q coordinates because
        we cannot envision a scenario where such modes would be useful.

    *   What is the interaction with multisample points, which are round?

        RESOLVED: Point sprites are rasterized as squares, even in
        multisample mode.  Leaving them as round points would make the
        feature useless.

    *   How does the point sprite extension interact with fragment
        program extensions (ARB_fragment_program, NV_fragment_program,
        etc)?

        RESOLVED: The primary issue is how the interpolanted texture
        coordinate set appears when fragment attribute variables
        (ARB terminology) or fragment program attribute registers (NV
        terminology) are accessed.

        When point sprite is enabled and the GL_COORD_REPLACE_NV state for
        a given texture unit is GL_TRUE, the texture coordinate set for
        that texture unit is (s,t,r,1) where the point sprite-overriden
        s, t, and r are described in the amended Section 3.3 below.
        The important point is that q is forced to 1.

        For fragment program extensions, q cooresponds to the w component
        of the respective fragment attribute.

    *   What push/pop attribute bits control the state of this extension?

        RESOLVED:  POINT_BIT for all the state.  Also ENABLE_BIT for
        the POINT_SPRITE_NV enable.

New Procedures and Functions

    void PointParameteriNV(enum pname, int param)
    void PointParameterivNV(enum pname, const int *params)

New Tokens


        POINT_SPRITE_NV                                0x8861


        COORD_REPLACE_NV                               0x8862




        POINT_SPRITE_R_MODE_NV                         0x8863



