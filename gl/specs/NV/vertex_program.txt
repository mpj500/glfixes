Name
    
    NV_vertex_program

Name Strings

    GL_NV_vertex_program

Contact

    Mark J. Kilgard, NVIDIA Corporation (mjk 'at' nvidia.com)

Notice

    Copyright NVIDIA Corporation, 2000, 2001, 2002, 2003, 2004.

IP Status

    NVIDIA Proprietary.

Status

    Shipping, spec at version 1.10.

Version

    NVIDIA Date:        March 31, 2009
    Revision:           1.10

Number

    233

Dependencies

    Written based on the wording of the OpenGL 1.2.1 specification and
    requires OpenGL 1.2.1.

    Requires support for the ARB_multitexture extension with at least
    two texture units.

    EXT_point_parameters affects the definition of this extension.

    EXT_secondary_color affects the definition of this extension.

    EXT_fog_coord affects the definition of this extension.

    EXT_vertex_weighting affects the definition of this extension.

    ARB_imaging affects the definition of this extension.

Overview

    Unextended OpenGL mandates a certain set of configurable per-vertex
    computations defining vertex transformation, texture coordinate
    generation and transformation, and lighting.  Several extensions
    have added further per-vertex computations to OpenGL.  For example,
    extensions have defined new texture coordinate generation modes
    (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new
    vertex transformation modes (EXT_vertex_weighting), new lighting modes
    (OpenGL 1.2's separate specular and rescale normal functionality),
    several modes for fog distance generation (NV_fog_distance), and
    eye-distance point size attenuation (EXT_point_parameters).

    Each such extension adds a small set of relatively inflexible
    per-vertex computations.

    This inflexibility is in contrast to the typical flexibility provided
    by the underlying programmable floating point engines (whether
    micro-coded vertex engines, DSPs, or CPUs) that are traditionally used
    to implement OpenGL's per-vertex computations.  The purpose of this
    extension is to expose to the OpenGL application writer a significant
    degree of per-vertex programmability for computing vertex parameters.

    For the purposes of discussing this extension, a vertex program is
    a sequence of floating-point 4-component vector operations that
    determines how a set of program parameters (defined outside of
    OpenGL's begin/end pair) and an input set of per-vertex parameters
    are transformed to a set of per-vertex output parameters.

    The per-vertex computations for standard OpenGL given a particular
    set of lighting and texture coordinate generation modes (along with
    any state for extensions defining per-vertex computations) is, in
    essence, a vertex program.  However, the sequence of operations is
    defined implicitly by the current OpenGL state settings rather than
    defined explicitly as a sequence of instructions.

    This extension provides an explicit mechanism for defining vertex
    program instruction sequences for application-defined vertex programs.
    In order to define such vertex programs, this extension defines
    a vertex programming model including a floating-point 4-component
    vector instruction set and a relatively large set of floating-point
    4-component registers.

    The extension's vertex programming model is designed for efficient
    hardware implementation and to support a wide variety of vertex
    programs.  By design, the entire set of existing vertex programs
    defined by existing OpenGL per-vertex computation extensions can be
    implemented using the extension's vertex programming model.

Issues

    What should this extension be called?

      RESOLUTION:  NV_vertex_program.  DirectX 8 refers to its similar
      functionality as "vertex shaders".  This is a confusing term
      because shaders are usually assumed to operate at the fragment or
      pixel level, not the vertex level.

      Conceptually, what the extension defines is an application-defined
      program (admittedly limited by its sequential execution model) for
      processing vertices so the "vertex program" term is more accurate.

      Additionally, some of the API machinery in this extension for
      describing programs could be useful for extending other OpenGL
      operations with programs (though other types of programs would
      likely look very different from vertex programs).

    What terms are important to this specification?

      vertex program mode - when vertex program mode is enabled, vertices
      are transformed by an application-defined vertex program.

      conventional GL vertex transform mode - when vertex program mode
      is disabled (or the extension is not supported), vertices are
      transformed by GL's conventional texgen, lighting, and transform
      state.

      provoke - the verb that denotes the beginning of vertex
      transformation by either vertex program mode or conventional GL
      vertex transform mode.  Vertices are provoked when either glVertex
      or glVertexAttribNV(0, ...) is called.

      program target - a type or class of program.  This extension
      supports two program targets:  the vertex program and the vertex
      state program.  Future extensions could add other program targets.

      vertex program -  an application-defined vertex program used to
      transform vertices when vertex program mode is enabled.

      vertex state program - a program similar to a vertex program.
      Unlike a vertex program, a vertex state program runs outside of
      a glBegin/glEnd pair.  Vertex state programs do not transform
      a vertex.  They just update program parameters.

      vertex attribute - one of 16 4-component per-vertex parameters
      defined by this extension.  These attributes alias with the
      conventional per-vertex parameters.

      per-vertex parameter - a vertex attribute or a conventional
      per-vertex parameter such as set by glNormal3f or glColor3f.

      program parameter - one of 96 4-component registers available
      to vertex programs.  The state of these registers is shared
      among all vertex programs.

    What part of OpenGL do vertex programs specifically bypass?

      Vertex programs bypass the following OpenGL functionality:

        o  Normal transformation and normalization

        o  Color material

        o  Per-vertex lighting

        o  Texture coordinate generation

        o  The texture matrix

        o  The normalization of AUTO_NORMAL evaluated normals

        o  The modelview and projection matrix transforms

        o  The per-vertex processing in EXT_point_parameters

        o  The per-vertex processing in NV_fog_distance

        o  Raster position transformation

        o  Client-defined clip planes

      Operations not subsumed by vertex programs

        o  The view frustum clip

        o  Perspective divide (division by w)

        o  The viewport transformation

        o  The depth range transformation

        o  Clamping the primary and secondary color to [0,1]

        o  Primitive assembly and subsequent operations

        o  Evaluator (except the AUTO_NORMAL normalization)

    How specific should this specification be about precision?

      RESOLUTION:  Reasonable precision requirements are incorporated
      into the specification beyond the often vague requirements of the
      core OpenGL specification.

      This extension essentially defines an instruction set and its
      corresponding execution environment.  The instruction set specified
      may find applications beyond the traditional purposes of 3D vertex
      transformation, lighting, and texture coordinate generation that
      have fairly lax precision requirements.  To facilitate such
      possibly unexpected applications of this functionality, minimum
      precision requirements are specified.

      The minimum precision requirements in the specification are meant
      to serve as a baseline so that application developers can write
      vertex programs with minimal worries about precision issues.

    What about when the "execution environment" involves support for
    other extensions?

      This extension assumes support for functionality that includes
      a fog distance, secondary color, point parameters, and multiple
      texture coordinates.

      There is a trade-off between requiring support for these extensions
      to guarantee a particular extended execution environment and
      requiring lots of functionality that everyone might not support.

      Application developers will desire a high baseline of functionality
      so that OpenGL applications using vertex programs can work in
      the full context of OpenGL.  But if too much is required, the
      implementation burden mandated by the extension may limit the
      number of available implementations.

      Clearly we do not want to require support for 8 texture units
      even if the machinery is there for it.  Still multitexture is a
      common and important feature for using vertex programs effectively.
      Requiring at least two texture units seems reasonable.

    What do we say about the alpha component of the secondary color?

      RESOLUTION:  When vertex program mode is enabled, the alpha
      component of csec used for the color sum state is assumed always
      zero.  Another downstream extension may actually make the alpha
      component written into the COL1 (or BFC1) vertex result register
      available.

    Should client-defined clip planes operate when vertex program mode is
    enabled?

      RESOLUTION.  No.

      OpenGL's client-defined clip planes are specified in eye-space.
      Vertex programs generate homogeneous clip space positions.
      Unlike the conventional OpenGL vertex transformation mode, vertex
      program mode requires no semantic equivalent to eye-space.

      Applications that require client-defined clip planes can simulate
      OpenGL-style client-defined clip planes by generating texture
      coordinates and using alpha testing or other per-fragment tests
      such as NV_texture_shader's CULL_FRAGMENT_NV program to discard
      fragments.  In many ways, these schemes provide a more flexible
      mechanism for clipping than client-defined clip planes.

      Unfortunately, vertex programs used in conjunction with selection
      or feedback will not have a means to support client-defined clip
      planes because the per-fragment culling mechanisms described in the
      previous paragraph are not available in the selection or feedback
      render modes.  Oh well.

      Finally, as a practical concern, client-defined clip planes
      greatly complicate clipping for various hardware rasterization
      architectures.

    How are edge flags handled?

      RESOLUTION:  Passed through without the ability to be modified by
      a vertex program.  Applications are free to send edge flags when
      vertex program mode is enabled.

    Should vertex attributes alias with conventional per-vertex
    parameters?

      RESOLUTION.  YES.

      This aliasing should make it easy to use vertex programs with
      existing OpenGL code that transfers per-vertex parameters using
      conventional OpenGL per-vertex calls.

      It also minimizes the number of per-vertex parameters that the
      hardware must maintain.

      See Table X.2 for the aliasing of vertex attributes and conventional
      per-vertex parameters.

    How should vertex attribute arrays interact with conventional vertex
    arrays?

      RESOLUTION:  When vertex program mode is enabled, a particular
      vertex attribute array will be used if enabled, but if disabled,
      and the corresponding aliased conventional vertex array is enabled
      (assuming that there is a corresponding aliased conventional vertex
      array for the particular vertex array), the conventional vertex
      array will be used.

      This matches the way immediate mode per-vertex parameter aliasing
      works.

      This does slightly complicate vertex array validation in program
      mode, but programmers using vertex arrays can simply enable vertex
      program mode without reconfiguring their conventional vertex arrays
      and get what they expect.

      Note that this does create an asymmetry between immediate mode
      and vertex arrays depending on whether vertex program mode is
      enabled or not.  The immediate mode vertex attribute commands
      operate unchanged whether vertex program mode is enabled or not.
      However the vertex attribute vertex arrays are used only when
      vertex program mode is enabled.

      Supporting vertex attribute vertex arrays when vertex program mode
      is disabled would create a large implementation burden for existing
      OpenGL implementations that have heavily optimized conventional
      vertex arrays.  For example, the normal array can be assumed to
      always contain 3 and only 3 components in conventional OpenGL
      vertex transform mode, but may contain 1, 2, 3, or 4 components
      in vertex program mode.

      There is not any additional functionality gained by supporting
      vertex attribute arrays when vertex program mode is disabled, but
      there is lots of implementation overhead.  In any case, it does not
      seem something worth encouraging so it is simply not supported.
      So vertex attribute arrays are IGNORED when vertex program mode
      is not enabled.

      Ignoring VertexAttribute commands or treating VertexAttribute
      commands as an error when vertex program mode is enabled
      would likely add overhead for such a conditional check.  The
      implementation overhead for supporting VertexAttribute commands
      when vertex program mode is disabled is not that significant.
      Additionally, it is likely that setting persistent vertex attribute
      state while vertex program mode is disabled may be useful to
      applications.  So vertex attribute immediate mode commands are
      PERMITTED when vertex program mode is not enabled.

    Colors and normals specified as ints, uints, shorts, ushorts, bytes,
    and ubytes are converted to floating-point ranges when supplied to
    core OpenGL as described in Table 2.6.  Other per-vertex attributes
    such as texture coordinates and positions are not converted.
    How does this mix with vertex programs where all vertex attributes
    are supposedly treated identically?

      RESOLUTION:  Vertex attributes specified as bytes and ubytes are
      always converted as described in Table 2.6.  All other formats are
      not converted according to Table 2.6 but simply converted directly
      to floating-point.

      The ubyte type is converted because those types seem more useful
      for passing colors in the [0,1] range.

      If an application desires a conversion, the conversion can be
      incorporated into the vertex program itself.

      This also applies to vertex attribute arrays.  However, by enabling
      a color or normal vertex array and not enabling the corresponding
      aliased vertex attribute array, programmers can get the conventional
      conversions for color and normal arrays (but only for the vertex
      attribute arrays that alias to the conventional color and normal
      arrays and only with the sizes/types supported by these color and
      normal arrays).

    Should programs be C-style null-terminated strings?
      
      RESOLUTION:  No.  Programs should be specified as an array of
      GLubyte with an explicit length parameter.  OpenGL has no precedent
      for passing null-terminated strings into the API (though glGetString
      returns null-terminated strings).  Null-terminated strings are
      problematic for some languages.

    Should all existing OpenGL transform functionality and extensions
    be implementable as vertex programs?

      RESOLUTION:  Yes.  Vertex programs should be a complete superset
      of what you can do with OpenGL 1.2 and existing vertex transform
      extensions.

      To implement EXT_point_parameters, the
      GL_VERTEX_PROGRAM_POINT_SIZE_NV enable is introduced.

      To implement two-sided lighting, the GL_VERTEX_PROGRAM_TWO_SIDE_NV
      enable is introduced.

    How does glPointSize work with vertex programs?

      RESOLUTION:  If GL_VERTEX_PROGRAM_POINT_SIZE_NV is disabled, the size
      of points is determine by the glPointSize state.  If enabled,
      the point size is determined per-vertex by the clamped value of
      the vertex result PSIZ register.

    Can the currently bound vertex program object name be deleted or
    reloaded?

      RESOLUTION.  Yes.  When a vertex program object name is deleted
      or reloaded when it is the currently bound vertex program object,
      it is as if a rebind occurs after the deletion or reload.

      In the case of a reload, the new vertex program object will be
      used from then on.  In the case of a deletion, the current vertex
      program object will be treated as if it is nonexistent.

    Should program objects have a mechanism for managing program
    residency?

      RESOLUTION:  Yes.  Vertex program instruction memory is a limited
      hardware resource.  glBindProgramNV will be faster if binding to
      a resident program.  Applications are likely to want to quickly
      switch between a small collection of programs.

      glAreProgramsResidentNV allows the residency status of a
      group of programs to be queried.  This mimics
      glAreTexturesResident.

      Instead of adopting the glPrioritizeTextures mechanism, a new
      glRequestResidentProgramsNV command is specified instead.
      Assigning priorities to textures has always been a problematic
      endeavor and few OpenGL implementations implemented it effectively.
      For the priority mechanism to work well, it requires the client
      to routinely update the priorities of textures.

      The glRequestResidentProgramsNV indicates to the GL that a
      set of programs are intended for use together.  Because all
      the programs are requesting residency as a group, drivers
      should be able to attempt to load all the requested programs
      at once (and remove from residency programs not in the group if
      necessary).  Clients can use glAreProgramsResidentNV to query the
      relative success of the request.

      glRequestResidentProgramsNV should be superior to loading programs
      on-demand because fragmentation can be avoided.

    What happens when you execute a nonexistent or invalid program?

      RESOLUTION:  glBegin will fail with a GL_INVALID_OPERATION if the
      currently bound vertex program is nonexistent or invalid.  The same
      applies to glRasterPos and any command that implies a glBegin.

      Because the glVertex and glVertexAttribNV(0, ...) are ignored
      outside of a glBegin/glEnd pair (without generating an error) it
      is impossible to provoke a vertex program if the current vertex
      program is nonexistent or invalid.  Other per-vertex parameters
      (for examples those set by glColor, glNormal, and glVertexAttribNV
      when the attribute number is not zero) are recorded since they
      are legal outside of a glBegin/glEnd.

      For vertex state programs, the problem is simpler because
      glExecuteProgramNV can immediately fail with a GL_INVALID_OPERATION
      when the named vertex state program is nonexistent or invalid.

    What happens when a matrix has been tracked into a set of program
    parameters, but then glTrackMatrixNV(GL_VERTEX_PROGRAM_NV, addr,
    GL_NONE, GL_IDENTITY_NV) is performed?

      RESOLUTION:  The specified program parameters stop tracking a
      matrix, but they retain the values of the matrix they were last
      tracking.

    Can rows of tracked matrices be queried by querying the program
    parameters that track them?

      RESOLUTION:  Yes.

    Discussing matrices is confusing because of row-major versus
    column-major issues.  Can you give an example of how a matrix is
    tracked?

      // When loaded, the first row is "1, 2, 3, 4", because of column-major
      // (OpenGL spec) vs. row-major (C) differences.
      GLfloat matrix[16] = { 1, 5, 9,  13,
                             2, 6, 10, 14,
                             3, 7, 11, 15,
                             4, 8, 12, 16 };
      GLfloat row1[4], row2[4];

      glMatrixMode(GL_MATRIX0_NV);
      glLoadMatrixf(matrix);
      glTrackMatrixNV(GL_VERTEX_PROGRAM_NV, 4, GL_MATRIX0_NV, GL_IDENTITY_NV);
      glTrackMatrixNV(GL_VERTEX_PROGRAM_NV, 8, GL_MATRIX0_NV, GL_TRANSPOSE_NV);
      glGetProgramParameterfvNV(GL_VERTEX_PROGRAM_NV, 5,
        GL_PROGRAM_PARAMETER_NV, row1);
      /* row1 is now [ 5 6 7 8 ] */
      glGetProgramParameterfvNV(GL_VERTEX_PROGRAM_NV, 9,
        GL_PROGRAM_PARAMETER_NV, row2);
      /* row2 is now [ 2 6 10 14 ] because the tracked matrix is transposed */

    Should evaluators be extended to evaluate arbitrary vertex
    attributes?

      RESOLUTION:  Yes.  We'll support 32 new maps (16 for MAP1 and 16
      for MAP2) that take priority over the conventional maps that they
      might alias to (only when vertex program mode is enabled).

      These new maps always evaluate all four components.  The rationale
      for this is that if we supported 1, 2, 3, or 4 components, that
      would add 128 (16*4*2) enumerants which is too many.  In addition,
      if you wanted to evaluate two 2-component vertex attributes, you
      could instead generate one 4-component vertex attribute and use
      the vertex program with swizzling to treat this as two-components.

      Moreover, we are assuming 4-component vector instructions so less
      than 4-component evaluations might not be any more efficient
      than 4-component evaluations.  Implementations that use vector
      instructions such as Intel's SSE instructions will be easier to
      implement since they can focus on optimizing just the 4-component
      case.

    How should GL_AUTO_NORMAL work with vertex programs?

      RESOLUTION:  GL_AUTO_NORMAL should NOT guarantee that the generated
      analytical normal be normalized.  In vertex program mode, the
      current vertex program can easily normalize the normal if required.

      This can lead to greater efficiency if the vertex program transforms
      the normal to another coordinate system such as eye-space with a
      transform that preserves vector length.  Then a single normalize
      after transform is more efficient than normalizing after evaluation
      and also normalizing after transform.

      Conceptually, the normalize mandated for AUTO_NORMAL in section
      5.1 is just one of the many transformation operations subsumed by
      vertex programs.

    Should the new vertex program related enables push/pop with
    GL_ENABLE_BIT?

      RESOLUTION:  Yes.  Pushing and popping enable bits is easy.
      This includes the 32 new evaluator map enable bits.  These evaluator
      enable bits are also pushed and popped using GL_EVAL_BIT.

    Should all the vertex attribute state push/pop with GL_CURRENT_BIT?

      RESOLUTION: Yes.  The state is aliased with the conventional
      per-vertex parameter state so it really should push/pop.

    Should all the vertex attrib vertex array state push/pop with
    GL_CLIENT_VERTEX_ARRAY_BIT?

      RESOLUTION: Yes.

    Should all the other vertex program-related state push/pop somehow?

      RESOLUTION:  No.

      The other vertex program doesn't fit well with the existing bits.
      To be clear, GL_ALL_ATTRIB_BITS does not push/pop vertex program
      state other than enables.

    Should we generate a GL_INVALID_OPERATION operation if updating
    a vertex attribute greater than 15?

      RESOLUTION:  Yes.

      The other option would be to mask or modulo the vertex attribute
      index with 16.  This is cheap, but it would make it difficult to
      increase the number of vertex attributes in the future.

      If we check for the error, it should be a well predicted branch
      for immediate mode calls.  For vertex arrays, the check is only
      required at vertex array specification time.

      Hopefully this will encourage people to use vertex arrays over
      immediate mode.

    Should writes to program parameter registers during a vertex program
    be supported?

      RESOLUTION.  No.

      Writes to program parameter registers from within a vertex program
      would require the execution of vertex programs to be serialized
      with respect to each other.  This would create an unwarranted
      implementation penalty for parallel vertex program execution
      implementations.

      However vertex state programs may write to program parameter
      registers (that is the whole point of vertex state programs).

    Should we support variously sized immediate mode byte and ubyte
    commands?  How about for vertex arrays?

      RESOLUTION.  Only support the 4ub mode.

      There are simply too many glVertexAttribNV routines.  Passing less
      than 4 bytes at a time is inefficient.  We expect the main use
      for bytes to be for colors where these will be unsigned bytes.
      So let's just support 4ub mode for bytes.  This applies to
      vertex arrays too.

    Should we support integer, unsigned integer, and unsigned short
    formats for vertex attributes?

      RESOLUTION:  No.  It's just too many immediate mode entry points,
      most of which are not that useful.  Signed shorts are supported
      however.  We expect signed shorts to be useful for passing compact
      texture coordinates.

    Should we support doubles for vertex attributes?

      RESOLUTION:  Yes.  Some implementation of the extension might
      support double precision.  Lots of math routines output double
      precision.

    Should there be a way to determine where in a loaded program
    string the first parse error occurs?

      RESOLUTION:  Yes.  You can query PROGRAM_ERROR_POSITION_NV.

    Should program objects be shared among rendering contexts in the
    same manner as display lists and texture objects?

      RESOLUTION:  Yes.

    How should this extension interact with color material?

      RESOLUTION:  It should not.  Color material is a conventional
      OpenGL vertex transform mode.  It does not have a place for vertex
      programs.  If you want to emulate color material with vertex
      programs, you would simply write a program where the material
      parameters feed from the color vertex attribute.

    Should there be a glMatrixMode or glActiveTextureARB style selector
    for vertex attributes?

      RESOLUTION:  No.  While this would let us reduce a lot of
      enumerants down, it would make programming a hassle in lots
      of cases.  Consider having to change the vertex attribute
      mode to enable a set of vertex arrays.

    How should gets for vertex attribute array pointers?

      RESOLUTION:  Add new get commands.  Using the existing calls
      would require adding 4 sets of 16 enumerants stride, type, size,
      and pointer.  That's too many gets.

      Instead add glGetVertexAttribNV and glGetVertexAttribPointervNV.
      glGetVertexAttribNV is also useful for querying the current vertex
      attribute.

      glGet and glGetPointerv will not return vertex attribute array
      pointers.

    Why is the address register numbered and why is it a vector
    register?

      In the future, A0.y and A0.z and A0.w may exist.  For this
      extension, only A0.x is useful.  Also in the future, there may be
      more than one address register.

      There's a nice consistency in thinking about all the registers
      as 4-component vectors even if the address register has only one
      usable component.

    Should vertex programs and vertex state programs be required to
    have a header token and an end token?

      RESOLUTION:  Yes.

      The "!!VP1.0" and "!!VSP1.0" tokens start vertex programs and
      vertex state programs respectively.  Both types of programs must
      end with the "END" token.

      The initial header token reminds the programmer what type of program
      they are writing.  If vertex programs and vertex state programs are
      ever read from disk files, the header token can serve as a magic
      number for identifying vertex programs and vertex state programs.

      The target type for vertex programs and vertex state programs can be
      distinguished based on their respective grammars independent of the
      initial header tokens, but the initial header tokens will make it
      easier for programmers to distinguish the two program target types.

      We expect programs to often be generated by concatenation of
      program fragments.  The "END" token will hopefully reduce bugs
      due to specifying an incorrectly concatenated program.

      It's tempting to make these additional header and end tokens
      optional, but if there is a sanity check value in header and end
      tokens, that value is undermined if the tokens are optional.

    What should be said about rendering invariances?

      RESOLUTION:  See the Appendix A additions below.

      The justification for the two rules cited is to support multi-pass
      rendering when using vertex programs.  Different rendering passes
      will likely use different programs so there must be some means of
      guaranteeing that two different programs can generate particular
      identical vertex results between different passes.

      In practice, this does limit the type of vertex program
      implementations that are possible.

      For example, consider a limited hardware implementation of vertex
      programs that uses a different floating-point implementation
      than the CPU's floating-point implementation.  If the limited
      hardware implementation can only run small vertex programs (say
      the hardware provides on 4 temporary registers instead of the
      required 12), the implementation is incorrect and non-conformant
      if programs that only require 4 temporary registers use the vertex
      program hardware, but programs that require more than 4 temporary
      registers are implemented by the CPU.

      This is a very important practical requirement.  Consider a
      multi-pass rendering algorithm where one pass uses a vertex program
      that uses only 4 temporary registers, but a different pass uses a
      vertex program that uses 5 temporary registers.  If two programs
      have instruction sequences that given the same input state compute
      identical resulting vertex positions, the multi-pass algorithm
      should generate identically positioned primitives for each pass.
      But given the non-conformant vertex program implementation described
      above, this could not be guaranteed.

      This does not mean that schemes for splitting vertex program
      implementations between dedicated hardware and CPUs are impossible.
      If the CPU and dedicated vertex program hardware used IDENTICAL
      floating-point implementations and therefore generated exactly
      identical results, the above described could work.

      While these invariance rules are vital for vertex programs operating
      correctly for multi-pass algorithms, there is no requirement that
      conventional OpenGL vertex transform mode will be invariant with
      vertex program mode.  A multi-pass algorithm should not assume
      that one pass using vertex program mode and another pass using
      conventional GL vertex transform mode will generate identically
      positioned primitives.

      Consider that while the conventional OpenGL vertex program mode
      is repeatable with itself, the exact procedure used to transform
      vertices is not specified nor is the procedure's precision
      specified.  The GL specification indicates that vertex coordinates
      are transformed by the modelview matrix and then transformed by the
      projection matrix.  Some implementations may perform this sequence
      of transformations exactly, but other implementations may transform
      vertex coordinates by the composite of the modelview and projection
      matrices (one matrix transform instead of two matrix transforms
      in sequence).  Given this implementation flexibility, there is no
      way for a vertex program author to exactly duplicate the precise
      computations used by the conventional OpenGL vertex transform mode.

      The guidance to OpenGL application programs is clear.  If you are
      going to implement multi-pass rendering algorithms that require
      certain invariances between the multiple passes, choose either
      vertex program mode or the conventional OpenGL vertex transform
      mode for your rendering passes, but do not mix the two modes.

    What range of relative addressing offsets should be allowed?

      RESOLUTION:  -64 to 63.

      Negative offsets are useful for accessing a table centered at zero
      without extra bias instructions.  Having the offsets support much
      larger magnitudes just seems to increase the required instruction
      widths.  The -64 to 63 range seems like a reasonable compromise.

    When EXT_secondary_color is supported, how does the GL_COLOR_SUM_EXT
    enable affect vertex program mode?

      RESOLUTION:  The GL_COLOR_SUM_EXT enable has no affect when vertex
      program mode is enabled.

      When vertex program mode is enabled, the color sum operation is
      always in operation.  A program can "avoid" the color sum operation
      by not writing the COL1 (or BFC1 when GL_VERTEX_PROGRAM_TWO_SIDE_NV)
      vertex result registers because the default values of all vertex
      result registers is (0,0,0,1).  For the color sum operation,
      the alpha value is always assumed zero.  So by not writing the
      secondary color vertex result registers, the program assures that
      zero is added as part of the color sum operation.

      If there is a cost to the color sum operation, OpenGL
      implementations may be smart enough to determine at program bind
      time whether a secondary color vertex result is generated and
      implicitly disable the color sum operation.

    Why must RCP of 1.0 always be 1.0?

      This is important for 3D graphics so that non-projective textures
      and orthogonal projections work as expected.  Basically when q or
      w is 1.0, things should work as expected.

      Stronger requirements such as "RCP of -1.0 must always be -1.0"
      are encouraged, but there is no compelling reason to state such
      requirements explicitly as is the case for "RCP of 1.0 must always
      be 1.0".

    What happens when the source scalar value for the ARL instruction
    is an extremely positive or extremely negative floating-point value?
    Is there a problem mapping the value to a constrained integer range?

      RESOLUTION:  It is not a problem.  Relative addressing can by offset
      by a limited range of offsets (-64 to 63).  Relative addressing
      that falls outside of the 0 to 95 range of program parameter
      registers is automatically mapped to (0,0,0,0).

      Clamping the source scalar value for ARL to the range -64 to 160
      inclusive is sufficient to ensure that relative addressing is out
      of range.

    How do you perform a 3-component normalize in three instructions?

      #
      # R1 = (nx,ny,nz)
      #
      # R0.xyz = normalize(R1)
      # R0.w   = 1/sqrt(nx*nx + ny*ny + nz*nz)
      #
      DP3 R0.w, R1, R1;
      RSQ R0.w, R0.w;
      MUL R0.xyz, R1, R0.w;

    How do you perform a 3-component cross product in two instructions?

      #
      # Cross product |  i     j     k   | into R2.
      #               | R0.x  R0.y  R0.z |
      #               | R1.x  R1.y  R1.z |
      #
      MUL R2, R0.zxyw, R1.yzxw;
      MAD R2, R0.yzxw, R1.zxyw, -R2;

    How do you perform a 4-component vector absolute value in one
    instruction?

      #
      # Absolute value is the maximum of the negative and positive
      # components of a vector.
      #
      # R1 = abs(R0)
      #
      MAX R1, R0, -R0;

    How do you compute the determinant of a 3x3 matrix in three
    instructions?

      #
      # Determinant of | R0.x  R0.y  R0.z | into R3
      #                | R1.x  R1.y  R1.z |
      #                | R2.x  R2.y  R2.z |
      #
      MUL R3, R1.zxyw, R2.yzxw;
      MAD R3, R1.yzxw, R2.zxyw, -R3;
      DP3 R3, R0, R3;

    How do you transform a vertex position by a 4x4 matrix and then
    perform a homogeneous divide?

      #
      # c[20] = modelview row 0
      # c[21] = modelview row 1
      # c[22] = modelview row 2
      # c[23] = modelview row 3
      #
      # result = R5
      #
      DP4 R5.w, v[OPOS], c[23];
      DP4 R5.x, v[OPOS], c[20];
      DP4 R5.y, v[OPOS], c[21];
      DP4 R5.z, v[OPOS], c[22];
      RCP R11, R5.w;
      MUL R5,R5,R11;

    How do you perform a vector weighting of two vectors using a single
    weight?

      #
      # R2        = vector 0
      # R3        = vector 1
      # v[WGHT].x = scalar weight to blend vectors 0 and 1
      # result    = R2 * v[WGHT].x + R3 * (1-v[WGHT])
      #
      # this is because A*B + (1-A)*C = A*(B-C) + C
      #
      ADD R4, R2, -R3;
      MAD R4, v[WGHT].x, R4, R3;

    How do you reduce a value to some fundamental period such as 2*PI?

      #
      # c[36] = (1.0/(2*PI), 2*PI, 0.0, 0.0)
      #
      # R1.x = input value
      # R2   = result
      #
      MUL R0, R1, c[36].x;
      EXP R4, R0.x;
      MUL R2, R4.y, c[36].y;

    How do you implement a simple specular and diffuse lighting
    computation with an eye-space normal?

      !!VP1.0
      #
      # c[0-3]  = modelview projection (composite) matrix
      # c[4-7]  = modelview inverse transpose
      # c[32]   = normalized eye-space light direction (infinite light)
      # c[33]   = normalized constant eye-space half-angle vector (infinite viewer)
      # c[35].x = pre-multiplied monochromatic diffuse light color & diffuse material
      # c[35].y = pre-multiplied monochromatic ambient light color & diffuse material
      # c[36]   = specular color
      # c[38].x = specular power
      #
      # outputs homogenous position and color
      #
      DP4   o[HPOS].x, c[0], v[OPOS];
      DP4   o[HPOS].y, c[1], v[OPOS];
      DP4   o[HPOS].z, c[2], v[OPOS];
      DP4   o[HPOS].w, c[3], v[OPOS];
      DP3   R0.x, c[4], v[NRML];
      DP3   R0.y, c[5], v[NRML]; 
      DP3   R0.z, c[6], v[NRML];           # R0 = n' = transformed normal
      DP3   R1.x, c[32], R0;               # R1.x = Lpos DOT n'
      DP3   R1.y, c[33], R0;               # R1.y = hHat DOT n'
      MOV   R1.w, c[38].x;                 # R1.w = specular power
      LIT   R2, R1;                        # Compute lighting values
      MAD   R3, c[35].x, R2.y, c[35].y;    # diffuse + emissive
      MAD   o[COL0].xyz, c[36], R2.z, R3;  # + specular
      END

    Can you perturb transformed vertex positions with a vertex program?

      Yes.  Here is an example that performs an object-space diffuse
      lighting computations and perturbs the vertex position based on
      this lighting result.  Do not take this example too seriously.

        !!VP1.0
        #
        # c[0-3]  = modelview projection (composite) matrix
        # c[32]   = normalized light direction in object-space
        # c[35]   = yellow diffuse material, (1.0, 1.0, 0.0, 1.0)
        # c[64].x = 0.0
        # c[64].z = 0.125, a scaling factor
        #
        # outputs diffuse illumination for color and perturbed position
        #
        DP3   R0, c[32], v[NRML];     # light direction DOT normal
        MUL   o[COL0].xyz, R0, c[35]; 
        MAX   R0, c[64].x, R0; 
        MUL   R0, R0, v[NRML]; 
        MUL   R0, R0, c[64].z;  
        ADD   R1, v[OPOS], -R0;       # perturb object space position
        DP4   o[HPOS].x, c[0], R1; 
        DP4   o[HPOS].y, c[1], R1; 
        DP4   o[HPOS].z, c[2], R1; 
        DP4   o[HPOS].w, c[3], R1; 
        END

    What if more exponential precision is needed than provided by the
    builtin EXP instruction?

        A sequence of vertex program instructions can be used refine
        the initial EXP approximation.  The pseudo-macro below shows an
        example of how to refine the EXP approximation.

        The psuedo-macro requires 10 instructions, 1 temp register,
        and 2 constant locations.

        CE0 = { 9.61597636e-03, -1.32823968e-03, 1.47491097e-04, -1.08635004e-05 };
        CE1 = { 1.00000000e+00, -6.93147182e-01, 2.40226462e-01, -5.55036440e-02 };

        /* Rt != Ro && Rt != Ri */
        EXP_MACRO(Ro:vector, Ri:scalar, Rt:vector) {
           EXP Rt, Ri.x;                   /* Use appropriate component of Ri */
           MAD Rt.w, c[CE0].w, Rt.y, c[CE0].z;
           MAD Rt.w, Rt.w,Rt.y, c[CE0].y;
           MAD Rt.w, Rt.w,Rt.y, c[CE0].x;
           MAD Rt.w, Rt.w,Rt.y, c[CE1].w;
           MAD Rt.w, Rt.w,Rt.y, c[CE1].z;
           MAD Rt.w, Rt.w,Rt.y, c[CE1].y;
           MAD Rt.w, Rt.w,Rt.y, c[CE1].x;
           RCP Rt.w, Rt.w;
           MUL Ro, Rt.w, Rt.x;             /* Apply user write mask to Ro */
        }

        Simulation gives |max abs error| < 3.77e-07 over the range (0.0
        <= x < 1.0).  Actual vertex program precision may be slightly
        less accurate than this.

    What if more exponential precision is needed than provided by the
    builtin LOG instruction?

        The pseudo-macro requires 10 instructions, 1 temp register,
        and 3 constant locations.
   
        CL0 = { 2.41873696e-01, -1.37531206e-01, 5.20646796e-02, -9.31049418e-03 };
        CL1 = { 1.44268966e+00, -7.21165776e-01, 4.78684813e-01, -3.47305417e-01 };
        CL2 = { 1.0, NA, NA, NA };

        /* Rt != Ro && Rt != Ri */
        LOG_MACRO(Ro:vector, Ri:scalar, Rt:vector) {
           LOG Rt, Ri.x;                   /* Use appropriate component of Ri */
           ADD Rt.y, Rt.y, -c[CL2].x;
           MAD Rt.w, c[CL0].w, Rt.y, c[CL0].z;
           MAD Rt.w, Rt.w, Rt.y,c[CL0].y;
           MAD Rt.w, Rt.w, Rt.y,c[CL0].x;
           MAD Rt.w, Rt.w, Rt.y,c[CL1].w;
           MAD Rt.w, Rt.w, Rt.y,c[CL1].z;
           MAD Rt.w, Rt.w, Rt.y,c[CL1].y;
           MAD Rt.w, Rt.w, Rt.y,c[CL1].x;
           MAD Ro, Rt.w, Rt.y, Rt.x;       /* Apply user write mask to Ro */
        }
  
        Simulation gives |max abs error| < 1.79e-07 over the range (1.0
        <= x < 2.0).  Actual vertex program precision may be slightly
        less accurate than this.

New Procedures and Functions

    void BindProgramNV(enum target, uint id);

    void DeleteProgramsNV(sizei n, const uint *ids);

    void ExecuteProgramNV(enum target, uint id, const float *params);

    void GenProgramsNV(sizei n, uint *ids);

    boolean AreProgramsResidentNV(sizei n, const uint *ids,
                                  boolean *residences);

    void RequestResidentProgramsNV(sizei n, uint *ids);

    void GetProgramParameterfvNV(enum target, uint index,
                                 enum pname, float *params);
    void GetProgramParameterdvNV(enum target, uint index,
                                 enum pname, double *params);

    void GetProgramivNV(uint id, enum pname, int *params);

    void GetProgramStringNV(uint id, enum pname, ubyte *program);

    void GetTrackMatrixivNV(enum target, uint address,
                            enum pname, int *params);

    void GetVertexAttribdvNV(uint index, enum pname, double *params);
    void GetVertexAttribfvNV(uint index, enum pname, float *params);
    void GetVertexAttribivNV(uint index, enum pname, int *params);

    void GetVertexAttribPointervNV(uint index, enum pname, void **pointer);

    boolean IsProgramNV(uint id);

    void LoadProgramNV(enum target, uint id, sizei len,
                       const ubyte *program);

    void ProgramParameter4fNV(enum target, uint index,
                              float x, float y, float z, float w)
    void ProgramParameter4dNV(enum target, uint index,
                              double x, double y, double z, double w)

    void ProgramParameter4dvNV(enum target, uint index,
                               const double *params);
    void ProgramParameter4fvNV(enum target, uint index,
                               const float *params);

    void ProgramParameters4dvNV(enum target, uint index,
                                sizei num, const double *params);
    void ProgramParameters4fvNV(enum target, uint index,
                                sizei num, const float *params);

    void TrackMatrixNV(enum target, uint address,
                       enum matrix, enum transform);

    void VertexAttribPointerNV(uint index, int size, enum type, sizei stride,
                               const void *pointer);

    void VertexAttrib1sNV(uint index, short x);
    void VertexAttrib1fNV(uint index, float x);
    void VertexAttrib1dNV(uint index, double x);
    void VertexAttrib2sNV(uint index, short x, short y);
    void VertexAttrib2fNV(uint index, float x, float y);
    void VertexAttrib2dNV(uint index, double x, double y);
    void VertexAttrib3sNV(uint index, short x, short y, short z);
    void VertexAttrib3fNV(uint index, float x, float y, float z);
    void VertexAttrib3dNV(uint index, double x, double y, double z);
    void VertexAttrib4sNV(uint index, short x, short y, short z, short w);
    void VertexAttrib4fNV(uint index, float x, float y, float z, float w);
    void VertexAttrib4dNV(uint index, double x, double y, double z, double w);
    void VertexAttrib4ubNV(uint index, ubyte x, ubyte y, ubyte z, ubyte w);

    void VertexAttrib1svNV(uint index, const short *v);
    void VertexAttrib1fvNV(uint index, const float *v);
    void VertexAttrib1dvNV(uint index, const double *v);
    void VertexAttrib2svNV(uint index, const short *v);
    void VertexAttrib2fvNV(uint index, const float *v);
    void VertexAttrib2dvNV(uint index, const double *v);
    void VertexAttrib3svNV(uint index, const short *v);
    void VertexAttrib3fvNV(uint index, const float *v);
    void VertexAttrib3dvNV(uint index, const double *v);
    void VertexAttrib4svNV(uint index, const short *v);
    void VertexAttrib4fvNV(uint index, const float *v);
    void VertexAttrib4dvNV(uint index, const double *v);
    void VertexAttrib4ubvNV(uint index, const ubyte *v);

    void VertexAttribs1svNV(uint index, sizei n, const short *v);
    void VertexAttribs1fvNV(uint index, sizei n, const float *v);
    void VertexAttribs1dvNV(uint index, sizei n, const double *v);
    void VertexAttribs2svNV(uint index, sizei n, const short *v);
    void VertexAttribs2fvNV(uint index, sizei n, const float *v);
    void VertexAttribs2dvNV(uint index, sizei n, const double *v);
    void VertexAttribs3svNV(uint index, sizei n, const short *v);
    void VertexAttribs3fvNV(uint index, sizei n, const float *v);
    void VertexAttribs3dvNV(uint index, sizei n, const double *v);
    void VertexAttribs4svNV(uint index, sizei n, const short *v);
    void VertexAttribs4fvNV(uint index, sizei n, const float *v);
    void VertexAttribs4dvNV(uint index, sizei n, const double *v);
    void VertexAttribs4ubvNV(uint index, sizei n, const ubyte *v);

New Tokens


        VERTEX_PROGRAM_NV                              0x8620 


        VERTEX_PROGRAM_POINT_SIZE_NV                   0x8642
        VERTEX_PROGRAM_TWO_SIDE_NV                     0x8643

    
        VERTEX_STATE_PROGRAM_NV                        0x8621 


        ATTRIB_ARRAY_SIZE_NV                           0x8623
        ATTRIB_ARRAY_STRIDE_NV                         0x8624
        ATTRIB_ARRAY_TYPE_NV                           0x8625
        CURRENT_ATTRIB_NV                              0x8626


        PROGRAM_PARAMETER_NV                           0x8644


        ATTRIB_ARRAY_POINTER_NV                        0x8645


        PROGRAM_TARGET_NV                              0x8646
        PROGRAM_LENGTH_NV                              0x8627
        PROGRAM_RESIDENT_NV                            0x8647


        PROGRAM_STRING_NV                              0x8628


        TRACK_MATRIX_NV                                0x8648
        TRACK_MATRIX_TRANSFORM_NV                      0x8649


        MAX_TRACK_MATRIX_STACK_DEPTH_NV                0x862E
        MAX_TRACK_MATRICES_NV                          0x862F
        CURRENT_MATRIX_STACK_DEPTH_NV                  0x8640
        CURRENT_MATRIX_NV                              0x8641
        VERTEX_PROGRAM_BINDING_NV                      0x864A
        PROGRAM_ERROR_POSITION_NV                      0x864B

    
        MODELVIEW_PROJECTION_NV                        0x8629


    
        MATRIX0_NV                                     0x8630
        MATRIX1_NV                                     0x8631
        MATRIX2_NV                                     0x8632
        MATRIX3_NV                                     0x8633
        MATRIX4_NV                                     0x8634
        MATRIX5_NV                                     0x8635
        MATRIX6_NV                                     0x8636
        MATRIX7_NV                                     0x8637



        IDENTITY_NV                                    0x862A
        INVERSE_NV                                     0x862B
        TRANSPOSE_NV                                   0x862C
        INVERSE_TRANSPOSE_NV                           0x862D 


        VERTEX_ATTRIB_ARRAY0_NV                        0x8650
        VERTEX_ATTRIB_ARRAY1_NV                        0x8651
        VERTEX_ATTRIB_ARRAY2_NV                        0x8652
        VERTEX_ATTRIB_ARRAY3_NV                        0x8653
        VERTEX_ATTRIB_ARRAY4_NV                        0x8654
        VERTEX_ATTRIB_ARRAY5_NV                        0x8655
        VERTEX_ATTRIB_ARRAY6_NV                        0x8656
        VERTEX_ATTRIB_ARRAY7_NV                        0x8657
        VERTEX_ATTRIB_ARRAY8_NV                        0x8658
        VERTEX_ATTRIB_ARRAY9_NV                        0x8659
        VERTEX_ATTRIB_ARRAY10_NV                       0x865A
        VERTEX_ATTRIB_ARRAY11_NV                       0x865B
        VERTEX_ATTRIB_ARRAY12_NV                       0x865C
        VERTEX_ATTRIB_ARRAY13_NV                       0x865D
        VERTEX_ATTRIB_ARRAY14_NV                       0x865E
        VERTEX_ATTRIB_ARRAY15_NV                       0x865F


        MAP1_VERTEX_ATTRIB0_4_NV                       0x8660
        MAP1_VERTEX_ATTRIB1_4_NV                       0x8661
        MAP1_VERTEX_ATTRIB2_4_NV                       0x8662
        MAP1_VERTEX_ATTRIB3_4_NV                       0x8663
        MAP1_VERTEX_ATTRIB4_4_NV                       0x8664
        MAP1_VERTEX_ATTRIB5_4_NV                       0x8665
        MAP1_VERTEX_ATTRIB6_4_NV                       0x8666
        MAP1_VERTEX_ATTRIB7_4_NV                       0x8667
        MAP1_VERTEX_ATTRIB8_4_NV                       0x8668
        MAP1_VERTEX_ATTRIB9_4_NV                       0x8669
        MAP1_VERTEX_ATTRIB10_4_NV                      0x866A
        MAP1_VERTEX_ATTRIB11_4_NV                      0x866B
        MAP1_VERTEX_ATTRIB12_4_NV                      0x866C
        MAP1_VERTEX_ATTRIB13_4_NV                      0x866D
        MAP1_VERTEX_ATTRIB14_4_NV                      0x866E
        MAP1_VERTEX_ATTRIB15_4_NV                      0x866F


        MAP2_VERTEX_ATTRIB0_4_NV                       0x8670
        MAP2_VERTEX_ATTRIB1_4_NV                       0x8671
        MAP2_VERTEX_ATTRIB2_4_NV                       0x8672
        MAP2_VERTEX_ATTRIB3_4_NV                       0x8673
        MAP2_VERTEX_ATTRIB4_4_NV                       0x8674
        MAP2_VERTEX_ATTRIB5_4_NV                       0x8675
        MAP2_VERTEX_ATTRIB6_4_NV                       0x8676
        MAP2_VERTEX_ATTRIB7_4_NV                       0x8677
        MAP2_VERTEX_ATTRIB8_4_NV                       0x8678
        MAP2_VERTEX_ATTRIB9_4_NV                       0x8679
        MAP2_VERTEX_ATTRIB10_4_NV                      0x867A
        MAP2_VERTEX_ATTRIB11_4_NV                      0x867B
        MAP2_VERTEX_ATTRIB12_4_NV                      0x867C
        MAP2_VERTEX_ATTRIB13_4_NV                      0x867D
        MAP2_VERTEX_ATTRIB14_4_NV                      0x867E
        MAP2_VERTEX_ATTRIB15_4_NV                      0x867F

