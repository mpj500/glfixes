Name

    NV_packed_depth_stencil

Name Strings

    GL_NV_packed_depth_stencil

Contact

    Matt Craighead, NVIDIA Corporation (mcraighead 'at' nvidia.com)

Notice

    Copyright NVIDIA Corporation, 2000, 2001.

IP Status

    NVIDIA Proprietary.

Status

    Shipping (version 1.1)

Version
    
    NVIDIA Date: August 22, 2001 (version 1.1)

Number

    226

Dependencies

    Written based on the wording of the OpenGL 1.2.1 specification.

    SGIX_depth_texture affects the definition of this extension.

Overview

    Many OpenGL implementations have chosen to interleave the depth and
    stencil buffers into one buffer, often with 24 bits of depth
    precision and 8 bits of stencil data.  32 bits is more than is needed
    for the depth buffer much of the time; a 24-bit depth buffer, on the
    other hand, requires that reads and writes of depth data be unaligned
    with respect to power-of-two boundaries.  On the other hand, 8 bits
    of stencil data is more than sufficient for most applications, so it
    is only natural to pack the two buffers into a single buffer with
    both depth and stencil data.  OpenGL never provides direct access to
    the buffers, so the OpenGL implementation can provide an interface to
    applications where it appears the one merged buffer is composed of
    two logical buffers.

    One disadvantage of this scheme is that OpenGL lacks any means by
    which this packed data can be handled efficiently.  For example, when
    an application reads from the 24-bit depth buffer, using the type
    GL_UNSIGNED_SHORT will lose 8 bits of data, while GL_UNSIGNED_INT has
    8 too many.  Both require expensive format conversion operations.  A
    24-bit format would be no more suitable, because it would also suffer
    from the unaligned memory accesses that made the standalone 24-bit
    depth buffer an unattractive proposition in the first place.

    Many applications, such as parallel rendering applications, may also
    wish to draw to or read back from both the depth and stencil buffers
    at the same time.  Currently this requires two separate operations,
    reducing performance.  Since the buffers are interleaved, drawing to
    or reading from both should be no more expensive than using just one;
    in some cases, it may even be cheaper.

    This extension provides a new data format, GL_DEPTH_STENCIL_NV, that
    can be used with the glDrawPixels, glReadPixels, and glCopyPixels
    commands, as well as a packed data type, GL_UNSIGNED_INT_24_8_NV,
    that is meant to be used with GL_DEPTH_STENCIL_NV.  No other formats
    are supported with GL_DEPTH_STENCIL_NV.  If SGIX_depth_texture is
    supported, GL_DEPTH_STENCIL_NV/GL_UNSIGNED_INT_24_8_NV data can also
    be used for textures; this provides a more efficient way to supply
    data for a 24-bit depth texture.

    GL_DEPTH_STENCIL_NV data, when passed through the pixel path,
    undergoes both depth and stencil operations.  The depth data is
    scaled and biased by the current GL_DEPTH_SCALE and GL_DEPTH_BIAS,
    while the stencil data is shifted and offset by the current
    GL_INDEX_SHIFT and GL_INDEX_OFFSET.  The stencil data is also put
    through the stencil-to-stencil pixel map.

    glDrawPixels of GL_DEPTH_STENCIL_NV data operates similarly to that
    of GL_STENCIL_INDEX data, bypassing the OpenGL fragment pipeline
    entirely, unlike the treatment of GL_DEPTH_COMPONENT data.  The
    stencil and depth masks are applied, as are the pixel ownership and
    scissor tests, but all other operations are skipped.

    glReadPixels of GL_DEPTH_STENCIL_NV data reads back a rectangle from
    both the depth and stencil buffers.

    glCopyPixels of GL_DEPTH_STENCIL_NV data copies a rectangle from
    both the depth and stencil buffers.  Like glDrawPixels, it applies
    both the stencil and depth masks but skips the remainder of the
    OpenGL fragment pipeline.

    glTex[Sub]Image[1,2,3]D of GL_DEPTH_STENCIL_NV data loads depth data
    into a depth texture.  glGetTexImage of GL_DEPTH_STENCIL_NV data can
    be used to retrieve depth data from a depth texture.

Issues

    *   Depth data has a format of GL_DEPTH_COMPONENT, and stencil data
        has a format of GL_STENCIL_INDEX.  So shouldn't the enumerant be
        called GL_DEPTH_COMPONENT_STENCIL_INDEX_NV?

        RESOLVED: No, this is fairly clumsy.

    *   Should we support CopyPixels?

        RESOLVED: Yes.  Right now copying stencil data means masking off
        just the stencil bits, while copying depth data has strange
        unintended consequences (fragment operations) and is difficult to
        implement.  It is easy and useful to add CopyPixels support.

    *   Should we support textures?

        RESOLVED: Yes.  24-bit depth textures have no good format without
        this extension.

    *   Should the depth/stencil format support other standard types,
        like GL_FLOAT or GL_UNSIGNED_INT?

        RESOLVED: No, this extension is designed to be minimalist.
        Supporting more types gains little because the new types will
        just require data format conversions.  Our goal is to match the
        native format of the buffer, not add broad new classes of
        functionality.

    *   Should the 24/8 format be supported for other formats, such as
        LUMINANCE_ALPHA?  Should we support an 8/24 reversed format as
        well?

        RESOLVED: No and no, this adds implementation burden and gains us
        little, if anything.

    *   Does anything need to be written in the spec on the topic of
        using GL_DEPTH_STENCIL_NV formats for glTexImage* or
        glGetTexImage?

        RESOLVED: No.  Since the SGIX_depth_texture extension spec was
        never actually written (the additions to Section 3 are "XXX -
        lots" and a few brief notes on how it's intended to work), it's
        impossible to write what would essentially be amendments to that
        spec.

        However, it is worthwhile to mention here the intended behavior.
        When downloading into a depth component texture, the stencil
        indices are ignored, and when retrieving a depth component
        texture, the stencil indices obtained from the texture are
        undefined.

    *   Should anything be said about performance?

        RESOLVED: No, not in the spec.  However, common sense should
        apply.  Apps should probably check that GL_DEPTH_BITS is 24 and
        that GL_STENCIL_BITS is 8 before using either the new DrawPixels
        or ReadPixels formats.  CopyPixels is probably safe regardless of
        the size of either buffer.  The 24/8 format should probably only
        be used with 24-bit depth textures.

New Procedures and Functions

    None.

New Tokens


        DEPTH_STENCIL_NV                               0x84F9


        UNSIGNED_INT_24_8_NV                           0x84FA

