Name

    NV_vertex_program3

Name Strings

    GL_NV_vertex_program3

Contact

    Pat Brown, NVIDIA Corporation (pbrown 'at' nvidia.com)

Status

    Shipping.

Version

    Last Modified Data:         10/12/2009
    NVIDIA Revision:            7

Number

    306

Dependencies

    ARB_vertex_program is required.
    NV_vertex_program2_option is required.
    This extension interacts with ARB_fragment_program_shadow.

Overview

    This extension, like the NV_vertex_program2_option extension,
    provides additional vertex program functionality to extend the
    standard ARB_vertex_program language and execution environment.
    ARB programs wishing to use this added functionality need only add:

        OPTION NV_vertex_program3;

    to the beginning of their vertex programs.

    New functionality provided by this extension, above and beyond that
    already provided by NV_vertex_program2_option extension, includes: 

        * texture lookups in vertex programs,

        * ability to push and pop address registers on the stack,

        * address register-relative addressing for vertex attribute and
          result arrays, and

        * a second four-component condition code.

Issues

    Should we provided a separate "!!VP3.0" program type, like the
    "!!VP2.0" type defined in NV_vertex_program2?

      RESOLVED:  No.  Since ARB_vertex_program has been fully defined
      (it wasn't in the !!VP2.0 time-frame), we will simply define
      language extensions to !!ARBvp1.0 that expose new functionality.
      The NV_vertex_program2_option specification followed this same
      pattern for the NV3X family (GeForce FX, Quadro FX).

    Should this be called "NV_vertex_program3_option"?

      RESOLVED:  No.  The similar extension to !!ARBvp1.0 called
      "NV_vertex_program2_option" got that name only because the simpler
      "NV_vertex_program2" name had already been used.

    Is there a limit on the number of texture units that can be accessed
    by a vertex program?

      RESOLVED:  Yes.  The limit may be lower than the total number of texture
      image units available and is given by the implementation-dependent
      constant MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB.  Any program that attempts
      to use more unique texture image units will fail to load.  Programs can
      use any texture image unit number, as long as they don't use too many
      simultaneously.  As an example, the GeForce 6 series of GPUs provides 16
      texture image units accessible to vertex programs, but no more than four
      can be used simultaneously.  It is not an error to use texture image
      units 12-15 in a program.

      This limitation is identical to the one in the ARB_vertex_shader
      extensions -- both extensions use the same enum to query the number of
      available image units.  Violating this limit in GLSL results in a link
      error.

    Is there a restriction on the texture targets that can be accessed by a
    vertex program?

      RESOLVED:  Yes -- for any texture image unit, vertex and fragment
      processing can not use different targets.  If they do, an
      INVALID_OPERATION is generated at Begin-time.  This resolution is
      consistent with resultion of the same issue in the ARB_vertex_shader
      extension and OpenGL 2.0.

    Since vertices don't have screen space partial derivatives, how is
    the LOD used for texture accesses defined?

      RESOLVED:  The TXL instruction allows a program to explicitly
      set an LOD; the LOD for all other texture instructions is zero.
      The texture LOD bias specified in the texture object and environment
      do apply to all vertex texture lookups.


New Procedures and Functions

    None.

New Tokens


        MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB              0x8B4C

