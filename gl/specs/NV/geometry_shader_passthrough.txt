Name

    NV_geometry_shader_passthrough

Name Strings

    GL_NV_geometry_shader_passthrough

Contact

    Pat Brown, NVIDIA Corporation (pbrown 'at' nvidia.com)

Contributors

    Jeff Bolz, NVIDIA Corporation
    Piers Daniell, NVIDIA Corporation
    Christoph Kubisch, NVIDIA Corporation
    Mathias Heyer, NVIDIA Corporation

Status

    Shipping

Version

    Last Modified Date:         March 27, 2015
    NVIDIA Revision:            2

Number

    OpenGL Extension #470
    OpenGL ES Extension #233

Dependencies

    This extension is written against the OpenGL 4.3 Specification
    (Compatibility Profile), dated February 14, 2013

    This extension is written against the OpenGL Shading Language
    Specification, version 4.30, revision 8.

    OpenGL ES 3.1 and EXT_geometry_shader are required for an
    implementation in OpenGL ES.

    This extension interacts with OpenGL 4.4 and ARB_enhanced_layouts.

    This extension interacts with NV_gpu_program4 and NV_gpu_program5.

    This extension interacts with NV_geometry_shader4 and NV_gpu_shader4.

    This extension interacts with NV_geometry_program4 and NV_gpu_program4.

    This extension interacts with NV_transform_feedback.

    This extension interacts with a combination of NV_gpu_program4,
    NV_gpu_program5, NV_transform_feedback, EXT_transform_feedback, and OpenGL
    3.0.

    This extension interacts with NVX_shader_thread_group.

Overview

    Geometry shaders provide the ability for applications to process each
    primitive sent through the GL using a programmable shader.  While geometry
    shaders can be used to perform a number of different operations, including
    subdividing primitives and changing primitive type, one common use case
    treats geometry shaders as largely "passthrough".  In this use case, the
    bulk of the geometry shader code simply copies inputs from each vertex of
    the input primitive to corresponding outputs in the vertices of the output
    primitive.  Such shaders might also compute values for additional built-in
    or user-defined per-primitive attributes (e.g., gl_Layer) to be assigned
    to all the vertices of the output primitive.

    This extension provides a shading language abstraction to express such
    shaders without requiring explicit logic to manually copy attributes from
    input vertices to output vertices.  For example, consider the following
    simple geometry shader in unextended OpenGL:

      layout(triangles) in;
      layout(triangle_strip) out;
      layout(max_vertices=3) out;

      in Inputs {
        vec2 texcoord;
        vec4 baseColor;
      } v_in[];
      out Outputs {
        vec2 texcoord;
        vec4 baseColor;
      };

      void main()
      {
        int layer = compute_layer();
        for (int i = 0; i < 3; i++) {
          gl_Position = gl_in[i].gl_Position;
          texcoord = v_in[i].texcoord;
          baseColor = v_in[i].baseColor;
          gl_Layer = layer;
          EmitVertex();
        }
      }

    In this shader, the inputs "gl_Position", "Inputs.texcoord", and
    "Inputs.baseColor" are simply copied from the input vertex to the
    corresponding output vertex.  The only "interesting" work done by the
    geometry shader is computing and emitting a gl_Layer value for the
    primitive.

    The following geometry shader, using this extension, is equivalent:

      #extension GL_NV_geometry_shader_passthrough : require

      layout(triangles) in;
      // No output primitive layout qualifiers required.

      // Redeclare gl_PerVertex to pass through "gl_Position".
      layout(passthrough) in gl_PerVertex {
        vec4 gl_Position;
      };

      // Declare "Inputs" with "passthrough" to automatically copy members.
      layout(passthrough) in Inputs {
        vec2 texcoord;
        vec4 baseColor;
      };

      // No output block declaration required.

      void main()
      {
        // The shader simply computes and writes gl_Layer.  We don't
        // loop over three vertices or call EmitVertex().
        gl_Layer = compute_layer();
      }

New Procedures and Functions

    None.

New Tokens


