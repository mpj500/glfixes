Name

    NV_fragment_shader_interlock

Name Strings

    GL_NV_fragment_shader_interlock

Contact

    Pat Brown, NVIDIA Corporation (pbrown 'at' nvidia.com)

Contributors

    Jeff Bolz, NVIDIA Corporation
    Mathias Heyer, NVIDIA Corporation

Status

    Shipping

Version

    Last Modified Date:         March 27, 2015
    NVIDIA Revision:            2

Number

    OpenGL Extension #468
    OpenGL ES Extension #230

Dependencies

    This extension is written against the OpenGL 4.3
    (Compatibility Profile, dated February 14, 2013), and the
    OpenGL ES 3.1.0 (dated March 17, 2014) Specification

    This extension is written against the OpenGL Shading Language
    Specification (version 4.30, revision 8) and the OpenGL ES Shading
    Language Specification (version 3.10, revision 2).

    OpenGL 4.3 and GLSL 4.30 are required in an OpenGL implementation
    OpenGL ES 3.1 and GLSL ES 3.10 are required in an OpenGL ES implementation

    This extension interacts with NV_shader_buffer_load and
    NV_shader_buffer_store.

    This extension interacts with NV_gpu_program4 and NV_gpu_program5.

    This extension interacts with EXT_tessellation_shader.

    This extension interacts with OES_sample_shading

    This extension interacts with OES_shader_multisample_interpolation

    This extension interacts with OES_shader_image_atomic

Overview

    In unextended OpenGL 4.3 or OpenGL ES 3.1, applications may produce a
    large number of fragment shader invocations that perform loads and
    stores to memory using image uniforms, atomic counter uniforms,
    buffer variables, or pointers. The order in which loads and stores
    to common addresses are performed by different fragment shader
    invocations is largely undefined.  For algorithms that use shader
    writes and touch the same pixels more than once, one or more of the
    following techniques may be required to ensure proper execution ordering:

      * inserting Finish or WaitSync commands to drain the pipeline between
        different "passes" or "layers";

      * using only atomic memory operations to write to shader memory (which
        may be relatively slow and limits how memory may be updated); or

      * injecting spin loops into shaders to prevent multiple shader
        invocations from touching the same memory concurrently.

    This extension provides new GLSL built-in functions
    beginInvocationInterlockNV() and endInvocationInterlockNV() that delimit a
    critical section of fragment shader code.  For pairs of shader invocations
    with "overlapping" coverage in a given pixel, the OpenGL implementation
    will guarantee that the critical section of the fragment shader will be
    executed for only one fragment at a time.

    There are four different interlock modes supported by this extension,
    which are identified by layout qualifiers.  The qualifiers
    "pixel_interlock_ordered" and "pixel_interlock_unordered" provides mutual
    exclusion in the critical section for any pair of fragments corresponding
    to the same pixel.  When using multisampling, the qualifiers
    "sample_interlock_ordered" and "sample_interlock_unordered" only provide
    mutual exclusion for pairs of fragments that both cover at least one
    common sample in the same pixel; these are recommended for performance if
    shaders use per-sample data structures.

    Additionally, when the "pixel_interlock_ordered" or
    "sample_interlock_ordered" layout qualifier is used, the interlock also
    guarantees that the critical section for multiple shader invocations with
    "overlapping" coverage will be executed in the order in which the
    primitives were processed by the GL.  Such a guarantee is useful for
    applications like blending in the fragment shader, where an application
    requires that fragment values to be composited in the framebuffer in
    primitive order.

    This extension can be useful for algorithms that need to access per-pixel
    data structures via shader loads and stores.  Such algorithms using this
    extension can access such data structures in the critical section without
    worrying about other invocations for the same pixel accessing the data
    structures concurrently.  Additionally, the ordering guarantees are useful
    for cases where the API ordering of fragments is meaningful.  For example,
    applications may be able to execute programmable blending operations in
    the fragment shader, where the destination buffer is read via image loads
    and the final value is written via image stores.

New Procedures and Functions

    None.

New Tokens


