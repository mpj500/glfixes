Name

    NV_half_float

Name Strings

    GL_NV_half_float

Contact

    Pat Brown, NVIDIA Corporation (pbrown 'at' nvidia.com)

Notice

    Copyright NVIDIA Corporation, 2001-2002.

IP Status

    NVIDIA Proprietary.

Status

    Implemented in CineFX (NV30) Emulation driver, August 2002.
    Shipping in Release 40 NVIDIA driver for CineFX hardware, January 2003.

Version

    Last Modified Date:         02/25/2004
    NVIDIA Revision:            9

Number

    283

Dependencies

    Written based on the wording of the OpenGL 1.3 specification.

    OpenGL 1.1 is required.

    NV_float_buffer affects the definition of this extension.

    EXT_fog_coord affects the definition of this extension.

    EXT_secondary_color affects the definition of this extension.

    EXT_vertex_weighting affects the definition of this extension.

    NV_vertex_program affects the definition of this extension.

Overview

    This extension introduces a new storage format and data type for
    half-precision (16-bit) floating-point quantities.  The floating-point
    format is very similar to the IEEE single-precision floating-point
    standard, except that it has only 5 exponent bits and 10 mantissa bits.
    Half-precision floats are smaller than full precision floats and provide a
    larger dynamic range than similarly-sized normalized scalar data types.

    This extension allows applications to use half-precision floating point
    data when specifying vertices or pixel data.  It adds new commands to
    specify vertex attributes using the new data type, and extends the
    existing vertex array and image specification commands to accept the new
    data type.

    This storage format is also used to represent 16-bit components in the
    floating-point frame buffers, as defined in the NV_float_buffer extension.

Issues

    What should the new data type be called?  "half"?  "hfloat"?  In addition,
    what should the immediate mode function suffix be?  "h"?  "hf"?

        RESOLVED:  half and "h".  This convention builds on the convention of
        using the type "double" to describe double-precision floating-point
        numbers.  Here, "half" will refer to half-precision floating-point
        numbers.

        Even though the 16-bit float data type is a first-class data type, it
        is still more problematic than the other types in the sense that no
        native programming languages support the data type.  "hfloat/hf" would
        have reflected a second-class status better than "half/h".

        Both names are not without conflicting precedents.  The name "half" is
        used to connote 16-bit scalar values on some 32-bit CPU architectures
        (e.g., PowerPC).  The name "hfloat" has been used to describe 128-bit
        floating-point data on VAX systems.

    Should we provide immediate-mode entry points for half-precision
    floating-point data types?

        RESOLVED:  Yes, for orthogonality.  Also useful as a fallback for the
        "general" case for ArrayElement.

    Should we support half-precision floating-point color index data?

        RESOLVED:  No.

    Should half-precision data be accepted by all commands that accept pixel
    data or only a subset?

        RESOLVED:  All functions.  Note that some textures or frame buffers
        may store the half-precision floating-point data natively.

        Since half float data would be accepted in some cases, it will be
        necessary for drivers to provide some data conversion code.  This code
        can be reused to handle the less common commands.


New Procedures and Functions

    void Vertex2hNV(half x, half y);
    void Vertex2hvNV(const half *v);
    void Vertex3hNV(half x, half y, half z);
    void Vertex3hvNV(const half *v);
    void Vertex4hNV(half x, half y, half z, half w);
    void Vertex4hvNV(const half *v);
    void Normal3hNV(half nx, half ny, half nz);
    void Normal3hvNV(const half *v);
    void Color3hNV(half red, half green, half blue);
    void Color3hvNV(const half *v);
    void Color4hNV(half red, half green, half blue, half alpha);
    void Color4hvNV(const half *v);
    void TexCoord1hNV(half s);
    void TexCoord1hvNV(const half *v);
    void TexCoord2hNV(half s, half t);
    void TexCoord2hvNV(const half *v);
    void TexCoord3hNV(half s, half t, half r);
    void TexCoord3hvNV(const half *v);
    void TexCoord4hNV(half s, half t, half r, half q);
    void TexCoord4hvNV(const half *v);
    void MultiTexCoord1hNV(enum target, half s);
    void MultiTexCoord1hvNV(enum target, const half *v);
    void MultiTexCoord2hNV(enum target, half s, half t);
    void MultiTexCoord2hvNV(enum target, const half *v);
    void MultiTexCoord3hNV(enum target, half s, half t, half r);
    void MultiTexCoord3hvNV(enum target, const half *v);
    void MultiTexCoord4hNV(enum target, half s, half t, half r, half q);
    void MultiTexCoord4hvNV(enum target, const half *v);
    void VertexAttrib1hNV(uint index, half x);
    void VertexAttrib1hvNV(uint index, const half *v);
    void VertexAttrib2hNV(uint index, half x, half y);
    void VertexAttrib2hvNV(uint index, const half *v);
    void VertexAttrib3hNV(uint index, half x, half y, half z);
    void VertexAttrib3hvNV(uint index, const half *v);
    void VertexAttrib4hNV(uint index, half x, half y, half z, half w);
    void VertexAttrib4hvNV(uint index, const half *v);
    void VertexAttribs1hvNV(uint index, sizei n, const half *v);
    void VertexAttribs2hvNV(uint index, sizei n, const half *v);
    void VertexAttribs3hvNV(uint index, sizei n, const half *v);
    void VertexAttribs4hvNV(uint index, sizei n, const half *v);

    (added if EXT_fog_coord is supported)

    void FogCoordhNV(half fog);
    void FogCoordhvNV(const half *fog);

    (added if EXT_secondary_color is supported)

    void SecondaryColor3hNV(half red, half green, half blue);
    void SecondaryColor3hvNV(const half *v);

    (added if EXT_vertex_weighting is supported)

    void VertexWeighthNV(half weight);
    void VertexWeighthvNV(const half *weight);

New Tokens


        HALF_FLOAT_NV                                   0x140B

