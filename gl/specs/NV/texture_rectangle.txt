Name

    NV_texture_rectangle

Name Strings

    GL_NV_texture_rectangle

Contact

    Mark J. Kilgard, NVIDIA Corporation (mjk 'at' nvidia.com)

Notice

    Copyright NVIDIA Corporation, 2000, 2001, 2002, 2003, 2004.

Status

    Implemented in NVIDIA's Release 10 drivers.

Version

    NVIDIA Date: March 5, 2004

Number

    229

Dependencies

    Written based on the OpenGL 1.2.1 specification including
    ARB_texture_cube_map wording.

    IBM_mirrored_repeat affects the definition of this extension.

    ARB_texture_border_clamp affects the definition of this extension.

    EXT_paletted_texture affects the definition of this extension.

    This extension affects the definition of the NV_texture_shader
    extension.

Overview

    OpenGL texturing is limited to images with power-of-two dimensions
    and an optional 1-texel border.  NV_texture_rectangle extension
    adds a new texture target that supports 2D textures without requiring
    power-of-two dimensions.

    Non-power-of-two dimensioned textures are useful for storing
    video images that do not have power-of-two dimensions.  Re-sampling
    artifacts are avoided and less texture memory may be required by using
    non-power-of-two dimensioned textures.  Non-power-of-two dimensioned
    textures are also useful for shadow maps and window-space texturing.

    However, non-power-of-two dimensioned (NPOTD) textures have
    limitations that do not apply to power-of-two dimensioned (POT)
    textures.  NPOTD textures may not use mipmap filtering; POTD
    textures support both mipmapped and non-mipmapped filtering.
    NPOTD textures support only the GL_CLAMP, GL_CLAMP_TO_EDGE,
    and GL_CLAMP_TO_BORDER_ARB wrap modes; POTD textures support
    GL_CLAMP_TO_EDGE, GL_REPEAT, GL_CLAMP, GL_MIRRORED_REPEAT_IBM,
    and GL_CLAMP_TO_BORDER.  NPOTD textures do not support an optional
    1-texel border; POTD textures do support an optional 1-texel border.

    NPOTD textures are accessed by non-normalized texture coordinates.
    So instead of thinking of the texture image lying in a [0..1]x[0..1]
    range, the NPOTD texture image lies in a [0..w]x[0..h] range.

    This extension adds a new texture target and related state (proxy,
    binding, max texture size).

Issues

    Should rectangular textures simply be an extension to the 2D texture
    target that allows non-power-of-two widths and heights?

      RESOLUTION:  No.  The rectangular texture is an entirely new texture
      target type called GL_TEXTURE_RECTANGLE_NV.  This is because while
      the texture rectangle target relaxes the power-of-two dimensions
      requirements of the texture 2D target, it also has limitations
      such as the absence of both mipmapping and the GL_REPEAT and
      GL_MIRRORED_REPEAT_IBM wrap modes.  Additionally, rectangular
      textures do not use [0..1] normalized texture coordinates.

    How is the image of a rectangular texture specified?

      RESOLUTION:  Using the standard OpenGL API for specifying a 2D
      texture image: glTexImage2D, glSubTexImage2D, glCopyTexImage2D,
      and glCopySubTexImage2D.  The target for these commands is
      GL_TEXTURE_RECTANGLE_NV though.

      This is similar to how the ARB_texture_cube_map extension uses
      the 2D texture image specification API though with its own texture
      target.

    Should 3D textures be allowed to be NPOTD?
    
      RESOLUTION:  No.  That should be left to another extension.

    Should cube map textures be allowed to be NPOTD?

      RESOLUTION:  No.  Probably not particularly interesting for
      cube maps.  If it becomes important, another extension should
      provide NPOTD cube maps.

    Should 1D textures be allowed to be NPOTD?

      RESOLUTION:  No.  Rectangular textures are always considered 2D
      by this extension.  You can always simulate a 1D NPOTD textures
      by using a 2D Wx1 or 1xH dimensioned rectangular texture.

    Should anything be said about performance?

      RESOLUTION:  No, but developers should not be surprised if
      conventional POTD textures will render slightly faster than NPOTD
      textures.  This is particularly likely to be true when NPOTD
      textures are minified leading to texture cache thrashing.

    How are rectangular textures enabled?

      RESOLUTION:  Since rectangular textures add a new texture target,
      you enable rectangular textures by enabling this target.  Example:

        glEnable(GL_TEXTURE_RECTANGLE_NV);

    What is the priority of the rectangular texture target enable relative to
    existing texture enables?

      RESOLUTION:  The texture rectangle target is like a 2D texture in
      many ways so its enable priority is just above GL_TEXTURE_2D.  From
      lowest priority to highest priority: GL_TEXTURE_1D, GL_TEXTURE_2D,
      GL_TEXTURE_RECTANGLE_NV, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARB.

    What is the default wrap state for a texture rectangle?

      RESOLUTION:  GL_CLAMP_TO_EDGE.  The normal default wrap state is
      GL_REPEAT, but that mode is not allowed for rectangular textures?

    What is the default minification filter for a texture rectangle?

      RESOLUTION:  GL_LINEAR.  The normal default minification filter
      state is GL_NEAREST_MIPMAP_LINEAR, but that mode is not allowed
      for rectangular textures because mipmapping is not supported.

    Do paletted textures work with rectangular textures?

      RESOLUTION:  No.  Similar (but not identical) functionality can
      be accomplished using dependent texture shader operations (see
      NV_texture_shader).

      The difference between paletted texture accesses and dependent
      texture accesses is that paletted texture lookups are
      "pre-filtering" while dependent texture shader operations are
      "post-filtering".

    Can compressed texture images be specified for a rectangular texture?

      RESOLUTION:  The generic texture compression internal formats
      introduced by ARB_texture_compression are supported for rectangular
      textures because the image is not presented as compressed data and
      the ARB_texture_compression extension always permits generic texture
      compression internal formats to be stored in uncompressed form.
      Implementations are free to support generic compression internal
      formats for rectangular textures if supported but such support is
      not required.

      This extensions makes a blanket statement that specific compressed
      internal formats for use with CompressedTexImage<n>DARB are NOT
      supported for rectangular textures.  This is because several
      existing hardware implementations of texture compression formats
      such as S3TC are not designed for compressing rectangular textures.
      This does not preclude future texture compression extensions from
      supporting compressed internal formats that do work with rectangular
      extensions (by relaxing the current blanket error condition).

    Does this extension work with SGIX_shadow-style shadow mapping?

      RESOLUTION:  Yes.  The one non-obvious allowance to support
      SGIX_shadow-style shadow mapping is that the R texture coordinate
      wrap mode remains UNCHANGED for rectangular textures.  Clamping of
      the R texture coordinate for rectangular textures uses the standard
      [0,1] interval rather than the [0,ws] or [0,hs] intervals as in
      the case of S and T.  This is because R represents a depth value
      in the [0,1] range whether using a 2D or rectangular texture.

New Procedures and Functions

    None

New Tokens


        TEXTURE_RECTANGLE_NV               0x84F5


        TEXTURE_BINDING_RECTANGLE_NV       0x84F6




        PROXY_TEXTURE_RECTANGLE_NV          0x84F7 


        MAX_RECTANGLE_TEXTURE_SIZE_NV       0x84F8

