Name

    NV_fence

Name Strings

    GL_NV_fence

Contact

    John Spitzer, NVIDIA Corporation (jspitzer 'at' nvidia.com)
    Mark Kilgard, NVIDIA Corporation (mjk 'at' nvidia.com)

Contributors

    John Spitzer
    Mark Kilgard
    Acorn Pooley

Notice

    Copyright NVIDIA Corporation, 2000, 2001.

IP Status

    NVIDIA Proprietary.

Status

    Shipping as of June 8, 2000 (version 1.0)

    Shipping as of November, 2003 (version 1.1)

    Version 1.2 adds ES support and clarification; otherwise identical to 1.1.

Version

    December 17, 2008 (version 1.2)

Number

    OpenGL Extension #222
    OpenGL ES Extension #52

Dependencies

    This extension is written against the OpenGL 1.2.1 Specification.
    It can also be used with OpenGL ES (see the section, "Dependencies on
    OpenGL ES," below).

Overview

    The goal of this extension is provide a finer granularity of
    synchronizing GL command completion than offered by standard OpenGL,
    which offers only two mechanisms for synchronization: Flush and Finish.
    Since Flush merely assures the user that the commands complete in a
    finite (though undetermined) amount of time, it is, thus, of only
    modest utility.  Finish, on the other hand, stalls CPU execution
    until all pending GL commands have completed.  This extension offers
    a middle ground - the ability to "finish" a subset of the command
    stream, and the ability to determine whether a given command has
    completed or not.

    This extension introduces the concept of a "fence" to the OpenGL
    command stream.  Once the fence is inserted into the command stream, it
    can be queried for a given condition - typically, its completion.
    Moreover, the application may also request a partial Finish -- that is,
    all commands prior to the fence will be forced to complete until control
    is returned to the calling process.  These new mechanisms allow for
    synchronization between the host CPU and the GPU, which may be accessing
    the same resources (typically memory).

    This extension is useful in conjunction with NV_vertex_array_range
    to determine when vertex information has been pulled from the
    vertex array range.  Once a fence has been tested TRUE or finished,
    all vertex indices issued before the fence must have been pulled.
    This ensures that the vertex data memory corresponding to the issued
    vertex indices can be safely modified (assuming no other outstanding
    vertex indices are issued subsequent to the fence).
    
Issues

    Do we need an IsFenceNV command?

        RESOLUTION:  Yes.  Not sure who would use this, but it's in there.
        Semantics currently follow the texture object definition --
        that is, calling IsFenceNV before SetFenceNV will return FALSE.

    Are the fences sharable between multiple contexts?

        RESOLUTION:  No.

        Potentially this could change with a subsequent extension.

    What other conditions will be supported?

        Only ALL_COMPLETED_NV will be supported initially.  Future extensions
        may wish to implement additional fence conditions.

    What is the relative performance of the calls?

        Execution of a SetFenceNV is not free, but will not trigger a
        Flush or Finish.

    Is the TestFenceNV call really necessary?  How often would this be used
    compared to the FinishFenceNV call (which also flushes to ensure this
    happens in finite time)?

        It is conceivable that a user may use TestFenceNV to decide
        which portion of memory should be used next without stalling
        the CPU.  An example of this would be a scenario where a single
        AGP buffer is used for both static (unchanged for multiple frames)
        and dynamic (changed every frame) data.  If the user has written
        dynamic data to all banks dedicated to dynamic data, and still
        has more dynamic objects to write, the user would first want to
        check if the first dynamic object has completed, before writing
        into the buffer.  If the object has not completed, instead of
        stalling the CPU with a FinishFenceNV call, it would possibly
        be better to start overwriting static objects instead.

    What should happen if TestFenceNV is called for a name before SetFenceNV
    is called?

        We generate an INVALID_OPERATION error, and return TRUE.
        This follows the semantics for texture object names before
        they are bound, in that they acquire their state upon binding.
        We will arbitrarily return TRUE for consistency.

    What should happen if FinishFenceNV is called for a name before
    SetFenceNV is called?

        RESOLUTION:  Generate an INVALID_OPERATION error because the
        fence id does not exist yet.  SetFenceNV must be called to create
        a fence.

    Do we need a mechanism to query which condition a given fence was
    set with?

        RESOLUTION:  Yes, use glGetFenceivNV with FENCE_CONDITION_NV.

    Should we allow these commands to be compiled within display list?
    Which ones?  How about within Begin/End pairs?

        RESOLUTION:  DeleteFencesNV, FinishFenceNV, GenFencesNV,
        TestFenceNV, and IsFenceNV are executed immediately while
        SetFenceNV is compiled.  Do not allow any of these commands
        within Begin/End pairs.

    Can fences be used as a form of performance monitoring?

        Yes, with some caveats.  By setting and testing or finishing
        fences, developers can measure the GPU latency for completing
        GL operations.  For example, developers might do the following:

          start = getCurrentTime();
          updateTextures();
          glSetFenceNV(TEXTURE_LOAD_FENCE, GL_ALL_COMPLETED_NV);
          drawBackground();
          glSetFenceNV(DRAW_BACKGROUND_FENCE, GL_ALL_COMPLETED_NV);
          drawCharacters();
          glSetFenceNV(DRAW_CHARACTERS_FENCE, GL_ALL_COMPLETED_NV);

          glFinishFenceNV(TEXTURE_LOAD_FENCE);
          textureLoadEnd = getCurrentTime();

          glFinishFenceNV(DRAW_BACKGROUND_FENCE);
          drawBackgroundEnd = getCurrentTime();

          glFinishFenceNV(DRAW_CHARACTERS_FENCE);
          drawCharactersEnd = getCurrentTime();

          printf("texture load time = %d\n", textureLoadEnd - start);
          printf("draw background time = %d\n", drawBackgroundEnd - textureLoadEnd);
          printf("draw characters time = %d\n", drawCharacters - drawBackgroundEnd);

        Note that there is a small amount of overhead associated with
        inserting each fence into the GL command stream.  Each fence
        causes the GL command stream to momentarily idle (idling the
        entire GPU pipeline).  The significance of this idling should
        be small if there are a small number of fences and large amount
        of intervening commands.

        If the time between two fences is zero or very near zero,
        it probably means that a GPU-CPU synchronization such as a
        glFinish probably occurred.  A glFinish is an explicit GPU-CPU
        synchronization, but sometimes implicit GPU-CPU synchronizations
        are performed by the driver.

    What happens if you set the same fence object twice?

        The second SetFenceNV clobbers whatever status the fence object
        previously had by forcing the object's status to GL_TRUE.
        The completion of the first SetFenceNV's fence command placed
        in the command stream is ignored (its completion does NOT
        update the fence object's status).  The second SetFenceNV sets a
        new fence command in the GL command stream.  This second fence
        command will update the fence object's status (assuming it is
        not ignored by a subsequent SetFenceNV to the same fence object).

    What happens to a fence command that is still pending execution
    when its fence object is deleted?

        The fence command completion is ignored.

    What happens if you use an arbitrary number for the SetFenceNV() <fence>
    parameter instead of obtaining the name from GenFences()?

        This works fine (just as with texture objects).

New Procedures and Functions

    void GenFencesNV(sizei n, uint *fences);

    void DeleteFencesNV(sizei n, const uint *fences);

    void SetFenceNV(uint fence, enum condition);

    boolean TestFenceNV(uint fence);

    void FinishFenceNV(uint fence);

    boolean IsFenceNV(uint fence);

    void GetFenceivNV(uint fence, enum pname, int *params);

New Tokens


        ALL_COMPLETED_NV                   0x84F2


        FENCE_STATUS_NV                    0x84F3
        FENCE_CONDITION_NV                 0x84F4

