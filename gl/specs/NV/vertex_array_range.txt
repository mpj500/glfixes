Name

    NV_vertex_array_range

Name Strings

    GL_NV_vertex_array_range

Contact

    Mark J. Kilgard, NVIDIA Corporation (mjk 'at' nvidia.com)

Notice

    Copyright NVIDIA Corporation, 1999, 2000, 2001.

IP Status

    NVIDIA Proprietary.

Status

    Shipping (version 1.1)

    Existing functionality is augmented by NV_vertex_array_range2.

Version

    NVIDIA Date: September 17, 2001 (version 1.1)

Number

    190

Dependencies

    None

Overview

    The goal of this extension is to permit extremely high vertex
    processing rates via OpenGL vertex arrays even when the CPU lacks
    the necessary data movement bandwidth to keep up with the rate
    at which the vertex engine can consume vertices.  CPUs can keep
    up if they can just pass vertex indices to the hardware and
    let the hardware "pull" the actual vertex data via Direct Memory
    Access (DMA).  Unfortunately, the current OpenGL 1.1 vertex array
    functionality has semantic constraints that make such an approach
    hard.  Hence, the vertex array range extension.

    This extension provides a mechanism for deferring the pulling of
    vertex array elements to facilitate DMAed pulling of vertices for
    fast, efficient vertex array transfers.  The OpenGL client need only
    pass vertex indices to the hardware which can DMA the actual index's
    vertex data directly out of the client address space.

    The OpenGL 1.1 vertex array functionality specifies a fairly strict
    coherency model for when OpenGL extracts vertex data from a vertex
    array and when the application can update the in memory
    vertex array data.  The OpenGL 1.1 specification says "Changes
    made to array data between the execution of Begin and the
    corresponding execution of End may affect calls to ArrayElement
    that are made within the same Begin/End period in non-sequential
    ways.  That is, a call to ArrayElement that precedes a change to
    array data may access the changed data, and a call that follows
    a change to array data may access the original data."

    This means that by the time End returns (and DrawArrays and
    DrawElements return since they have implicit Ends), the actual vertex
    array data must be transferred to OpenGL.  This strict coherency model
    prevents us from simply passing vertex element indices to the hardware
    and having the hardware "pull" the vertex data out (which is often
    long after the End for the primitive has returned to the application).

    Relaxing this coherency model and bounding the range from which
    vertex array data can be pulled is key to making OpenGL vertex
    array transfers faster and more efficient.

    The first task of the vertex array range extension is to relax
    the coherency model so that hardware can indeed "pull" vertex
    data from the OpenGL client's address space long after the application
    has completed sending the geometry primitives requiring the vertex
    data.

    The second problem with the OpenGL 1.1 vertex array functionality is
    the lack of any guidance from the API about what region of memory
    vertices can be pulled from.  There is no size limit for OpenGL 1.1
    vertex arrays.  Any vertex index that points to valid data in all
    enabled arrays is fair game.  This makes it hard for a vertex DMA
    engine to pull vertices since they can be potentially pulled from
    anywhere in the OpenGL client address space.

    The vertex array range extension specifies a range of the OpenGL
    client's address space where vertices can be pulled.  Vertex indices
    that access any array elements outside the vertex array range
    are specified to be undefined.  This permits hardware to DMA from
    finite regions of OpenGL client address space, making DMA engine
    implementation tractable.

    The extension is specified such that an (error free) OpenGL client
    using the vertex array range functionality could no-op its vertex
    array range commands and operate equivalently to using (if slower
    than) the vertex array range functionality.

    Because different memory types (local graphics memory, AGP memory)
    have different DMA bandwidths and caching behavior, this extension
    includes a window system dependent memory allocator to allocate
    cleanly the most appropriate memory for constructing a vertex array
    range.  The memory allocator provided allows the application to
    tradeoff the desired CPU read frequency, CPU write frequency, and
    memory priority while still leaving it up to OpenGL implementation
    the exact memory type to be allocated.

Issues

    How does this extension interact with the compiled_vertex_array
    extension?  

       I think they should be independent and not interfere with
       each other.  In practice, if you use NV_vertex_array_range,
       you can surpass the performance of compiled_vertex_array

    Should some explanation be added about what happens when an OpenGL
    application updates its address space in regions overlapping with
    the currently configured vertex array range?

       RESOLUTION:  I think the right thing is to say that you get
       non-sequential results.  In practice, you'll be using an old
       context DMA pointing to the old pages.

       If the application change's its address space within the
       vertex array range, the application should call
       glVertexArrayRangeNV again.  That will re-make a new vertex
       array range context DMA for the application's current address
       space.

    If we are falling back to software transformation, do we still need to
    abide by leaving "undefined" vertices outside the vertex array range?
    For example, pointers that are not 32-bit aligned would likely cause
    a fall back.

       RESOLUTION:  No.  The fact that vertex is "undefined" means we
       can do anything we want (as long as we send a vertex and do not
       crash) so it is perfectly fine for the software puller to
       grab vertex information not available to the hardware puller.

    Should we give a programmer a sense of how big a vertex array
    range they can specify?

       RESOLUTION:  No.  Just document it if there are limitations.
       Probably very hardware and operating system dependent.

    Is it clear enough that language about ArrayElement
    also applies to DrawArrays and DrawElements?

       Maybe not, but OpenGL 1.1 spec is clear that DrawArrays and
       DrawElements are defined in terms of ArrayElement.

    Should glFlush be the same as glVertexArrayRangeFlush?

       RESOLUTION:  No.  A glFlush is cheaper than a glVertexArrayRangeFlush
       though a glVertexArrayRangeFlushNV should do a flush.

    If any the data for any enabled array for a given array element index
    falls outside of the vertex array range, what happens?

       RESOLUTION:  An undefined vertex is generated.

    What error is generated in this case?

       I don't know yet.  We should make sure the hardware really does
       let us know when vertices are undefined.

       Note that this is a little weird for OpenGL since most errors
       in OpenGL result in the command being ignored.  Not in this
       case though.

    Should this extension support an interface for allocating video
    and AGP memory?

       RESOLUTION:  YES.  It seems like we should be able to leave
       the task of memory allocation to DirectDraw, but DirectDraw's
       asynchronous unmapping behavior and having to hold locks to
       update DirectDraw surfaces makes that mechanism to cumbersome.

       Plus the API is a lot easier if we do it ourselves.

    How do we decide what type of memory to allocate for the application?

       RESOLUTION:  Usage hints.  The application rates the read
       frequency (how often will they read the memory), the write
       frequency (how often will they write the memory), and the
       priority (how important is this memory relative to other
       uses for the memory such as texturing) on a scale of 1.0
       to 0.0.  Using these hints and the size of the memory requsted,
       the OpenGL implementation decides where to allocate the memory.

       We try to not directly expose particular types of memory
       (AGP, local memory, cached/uncached, etc) so future memory
       types can be supported by merely updating the OpenGL
       implementation.

    Should the memory allocator functionality be available be a part
    of the GL or window system dependent (GLX or WGL) APIs?

       RESOLUTION:  The window system dependent API.

       The memory allocator should be considered a window system/
       operating system dependent operation.  This also permits
       memory to be allocated when no OpenGL rendering contexts
       exist yet.

New Procedures and Functions

    void VertexArrayRangeNV(sizei length, void *pointer)
    void FlushVertexArrayRangeNV(void)

New Tokens


        VERTEX_ARRAY_RANGE_NV              0x851D


        VERTEX_ARRAY_RANGE_LENGTH_NV       0x851E
        VERTEX_ARRAY_RANGE_VALID_NV        0x851F
        MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV  0x8520


        VERTEX_ARRAY_RANGE_POINTER_NV      0x8521

