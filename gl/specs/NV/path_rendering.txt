Name

    NV_path_rendering

Name Strings

    GL_NV_path_rendering

Contact

    Mark Kilgard, NVIDIA (mjk 'at' nvidia.com)

Contributors

    Roger Allen, NVIDIA
    Jeff Bolz, NVIDIA
    Chris Dalton, NVIDIA
    Pierre-Loup Griffais, NVIDIA
    Chris Hebert, Samsung
    Scott Nations, NVIDIA
    David Chait, NVIDIA
    Daniel Koch, NVIDIA
    Bas Schouten, Mozilla
    Sandeep Shinde, NVIDIA

Status

    Released in NVIDIA Driver Release 275.33 (June 2011).

    Substantially optimized in NVIDIA Driver Release 301.42 (May 2012).

    Further optimized in NVIDIA Driver Release 314.xx (February 2013).

    Version 1.3 functionality shipping in NVIDIA Driver Release 337.88
    and on (May, 27 2014).

Version

    Last Modified Date:  September 9, 2014
    Version:             35

Number

    OpenGL Extension #410
    OpenGL ES Extension #199

Dependencies

    This extension is written against the OpenGL 3.2 Specification with
    Compatibility Profile but can apply to OpenGL 1.1 and up.

    When used with a Core profile or OpenGL ES context, certain
    functionality is unavailable (see "Dependencies on Core Profile and
    OpenGL ES" section).

    This extension depends on ARB_program_interface_query.

    EXT_direct_state_access commands are used in specifying portions
    of this extension but EXT_direct_state_access is not required to
    implement this extension as long as the functionality implemented
    is equivalent to the EXT_direct_state_access commands.

    EXT_separate_shader_objects is recommended.

    ARB_program_interface_query is recommended.

Overview

    Conventional OpenGL supports rendering images (pixel rectangles and
    bitmaps) and simple geometric primitives (points, lines, polygons).

    This extension adds a new rendering paradigm, known as path rendering,
    for rendering filled and stroked paths.  Path rendering is not novel
    but rather a standard part of most resolution-independent 2D rendering
    systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office
    drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML
    Paper Specification (XPS), and OpenVG.  What is novel is the ability
    to mix path rendering with arbitrary OpenGL 3D rendering and imaging.

    With this extension, path rendering becomes a first-class rendering
    mode within the OpenGL graphics system that can be arbitrarily mixed
    with existing OpenGL rendering and can take advantage of OpenGL's
    existing mechanisms for texturing, programmability, and per-fragment
    operations.

    Unlike geometric primitive rendering, paths are specified on a 2D
    (non-projective) plane rather than in 3D (projective) space.
    Even though the path is defined in a 2D plane, every path can
    be transformed into 3D clip space allowing for 3D view frustum &
    user-defined clipping, depth offset, and depth testing in the same
    manner as geometric primitive rendering.

    Both geometric primitive rendering and path rendering support
    rasterization of edges defined by line segments; however, path
    rendering also allows path segments to be specified by Bezier (cubic
    or quadratic) curves or partial elliptical arcs.  This allows path
    rendering to define truly curved primitive boundaries unlike the
    straight edges of line and polygon primitives.  Whereas geometric
    primitive rendering requires convex polygons for well-defined
    rendering results, path rendering allows (and encourages!) concave
    and curved outlines to be specified.  These paths are even allowed
    to self-intersect.

    When filling closed paths, the winding of paths (counterclockwise
    or clockwise) determines whether pixels are inside or outside of
    the path.

    Paths can also be stroked whereby, conceptually, a fixed-width "brush"
    is pulled along the path such that the brush remains orthogonal to
    the gradient of each path segment.  Samples within the sweep of this
    brush are considered inside the stroke of the path.

    This extension supports path rendering through a sequence of three
    operations:

        1.  Path specification is the process of creating and updating
            a path object consisting of a set of path commands and a
            corresponding set of 2D vertices.

            Path commands can be specified explicitly from path command
            and coordinate data, parsed from a string based on standard
            grammars for representing paths, or specified by a particular
            glyph of standard font representations.  Also new paths can
            be specified by weighting one or more existing paths so long
            as all the weighted paths have consistent command sequences.

            Each path object contains zero or more subpaths specified
            by a sequence of line segments, partial elliptical arcs,
            and (cubic or quadratic) Bezier curve segments.  Each path
            may contain multiple subpaths that can be closed (forming
            a contour) or open.

        2.  Path stenciling is the process of updating the stencil buffer
            based on a path's coverage transformed into window space.

            Path stenciling can determine either the filled or stroked
            coverage of a path.

            The details of path stenciling are explained within the core
            of the specification.

            Stenciling a stroked path supports all the standard
            embellishments for path stroking such as end caps, join
            styles, miter limits, dashing, and dash caps.  These stroking
            properties specified are parameters of path objects.

        3.  Path covering is the process of emitting simple (convex &
            planar) geometry that (conservatively) "covers" the path's
            sample coverage in the stencil buffer.  During path covering,
            stencil testing can be configured to discard fragments not
            within the actual coverage of the path as determined by
            prior path stenciling.

            Path covering can cover either the filled or stroked coverage
            of a path.

            The details of path covering are explained within the core
            of the specification.

    To render a path object into the color buffer, an application specifies
    a path object and then uses a two-step rendering process.  First, the
    path object is stenciled whereby the path object's stroked or filled
    coverage is rasterized into the stencil buffer.  Second, the path object
    is covered whereby conservative bounding geometry for the path is
    transformed and rasterized with stencil testing configured to test against
    the coverage information written to the stencil buffer in the first step
    so that only fragments covered by the path are written during this second
    step.  Also during this second step written pixels typically have
    their stencil value reset (so there's no need for clearing the
    stencil buffer between rendering each path).

    Here is an example of specifying and then rendering a five-point
    star and a heart as a path using Scalable Vector Graphics (SVG)
    path description syntax:

        GLuint pathObj = 42;
        const char *svgPathString =
          // star
          "M100,180 L40,10 L190,120 L10,120 L160,10 z"
          // heart
          "M300 300 C 100 400,100 200,300 100,500 200,500 400,300 300Z";
        glPathStringNV(pathObj, GL_PATH_FORMAT_SVG_NV,
                       (GLsizei)strlen(svgPathString), svgPathString);

    Alternatively applications oriented around the PostScript imaging
    model can use the PostScript user path syntax instead:

        const char *psPathString =
          // star
          "100 180 moveto"
          " 40 10 lineto 190 120 lineto 10 120 lineto 160 10 lineto closepath"
          // heart
          " 300 300 moveto"
          " 100 400 100 200 300 100 curveto"
          " 500 200 500 400 300 300 curveto closepath";
        glPathStringNV(pathObj, GL_PATH_FORMAT_PS_NV,
                       (GLsizei)strlen(psPathString), psPathString);

    The PostScript path syntax also supports compact and precise binary
    encoding and includes PostScript-style circular arcs.

    Or the path's command and coordinates can be specified explicitly:

        static const GLubyte pathCommands[10] =
          { GL_MOVE_TO_NV, GL_LINE_TO_NV, GL_LINE_TO_NV, GL_LINE_TO_NV,
            GL_LINE_TO_NV, GL_CLOSE_PATH_NV,
            'M', 'C', 'C', 'Z' };  // character aliases
        static const GLshort pathCoords[12][2] =
          { {100, 180}, {40, 10}, {190, 120}, {10, 120}, {160, 10},
            {300,300}, {100,400}, {100,200}, {300,100},
            {500,200}, {500,400}, {300,300} };
        glPathCommandsNV(pathObj, 10, pathCommands, 24, GL_SHORT, pathCoords);

    Before rendering to a window with a stencil buffer, clear the stencil
    buffer to zero and the color buffer to black:

        glClearStencil(0);
        glClearColor(0,0,0,0);
        glStencilMask(~0);
        glClear(GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

    Use an orthographic path-to-clip-space transform to map the
    [0..500]x[0..400] range of the star's path coordinates to the [-1..1]
    clip space cube:

        glMatrixLoadIdentityEXT(GL_PROJECTION);
        glMatrixLoadIdentityEXT(GL_MODELVIEW);
        glMatrixOrthoEXT(GL_MODELVIEW, 0, 500, 0, 400, -1, 1);

    Stencil the path:

        glStencilFillPathNV(pathObj, GL_COUNT_UP_NV, 0x1F);

    The 0x1F mask means the counting uses modulo-32 arithmetic. In
    principle the star's path is simple enough (having a maximum winding
    number of 2) that modulo-4 arithmetic would be sufficient so the mask
    could be 0x3.  Or a mask of all 1's (~0) could be used to count with
    all available stencil bits.

    Now that the coverage of the star and the heart have been rasterized
    into the stencil buffer, cover the path with a non-zero fill style
    (indicated by the GL_NOTEQUAL stencil function with a zero reference
    value):

        glEnable(GL_STENCIL_TEST);
        glStencilFunc(GL_NOTEQUAL, 0, 0x1F);
        glStencilOp(GL_KEEP, GL_KEEP, GL_ZERO);
        glColor3f(1,1,0); // yellow
        glCoverFillPathNV(pathObj, GL_BOUNDING_BOX_NV);

    The result is a yellow star (with a filled center) to the left of
    a yellow heart.

    The GL_ZERO stencil operation ensures that any covered samples
    (meaning those with non-zero stencil values) are zero'ed when
    the path cover is rasterized. This allows subsequent paths to be
    rendered without clearing the stencil buffer again.

    A similar two-step rendering process can draw a white outline
    over the star and heart.

    Before rendering, configure the path object with desirable path
    parameters for stroking.  Specify a wider 6.5-unit stroke and
    the round join style:

        glPathParameteriNV(pathObj, GL_PATH_JOIN_STYLE_NV, GL_ROUND_NV);
        glPathParameterfNV(pathObj, GL_PATH_STROKE_WIDTH_NV, 6.5);

     Now stencil the path's stroked coverage into the stencil buffer,
     setting the stencil to 0x1 for all stencil samples within the
     transformed path.

        glStencilStrokePathNV(pathObj, 0x1, ~0);

     Cover the path's stroked coverage (with a hull this time instead
     of a bounding box; the choice doesn't really matter here) while
     stencil testing that writes white to the color buffer and again
     zero the stencil buffer.

        glColor3f(1,1,1); // white
        glCoverStrokePathNV(pathObj, GL_CONVEX_HULL_NV);

     In this example, constant color shading is used but the application
     can specify their own arbitrary shading and/or blending operations,
     whether with Cg compiled to fragment program assembly, GLSL, or
     fixed-function fragment processing.

     More complex path rendering is possible such as clipping one path to
     another arbitrary path.  This is because stencil testing (as well
     as depth testing, depth bound test, clip planes, and scissoring)
     can restrict path stenciling.

     Now let's render the word "OpenGL" atop the star and heart.

     First create a sequence of path objects for the glyphs for the
     characters in "OpenGL":

        GLuint glyphBase = glGenPathsNV(6);
        const unsigned char *word = "OpenGL";
        const GLsizei wordLen = (GLsizei)strlen(word);
        const GLfloat emScale = 2048;  // match TrueType convention
        GLuint templatePathObject = ~0;  // Non-existent path object
        glPathGlyphsNV(glyphBase,
                       GL_SYSTEM_FONT_NAME_NV, "Helvetica", GL_BOLD_BIT_NV,
                       wordLen, GL_UNSIGNED_BYTE, word,
                       GL_SKIP_MISSING_GLYPH_NV, ~0, emScale);
        glPathGlyphsNV(glyphBase,
                       GL_SYSTEM_FONT_NAME_NV, "Arial", GL_BOLD_BIT_NV,
                       wordLen, GL_UNSIGNED_BYTE, word,
                       GL_SKIP_MISSING_GLYPH_NV, ~0, emScale);
        glPathGlyphsNV(glyphBase,
                       GL_STANDARD_FONT_NAME_NV, "Sans", GL_BOLD_BIT_NV,
                       wordLen, GL_UNSIGNED_BYTE, word,
                       GL_USE_MISSING_GLYPH_NV, ~0, emScale);

    Glyphs are loaded for three different fonts in priority order:
    Helvetica first, then Arial, and if neither of those loads, use the
    standard sans-serif font.  If a prior glPathGlyphsNV is successful
    and specifies the path object range, the subsequent glPathGlyphsNV
    commands silently avoid re-specifying the already existent path
    objects.

    Now query the (kerned) separations for the word "OpenGL" and build
    a set of horizontal translations advancing each successive glyph by
    its kerning distance with the following glyph.

        GLfloat xtranslate[6+1];  // wordLen+1
        glGetPathSpacingNV(GL_ACCUM_ADJACENT_PAIRS_NV,
                           wordLen+1, GL_UNSIGNED_BYTE,
                           "\000\001\002\003\004\005\005",  // repeat last letter twice
                           glyphBase,
                           1.0f, 1.0f,
                           GL_TRANSLATE_X_NV,
                           xtranslate);

    Next determine the font-wide vertical minimum and maximum for the
    font face by querying the per-font metrics of any one of the glyphs
    from the font face.

        GLfloat yMinMax[2];
        glGetPathMetricRangeNV(GL_FONT_Y_MIN_BOUNDS_BIT_NV|GL_FONT_Y_MAX_BOUNDS_BIT_NV,
                               glyphBase, /*count*/1,
                               2*sizeof(GLfloat),
                               yMinMax);

    Use an orthographic path-to-clip-space transform to map the
    word's bounds to the [-1..1] clip space cube:

        glMatrixLoadIdentityEXT(GL_PROJECTION);
        glMatrixOrthoEXT(GL_MODELVIEW,
                         0, xtranslate[6], yMinMax[0], yMinMax[1],
                         -1, 1);

    Stencil the filled paths of the sequence of glyphs for "OpenGL",
    each transformed by the appropriate 2D translations for spacing.

        glStencilFillPathInstancedNV(6, GL_UNSIGNED_BYTE,
                                     "\000\001\002\003\004\005",
                                     glyphBase,
                                     GL_PATH_FILL_MODE_NV, 0xFF,
                                     GL_TRANSLATE_X_NV, xtranslate);

     Cover the bounding box union of the glyphs with 50% gray.

        glEnable(GL_STENCIL_TEST);
        glStencilFunc(GL_NOTEQUAL, 0, 0xFF);
        glStencilOp(GL_KEEP, GL_KEEP, GL_ZERO);
        glColor3f(0.5,0.5,0.5); // 50% gray
        glCoverFillPathInstancedNV(6, GL_UNSIGNED_BYTE,
                                   "\000\001\002\003\004\005",
                                   glyphBase,
                                   GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV,
                                   GL_TRANSLATE_X_NV, xtranslate);

    Voila, the word "OpenGL" in gray is now stenciled into the framebuffer.

    Instead of solid 50% gray, the cover operation can apply a linear
    gradient that changes from green (RGB=0,1,0) at the top of the word
    "OpenGL" to blue (RGB=0,0,1) at the bottom of "OpenGL":

        GLfloat rgbGen[3][3] = {
          0, 0, 0,  // red   = constant zero
          0, 1, 0,  // green = varies with y from bottom (0) to top (1)
          0, -1, 1  // blue  = varies with y from bottom (1) to top (0)
        };
        glPathColorGenNV(GL_PRIMARY_COLOR, GL_PATH_OBJECT_BOUNDING_BOX_NV,
                         GL_RGB, &rgbGen[0][0]);

    Instead of loading just the glyphs for the characters in "OpenGL",
    the entire character set could be loaded.  This allows the characters
    of the string to be mapped (offset by the glyphBase) to path object names.
    A range of glyphs can be loaded like this:

        const int numChars = 256;  // ISO/IEC 8859-1 8-bit character range
        GLuint glyphBase = glGenPathsNV(numChars);
        glPathGlyphRangeNV(glyphBase,
                           GL_SYSTEM_FONT_NAME_NV, "Helvetica", GL_BOLD_BIT_NV,
                           0, numChars,
                           GL_SKIP_MISSING_GLYPH_NV, ~0, emScale);
        glPathGlyphRangeNV(glyphBase,
                           GL_SYSTEM_FONT_NAME_NV, "Arial", GL_BOLD_BIT_NV,
                           0, numChars,
                           GL_SKIP_MISSING_GLYPH_NV, ~0, emScale);
        glPathGlyphRangeNV(glyphBase,
                           GL_STANDARD_FONT_NAME_NV, "Sans", GL_BOLD_BIT_NV,
                           0, numChars,
                           GL_USE_MISSING_GLYPH_NV, ~0, emScale);

    Given a range of glyphs loaded as path objects, (kerned) spacing
    information can now be queried for the string:

        glGetPathSpacingNV(GL_ACCUM_ADJACENT_PAIRS_NV,
                           7, GL_UNSIGNED_BYTE, "OpenGLL", // repeat L to get final spacing
                           glyphBase,
                           1.0f, 1.0f,
                           GL_TRANSLATE_X_NV,
                           kerning);

    Using the range of glyphs, stenciling and covering the instanced
    paths for "OpenGL" can be done this way:

        glStencilFillPathInstancedNV(6, GL_UNSIGNED_BYTE, "OpenGL",
                                     glyphBase,
                                     GL_PATH_FILL_MODE_NV, 0xFF,
                                     GL_TRANSLATE_X_NV, xtranslate);

        glCoverFillPathInstancedNV(6, GL_UNSIGNED_BYTE, "OpenGL",
                                   glyphBase,
                                   GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV,
                                   GL_TRANSLATE_X_NV, xtranslate);

    The "stencil" and "cover" steps can be combined in a single command:

        glStencilThenCoverFillPathInstancedNV(6, GL_UNSIGNED_BYTE, "OpenGL",
                                              glyphBase,
                                              GL_PATH_FILL_MODE_NV, 0xFF,
                                              GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV
                                              GL_TRANSLATE_X_NV, xtranslate);

    XXX add path clipping example to demonstrate glPathStencilFuncNV.

New Procedures and Functions

    PATH SPECIFICATION COMMANDS

        EXPLICIT PATH DATA

        void PathCommandsNV(uint path,
                            sizei numCommands, const ubyte *commands,
                            sizei numCoords, enum coordType,
                            const void *coords);
        void PathCoordsNV(uint path,
                          sizei numCoords, enum coordType,
                          const void *coords);

        void PathSubCommandsNV(uint path,
                               sizei commandStart, sizei commandsToDelete,
                               sizei numCommands, const ubyte *commands,
                               sizei numCoords, enum coordType,
                               const void *coords);
        void PathSubCoordsNV(uint path,
                             sizei coordStart,
                             sizei numCoords, enum coordType,
                             const void *coords);

        STRING PATH DESCRIPTION

        void PathStringNV(uint path, enum format,
                          sizei length, const void *pathString);

        PATHS FROM FONT GLYPHS BY UNICODE CHARACTER POINT

        void PathGlyphsNV(uint firstPathName,
                          enum fontTarget,
                          const void *fontName,
                          bitfield fontStyle,
                          sizei numGlyphs, enum type,
                          const void *charcodes,
                          enum handleMissingGlyphs,
                          uint pathParameterTemplate,
                          float emScale);
        void PathGlyphRangeNV(uint firstPathName,
                              enum fontTarget,
                              const void *fontName,
                              bitfield fontStyle,
                              uint firstGlyph,
                              sizei numGlyphs,
                              enum handleMissingGlyphs,
                              uint pathParameterTemplate,
                              float emScale);

        PATHS FROM FONT GLYPHS BY PER-FONT GLYPH INDEX

        enum PathGlyphIndexArrayNV(uint firstPathName,
                                   enum fontTarget,
                                   const void *fontName,
                                   bitfield fontStyle,
                                   uint firstGlyphIndex,
                                   sizei numGlyphs,
                                   uint pathParameterTemplate,
                                   float emScale);
        enum PathMemoryGlyphIndexArrayNV(uint firstPathName,
                                         enum fontTarget,
                                         sizeiptr fontSize,
                                         const void *fontData,
                                         sizei faceIndex,
                                         uint firstGlyphIndex,
                                         sizei numGlyphs,
                                         uint pathParameterTemplate,
                                         float emScale);
        enum PathGlyphIndexRangeNV(enum fontTarget,
                                   const void *fontName,
                                   bitfield fontStyle,
                                   uint pathParameterTemplate,
                                   float emScale,
                                   uint baseAndCount[2]);

        PATH SPECIFICATION WITH EXISTING PATHS

        void WeightPathsNV(uint resultPath,
                           sizei numPaths,
                           const uint paths[], const float weights[]);
        void CopyPathNV(uint resultPath, uint srcPath);
        void InterpolatePathsNV(uint resultPath,
                                uint pathA, uint pathB,
                                float weight);
        void TransformPathNV(uint resultPath,
                             uint srcPath,
                             enum transformType,
                             const float *transformValues);

    PATH PARAMETER SPECIFICATION COMMANDS

        void PathParameterivNV(uint path, enum pname, const int *value);
        void PathParameteriNV(uint path, enum pname, int value);
        void PathParameterfvNV(uint path, enum pname, const float *value);
        void PathParameterfNV(uint path, enum pname, float value);

        void PathDashArrayNV(uint path,
                             sizei dashCount, const float *dashArray);

    PATH NAME MANAGEMENT

        uint GenPathsNV(sizei range);
        void DeletePathsNV(uint path, sizei range);
        boolean IsPathNV(uint path);

    PATH STENCILING

        void PathStencilFuncNV(enum func, int ref, uint mask);
        void PathStencilDepthOffsetNV(float factor, float units);

        void StencilFillPathNV(uint path,
                               enum fillMode, uint mask);

        void StencilStrokePathNV(uint path,
                                 int reference, uint mask);

        void StencilFillPathInstancedNV(sizei numPaths,
                                        enum pathNameType, const void *paths,
                                        uint pathBase,
                                        enum fillMode, uint mask,
                                        enum transformType,
                                        const float *transformValues);

        void StencilStrokePathInstancedNV(sizei numPaths,
                                          enum pathNameType, const void *paths,
                                          uint pathBase,
                                          int reference, uint mask,
                                          enum transformType,
                                          const float *transformValues);

    PATH COVERING

        void PathCoverDepthFuncNV(enum zfunc);

        void PathColorGenNV(enum color,
                            enum genMode,
                            enum colorFormat, const float *coeffs);
        void PathTexGenNV(enum texCoordSet,
                          enum genMode,
                          int components, const float *coeffs);
        void PathFogGenNV(enum genMode);

        void CoverFillPathNV(uint path, enum coverMode);

        void CoverStrokePathNV(uint path, enum coverMode);

        void CoverFillPathInstancedNV(sizei numPaths,
                                      enum pathNameType, const void *paths,
                                      uint pathBase,
                                      enum coverMode,
                                      enum transformType,
                                      const float *transformValues);

        void CoverStrokePathInstancedNV(sizei numPaths,
                                        enum pathNameType, const void *paths,
                                        uint pathBase,
                                        enum coverMode,
                                        enum transformType,
                                        const float *transformValues);

    PATH STENCILING THEN COVERING

        void StencilThenCoverFillPathNV(uint path, enum fillMode,
                                        uint mask, enum coverMode);
        void StencilThenCoverStrokePathNV(uint path, int reference,
                                          uint mask, enum coverMode);
        void StencilThenCoverFillPathInstancedNV(sizei numPaths,
                                                 enum pathNameType,
                                                 const void *paths,
                                                 uint pathBase,
                                                 enum fillMode, uint mask,
                                                 enum coverMode,
                                                 enum transformType,
                                                 const float *transformValues);
        void StencilThenCoverStrokePathInstancedNV(sizei numPaths,
                                                   enum pathNameType,
                                                   const void *paths,
                                                   uint pathBase,
                                                   int reference, uint mask,
                                                   enum coverMode,
                                                   enum transformType,
                                                   const float *transformValues);

    PATH COVERING OF GLSL FRAGMENT INPUTS

        void ProgramPathFragmentInputGenNV(uint program,
                                           int location,
                                           enum genMode,
                                           int components,
                                           const float *coeffs);

    PATH QUERIES

        void GetPathParameterivNV(uint path, enum pname, int *value);
        void GetPathParameterfvNV(uint path, enum pname, float *value);

        void GetPathCommandsNV(uint path, ubyte *commands);
        void GetPathCoordsNV(uint path, float *coords);
        void GetPathDashArrayNV(uint path, float *dashArray);

        void GetPathMetricsNV(bitfield metricQueryMask,
                              sizei numPaths,
                              enum pathNameType, const void *paths,
                              uint pathBase,
                              sizei stride,
                              float *metrics);
        void GetPathMetricRangeNV(bitfield metricQueryMask,
                                  uint firstPathName,
                                  sizei numPaths,
                                  sizei stride,
                                  float *metrics);

        void GetPathSpacingNV(enum pathListMode,
                              sizei numPaths,
                              enum pathNameType, const void *paths,
                              uint pathBase,
                              float advanceScale,
                              float kerningScale,
                              enum transformType,
                              float *returnedSpacing);

        void GetPathColorGenivNV(enum color, enum pname, int *value);
        void GetPathColorGenfvNV(enum color, enum pname, float *value);
        void GetPathTexGenivNV(enum texCoordSet, enum pname, int *value);
        void GetPathTexGenfvNV(enum texCoordSet, enum pname, float *value);

        boolean IsPointInFillPathNV(uint path,
                                    uint mask, float x, float y);
        boolean IsPointInStrokePathNV(uint path,
                                      float x, float y);

        float GetPathLengthNV(uint path,
                              sizei startSegment, sizei numSegments);

        boolean PointAlongPathNV(uint path,
                                 sizei startSegment, sizei numSegments,
                                 float distance,
                                 float *x, float *y,
                                 float *tangentX, float *tangentY);

    MATRIX SPECIFICATION

        void MatrixLoad3x2fNV(enum matrixMode, const float *m);
        void MatrixLoad3x3fNV(enum matrixMode, const float *m);
        void MatrixLoadTranspose3x3fNV(enum matrixMode, const float *m);

        void MatrixMult3x2fNV(enum matrixMode, const float *m);
        void MatrixMult3x3fNV(enum matrixMode, const float *m);
        void MatrixMultTranspose3x3fNV(enum matrixMode, const float *m);

    FLOATING-POINT PROGRAM RESOURCE QUERY

        void GetProgramResourcefvNV(uint program, enum programInterface,
                                    uint index, sizei propCount,
                                    const enum *props, sizei bufSize,
                                    sizei *length, float *params);

New Tokens


        CLOSE_PATH_NV                                   0x00
        MOVE_TO_NV                                      0x02
        RELATIVE_MOVE_TO_NV                             0x03
        LINE_TO_NV                                      0x04
        RELATIVE_LINE_TO_NV                             0x05
        HORIZONTAL_LINE_TO_NV                           0x06
        RELATIVE_HORIZONTAL_LINE_TO_NV                  0x07
        VERTICAL_LINE_TO_NV                             0x08
        RELATIVE_VERTICAL_LINE_TO_NV                    0x09
        QUADRATIC_CURVE_TO_NV                           0x0A
        RELATIVE_QUADRATIC_CURVE_TO_NV                  0x0B
        CUBIC_CURVE_TO_NV                               0x0C
        RELATIVE_CUBIC_CURVE_TO_NV                      0x0D
        SMOOTH_QUADRATIC_CURVE_TO_NV                    0x0E
        RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV           0x0F
        SMOOTH_CUBIC_CURVE_TO_NV                        0x10
        RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV               0x11
        SMALL_CCW_ARC_TO_NV                             0x12
        RELATIVE_SMALL_CCW_ARC_TO_NV                    0x13
        SMALL_CW_ARC_TO_NV                              0x14
        RELATIVE_SMALL_CW_ARC_TO_NV                     0x15
        LARGE_CCW_ARC_TO_NV                             0x16
        RELATIVE_LARGE_CCW_ARC_TO_NV                    0x17
        LARGE_CW_ARC_TO_NV                              0x18
        RELATIVE_LARGE_CW_ARC_TO_NV                     0x19
        CONIC_CURVE_TO_NV                               0x1A
        RELATIVE_CONIC_CURVE_TO_NV                      0x1B
        ROUNDED_RECT_NV                                 0xE8
        RELATIVE_ROUNDED_RECT_NV                        0xE9
        ROUNDED_RECT2_NV                                0xEA
        RELATIVE_ROUNDED_RECT2_NV                       0xEB
        ROUNDED_RECT4_NV                                0xEC
        RELATIVE_ROUNDED_RECT4_NV                       0xED
        ROUNDED_RECT8_NV                                0xEE
        RELATIVE_ROUNDED_RECT8_NV                       0xEF
        RESTART_PATH_NV                                 0xF0
        DUP_FIRST_CUBIC_CURVE_TO_NV                     0xF2
        DUP_LAST_CUBIC_CURVE_TO_NV                      0xF4
        RECT_NV                                         0xF6
        RELATIVE_RECT_NV                                0xF7
        CIRCULAR_CCW_ARC_TO_NV                          0xF8
        CIRCULAR_CW_ARC_TO_NV                           0xFA
        CIRCULAR_TANGENT_ARC_TO_NV                      0xFC
        ARC_TO_NV                                       0xFE
        RELATIVE_ARC_TO_NV                              0xFF


        PATH_FORMAT_SVG_NV                              0x9070
        PATH_FORMAT_PS_NV                               0x9071


        STANDARD_FONT_NAME_NV                           0x9072
        SYSTEM_FONT_NAME_NV                             0x9073
        FILE_NAME_NV                                    0x9074


        STANDARD_FONT_FORMAT_NV                         0x936C


        SKIP_MISSING_GLYPH_NV                           0x90A9
        USE_MISSING_GLYPH_NV                            0x90AA


        FONT_GLYPHS_AVAILABLE_NV                        0x9368
        FONT_TARGET_UNAVAILABLE_NV                      0x9369
        FONT_UNAVAILABLE_NV                             0x936A
        FONT_UNINTELLIGIBLE_NV                          0x936B  // once was FONT_CORRUPT_NV


        PATH_STROKE_WIDTH_NV                            0x9075
        PATH_INITIAL_END_CAP_NV                         0x9077
        PATH_TERMINAL_END_CAP_NV                        0x9078
        PATH_JOIN_STYLE_NV                              0x9079
        PATH_MITER_LIMIT_NV                             0x907A
        PATH_INITIAL_DASH_CAP_NV                        0x907C
        PATH_TERMINAL_DASH_CAP_NV                       0x907D
        PATH_DASH_OFFSET_NV                             0x907E
        PATH_CLIENT_LENGTH_NV                           0x907F
        PATH_DASH_OFFSET_RESET_NV                       0x90B4

        PATH_FILL_MODE_NV                               0x9080
        PATH_FILL_MASK_NV                               0x9081
        PATH_FILL_COVER_MODE_NV                         0x9082
        PATH_STROKE_COVER_MODE_NV                       0x9083
        PATH_STROKE_MASK_NV                             0x9084
        PATH_STROKE_BOUND_NV                            0x9086


        PATH_END_CAPS_NV                                0x9076
        PATH_DASH_CAPS_NV                               0x907B


        COUNT_UP_NV                                     0x9088
        COUNT_DOWN_NV                                   0x9089


        PRIMARY_COLOR                                   0x8577  // from OpenGL 1.3
        PRIMARY_COLOR_NV                                0x852C  // from NV_register_combiners
        SECONDARY_COLOR_NV                              0x852D  // from NV_register_combiners


        PATH_OBJECT_BOUNDING_BOX_NV                     0x908A


        CONVEX_HULL_NV                                  0x908B
        BOUNDING_BOX_NV                                 0x908D




        TRANSLATE_X_NV                                  0x908E
        TRANSLATE_Y_NV                                  0x908F
        TRANSLATE_2D_NV                                 0x9090
        TRANSLATE_3D_NV                                 0x9091
        AFFINE_2D_NV                                    0x9092
        AFFINE_3D_NV                                    0x9094
        TRANSPOSE_AFFINE_2D_NV                          0x9096
        TRANSPOSE_AFFINE_3D_NV                          0x9098




        UTF8_NV                                         0x909A
        UTF16_NV                                        0x909B


        BOUNDING_BOX_OF_BOUNDING_BOXES_NV               0x909C




        PATH_COMMAND_COUNT_NV                           0x909D
        PATH_COORD_COUNT_NV                             0x909E
        PATH_DASH_ARRAY_COUNT_NV                        0x909F

        PATH_COMPUTED_LENGTH_NV                         0x90A0

        PATH_FILL_BOUNDING_BOX_NV                       0x90A1
        PATH_STROKE_BOUNDING_BOX_NV                     0x90A2


        SQUARE_NV                                       0x90A3
        ROUND_NV                                        0x90A4
        TRIANGULAR_NV                                   0x90A5


        BEVEL_NV                                        0x90A6
        MITER_REVERT_NV                                 0x90A7
        MITER_TRUNCATE_NV                               0x90A8


        MOVE_TO_RESETS_NV                               0x90B5
        MOVE_TO_CONTINUES_NV                            0x90B6


        BOLD_BIT_NV                                     0x01
        ITALIC_BIT_NV                                   0x02


        PATH_ERROR_POSITION_NV                          0x90AB

        PATH_FOG_GEN_MODE_NV                            0x90AC

        PATH_STENCIL_FUNC_NV                            0x90B7
        PATH_STENCIL_REF_NV                             0x90B8
        PATH_STENCIL_VALUE_MASK_NV                      0x90B9

        PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV             0x90BD
        PATH_STENCIL_DEPTH_OFFSET_UNITS_NV              0x90BE

        PATH_COVER_DEPTH_FUNC_NV                        0x90BF


        GLYPH_WIDTH_BIT_NV                              0x01
        GLYPH_HEIGHT_BIT_NV                             0x02
        GLYPH_HORIZONTAL_BEARING_X_BIT_NV               0x04
        GLYPH_HORIZONTAL_BEARING_Y_BIT_NV               0x08
        GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV         0x10
        GLYPH_VERTICAL_BEARING_X_BIT_NV                 0x20
        GLYPH_VERTICAL_BEARING_Y_BIT_NV                 0x40
        GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV           0x80
        GLYPH_HAS_KERNING_BIT_NV                        0x100

        FONT_X_MIN_BOUNDS_BIT_NV                        0x00010000
        FONT_Y_MIN_BOUNDS_BIT_NV                        0x00020000
        FONT_X_MAX_BOUNDS_BIT_NV                        0x00040000
        FONT_Y_MAX_BOUNDS_BIT_NV                        0x00080000
        FONT_UNITS_PER_EM_BIT_NV                        0x00100000
        FONT_ASCENDER_BIT_NV                            0x00200000
        FONT_DESCENDER_BIT_NV                           0x00400000
        FONT_HEIGHT_BIT_NV                              0x00800000
        FONT_MAX_ADVANCE_WIDTH_BIT_NV                   0x01000000
        FONT_MAX_ADVANCE_HEIGHT_BIT_NV                  0x02000000
        FONT_UNDERLINE_POSITION_BIT_NV                  0x04000000
        FONT_UNDERLINE_THICKNESS_BIT_NV                 0x08000000
        FONT_HAS_KERNING_BIT_NV                         0x10000000
        FONT_NUM_GLYPH_INDICES_BIT_NV                   0x20000000


        ACCUM_ADJACENT_PAIRS_NV                         0x90AD
        ADJACENT_PAIRS_NV                               0x90AE
        FIRST_TO_REST_NV                                0x90AF


        PATH_GEN_MODE_NV                                0x90B0
        PATH_GEN_COEFF_NV                               0x90B1


        PATH_GEN_COLOR_FORMAT_NV                        0x90B2


        PATH_GEN_COMPONENTS_NV                          0x90B3


        FRAGMENT_INPUT_NV                               0x936D





