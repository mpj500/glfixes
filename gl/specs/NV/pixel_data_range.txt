Name

    NV_pixel_data_range

Name Strings

    GL_NV_pixel_data_range

Contact

    Matt Craighead, NVIDIA Corporation (mcraighead 'at' nvidia.com)

Notice

    Copyright NVIDIA Corporation, 2000, 2001, 2002.

IP Status

    NVIDIA Proprietary.

Status

    Shipping (version 1.0)

Version

    NVIDIA Date: November 7, 2002 (version 1.0)

Number

    284

Dependencies

    Written based on the wording of the OpenGL 1.3 specification.

    If this extension is implemented, the WGL or GLX memory allocator
    interface specified in NV_vertex_array_range must also be
    implemented.  Please refer to the NV_vertex_array_range specification
    for further information on this interface.

Overview

    The vertex array range extension is intended to improve the
    efficiency of OpenGL vertex arrays.  OpenGL vertex arrays' coherency
    model and ability to access memory from arbitrary locations in memory
    prevented implementations from using DMA (Direct Memory Access)
    operations.

    Many image-intensive applications, such as those that use dynamically
    generated textures, face similar problems.  These applications would
    like to be able to sustain throughputs of hundreds of millions of
    pixels per second through DrawPixels and hundreds of millions of
    texels per second through TexSubImage.

    However, the same restrictions that limited vertex throughput also
    limit pixel throughput.

    By the time that any pixel operation that reads data from user memory
    returns, OpenGL requires that it must be safe for the application to
    start using that memory for a different purpose.  This coherency
    model prevents asynchronous DMA transfers directly out of the user's
    buffer.

    There are also no restrictions on the pointer provided to pixel
    operations or on the size of the data.  To facilitate DMA
    implementations, the driver needs to know in advance what region of
    the address space to lock down.

    Vertex arrays faced both of these restrictions already, but pixel
    operations have one additional complicating factor -- they are
    bidirectional.  Vertex array data is always being transfered from the
    application to the driver and the HW, whereas pixel operations
    sometimes transfer data to the application from the driver and HW.
    Note that the types of memory that are suitable for DMA for reading
    and writing purposes are often different.  For example, on many PC
    platforms, DMA pulling is best accomplished with write-combined
    (uncached) AGP memory, while pushing data should use cached memory so
    that the application can read the data efficiently once it has been
    read back over the AGP bus.

    This extension defines an API where an application can specify two
    pixel data ranges, which are analogous to vertex array ranges, except
    that one is for operations where the application is reading data
    (e.g. glReadPixels) and one is for operations where the application
    is writing data (e.g. glDrawPixels, glTexSubImage2D, etc.).  Each
    pixel data range has a pointer to its start and a length in bytes.

    When the pixel data range is enabled, and if the pointer specified
    as the argument to a pixel operation is inside the corresponding
    pixel data range, the implementation may choose to asynchronously
    pull data from the pixel data range or push data to the pixel data
    range.  Data pulled from outside the pixel data range is undefined,
    while pushing data to outside the pixel data range produces undefined
    results.

    The application may synchronize with the hardware in one of two ways:
    by flushing the pixel data range (or causing an implicit flush) or by
    using the NV_fence extension to insert fences in the command stream.

Issues

    *   The vertex array range extension required that all active vertex
        arrays must be located inside the vertex array range.  Should
        this extension be equally strict?

        RESOLVED: No, because a user may want to use the pixel data range
        for one type of operation (say, texture downloads) but still be
        able to use standard non-PDR pixel operations for everything
        else.  Requiring that apps disable PDR every time such an
        operation occurs would be burdensome and make it difficult to
        integrate this extension into a larger app with minimal changes.
        So, for each pixel operation, we will look at the pointer
        provided by the application.  If it's inside the PDR, the PDR
        rules apply, and if it's not inside the PDR, it's a standard GL
        pixel operation, even if some of the data is actually inside the
        PDR.

    *   Reads and writes may require different types of memory.  How do
        we handle this?

        RESOLVED: The allocator interface already provides the ability to
        specify different read and write frequencies.  A buffer for a
        write PDR should probably be allocated with a high write
        frequency and low read frequency, while a read PDR's buffer
        should have a low write and high read frequency.

        Having two PDRs is essential because a single application may
        want to perform both asynchronous reads and writes
        simultaneously.

    *   What happens if a PDR pixel operation pulls data from a location
        outside the PDR?

        RESOLVED: The data pulled is undefined, and program termination
        may result.

    *   What happens if a PDR pixel operation pushes data to a location
        outside the PDR?

        RESOLVED: The contents of that memory location become undefined,
        and program termination may result.

    *   What happens if the hardware can't support the operation?

        RESOLVED: The operation may be slow, because we may need to, for
        example, read the pixel data out of uncached memory with the CPU,
        but it should still work.  So this should never be a problem; in
        fact, it means that a basic implementation that accelerates only,
        say, one operation is quite trivial.

    *   Should there be any limitations to what operations should be
        supported?

        RESOLVED: No, in theory any pixel operation that accesses a
        user's buffer can work with PDR.  This includes Bitmap,
        PolygonStipple, GetTexImage, ConvolutionFilter2D, etc.  Many are
        unlikely to be accelerated, but there is no reason to place
        arbitrary restrictions.  A list of possibly supported operations
        is provided for OpenGL 1.2.1 with ARB_imaging support and for all
        the extensions currently supported by NVIDIA.  Developers should
        carefully read the Implementation Details provided by their
        vendor before using the extension.

    *   Should PixelMap and GetPixelMap be supported?

        RESOLVED: Yes.  They're not really pixel path operations, but,
        again, there is no good reason to omit operations, and they _are_
        operations that pass around big chunks of pixel-related data.  If
        we support PolygonStipple, surely we should support this.

    *   Can the PDRs and the VAR overlap and/or be the same buffer?

        RESOLVED: Yes.  In fact, it is expected that one of the preferred
        modes of usage for this extension will be to use the same AGP
        buffer for both the write PDR and the VAR, so it can be used for
        both dynamic texturing and dynamic geometry.

    *   Can video memory buffers be used?

        RESOLVED: Yes, assuming the implementation supports using them
        for PDR.  On systems with AGP Fast Writes, this may be
        interesting in some cases.  Another possible use for this is to
        treat a video memory buffer as an offscreen surface, where
        DrawPixels can be thought of as a blit from offscreen memory to
        a GL surface, and ReadPixels can be thought of as a blit from a
        GL surface to offscreen memory.  This technique should be used
        with caution, because there are other alternatives, such as
        pbuffers, aux buffers, and even textures.

    *   Do we want to support more than one read and one write PDR?

        RESOLVED: No, but I could imagine uses for it.  For example, an
        app could use two system memory buffers (one read, one write PDR)
        and a single video memory buffer (both read and write).  Do we
        need a scheme where an unlimited number of PDR buffers can be
        specified?  Ugh.  I hope not.  I can't think of a good reason to
        use more than 3 buffers, and even that is stretching it.

    *   Do we want a separate enable for both the read and write PDR?

        RESOLVED: Yes.  In theory, they are completely independent, and
        we should treat them as such.

    *   Is there an equivalent to the VAR validity check?

        RESOLVED: No.  When a vertex array call occurs, all the vertex
        array state is already set.  We can know in advance whether all
        the pointers, strides, etc. are set up in a satisfactory way.
        However, for a pixel operation, much of the state is provided on
        the same function call that performs the operation.  For example,
        the pixel format of the data may need to match that of the
        framebuffer.  We can't know this without looking at the format
        and type arguments.

        An alternative might be some sort of "proxy" mechanism for pixel
        operations, but this seems to be very complicated.

    *   Do we want a more generalized API?  What stops us from needing a
        DMA extension for every single conceivable use in the future?

        RESOLVED: No, this is good enough.  Since new extensions will
        probably require new semantics anyhow, we'll just live with that.
        Maybe if the ARB wants to create a more generic "DMA" extension,
        these issues can be revisited.

    *   How do applications synchronize with the hardware?

        RESOLVED: A new command, FlushPixelDataRangeNV, is provided, that
        is analogous to FlushVertexArrayRangeNV.  Applications can also
        use the Finish command.  The NV_fence extension is best for
        applications that need fine-grained synchronization.

    *   Should enabling or disabling a PDR induce an implicit PDR flush?

        RESOLVED: No.  In the VAR extension, enabling and disabling the
        VAR does induce a VAR flush, but this has proven to be more
        problematic than helpful, because it makes it much more difficult
        to switch between VAR and non-VAR rendering; the VAR2 extension
        lifts this restriction, and there is no reason to get this wrong
        a second time.

        The PDR extension does not suffer from the problem of enabling
        and disabling frequently, because non-PDR operations are
        permitted simply by providing a pointer outside of the PDR, but
        there is no clear reason why the enable or disable should cause
        a quite unnecessary PDR flush.

    *   Should this state push/pop?

        RESOLVED: Yes, but via a Push/PopClientAttrib and the
        GL_CLIENT_PIXEL_STORE_BIT bit.  Although this is heavyweight
        state, VAR also allowed push/pop.  It does fit nicely into an
        existing category, too.

    *   Should making another context current cause a PDR flush?

        RESOLVED: No.  There's no fundamental reason it should.  Note
        that apps should be careful to not free their memory until the
        hardware is not using it... note also that this decision is
        inconsistent with VAR, which did guarantee a flush here.

    *   Is the read PDR guaranteed to give you either old or new values,
        or is it truly undefined?

        RESOLVED: Undefined.  This may ease implementation constraints
        slightly.  Apps must not rely at all on the contents of the
        region where the readback is occurring until it is known to be
        finished.

        An example of how an implementation might conceivably require
        this is as follows.  Suppose that a piece of hardware, for some
        reason, can only write full 32-byte chunks of data.  Any bytes
        that were supposed to be unwritten are in fact trashed by the
        hardware, filled with garbage.  By careful fixups (read the
        contents before the operation, restore when done), the driver may
        be able to hide this fact, but a requirement that either new or
        old data must show up would be violated.

        Or, more trivially, you might implement certain pixel operations
        as an in-place postprocess on the returned data.

        It is not anticipated that NVIDIA implementations will need this
        flexibility, but it is nevertheless provided.

    *   How should an application allocate its PDR memory?

        The app should use wglAllocateMemoryNV, even for a read PDR in
        system memory.  Using malloc may result in suboptimal
        performance, because the driver will not be able to choose an
        optimal memory type.  For ReadPixels to system memory, you might
        set a read frequency of 1.0, a write frequency of 0.0, and a
        priority of 1.0.  The driver might allocate PCI memory, or
        physically contiguous PCI memory, or cachable AGP memory, all
        depending on the performance characteristics of the device.
        While memory from malloc will work, it does not allow the driver
        to make these decisions, and it will certainly never give you AGP
        memory.

        Write PDR memory for purposes of streaming textures, etc. works
        exactly the same as VAR memory for streaming vertices.  You can,
        and in fact are encouraged to, use the same circular buffer for
        both vertices and textures.

        If you have different needs (not just streaming textures or
        asynchronous readbacks), you may want your pixel data in video
        memory.

New Procedures and Functions

    void PixelDataRangeNV(enum target, sizei length, void *pointer)
    void FlushPixelDataRangeNV(enum target)

New Tokens


        WRITE_PIXEL_DATA_RANGE_NV                      0x8878
        READ_PIXEL_DATA_RANGE_NV                       0x8879


        WRITE_PIXEL_DATA_RANGE_LENGTH_NV               0x887A
        READ_PIXEL_DATA_RANGE_LENGTH_NV                0x887B


        WRITE_PIXEL_DATA_RANGE_POINTER_NV              0x887C
        READ_PIXEL_DATA_RANGE_POINTER_NV               0x887D

