Name
    
    NV_texture_shader

Name Strings

    GL_NV_texture_shader

Contact

    Mark J. Kilgard, NVIDIA Corporation (mjk 'at' nvidia.com)

Notice

    Copyright NVIDIA Corporation, 1999, 2000, 2001, 2002, 2004.

IP Status

    NVIDIA Proprietary.

Status

    Shipping (since GeForce3)

Version

    NVIDIA Date:  March 13, 2007
    Version:      30

Number

    230

Dependencies

    Written based on the wording of the OpenGL 1.2.1 specification.

    Requires support for the ARB_multitexture extension.

    Requires support for the ARB_texture_cube_map extension.

    NV_register_combiners affects the definition of this extension.

    EXT_texture_lod_bias trivially affects the definition of this
    extension.

    ARB_texture_env_combine and/or EXT_texture_env_combine affect the
    definition of this extension.

    NV_texture_env_combine4 affects the definition of this extension.

    ARB_texture_env_add and/or EXT_texture_env_add affect the definition
    of this extension.

    NV_texture_rectangle affects the definition of this extension.

    NV_texture_shader2 depends on the definition of this extension.

    ARB_color_buffer_float affects the definiton of this extension.

Overview

    Standard OpenGL and the ARB_multitexture extension define a
    straightforward direct mechanism for mapping sets of texture
    coordinates to filtered colors.  This extension provides a more
    functional mechanism.

    OpenGL's standard texturing mechanism defines a set of texture
    targets.  Each texture target defines how the texture image
    is specified and accessed via a set of texture coordinates.
    OpenGL 1.0 defines the 1D and 2D texture targets.  OpenGL 1.2
    (and/or the EXT_texture3D extension) defines the 3D texture target.
    The ARB_texture_cube_map extension defines the cube map texture
    target.  Each texture unit's texture coordinate set is mapped to a
    color using the unit's highest priority enabled texture target.

    This extension introduces texture shader stages.  A sequence of
    texture shader stages provides a more flexible mechanism for mapping
    sets of texture coordinates to texture unit RGBA results than standard
    OpenGL.

    When the texture shader enable is on, the extension replaces the
    conventional OpenGL mechanism for mapping sets of texture coordinates
    to filtered colors with this extension's sequence of texture shader
    stages.  

    Each texture shader stage runs one of 21 canned texture shader
    programs.  These programs support conventional OpenGL texture
    mapping but also support dependent texture accesses, dot product
    texture programs, and special modes.  (3D texture mapping
    texture shader operations are NOT provided by this extension;
    3D texture mapping texture shader operations are added by the
    NV_texture_shader2 extension that is layered on this extension.
    See the NV_texture_shader2 specification.)

    To facilitate the new texture shader programs, this extension
    introduces several new texture formats and variations on existing
    formats.  Existing color texture formats are extended by introducing
    new signed variants.  Two new types of texture formats (beyond colors)
    are also introduced.  Texture offset groups encode two signed offsets,
    and optionally a magnitude or a magnitude and an intensity.  The new
    HILO (pronounced high-low) formats provide possibly signed, high
    precision (16-bit) two-component textures.

    Each program takes as input the stage's interpolated texture
    coordinate set (s,t,r,q).  Each program generates two results:
    a shader stage result that may be used as an input to subsequent
    shader stage programs, and a texture unit RGBA result that becomes the
    texture color used by the texture unit's texture environment function
    or becomes the initial value for the corresponding texture register
    for register combiners. The texture unit RGBA result is always
    an RGBA color, but the shader stage result may be one of an RGBA
    color, a HILO value, a texture offset group, a floating-point value,
    or an invalid result.  When both results are RGBA colors, the shader
    stage result and the texture unit RGBA result are usually identical
    (though not in all cases).

    Additionally, certain programs have a side-effect such as culling
    the fragment or replacing the fragment's depth value.

    The twenty-one programs are briefly described:

    <none>

    1.   NONE - Always generates a (0,0,0,0) texture unit RGBA result.
         Equivalent to disabling all texture targets in conventional
         OpenGL.

    <conventional textures>

    2.   TEXTURE_1D - Accesses a 1D texture via (s/q).

    3.   TEXTURE_2D - Accesses a 2D texture via (s/q,t/q).

    4.   TEXTURE_RECTANGLE_NV - Accesses a rectangular texture via (s/q,t/q).

    5.   TEXTURE_CUBE_MAP_ARB - Accesses a cube map texture via (s,t,r).

    <special modes>

    6.   PASS_THROUGH_NV - Converts a texture coordinate (s,t,r,q)
         directly to a [0,1] clamped (r,g,b,a) texture unit RGBA result.

    7.   CULL_FRAGMENT_NV - Culls the fragment based on the whether each
         (s,t,r,q) is "greater than or equal to zero" or "less than zero".

    <offset textures>

    8.   OFFSET_TEXTURE_2D_NV - Transforms the signed (ds,dt) components
         of a previous texture unit by a 2x2 floating-point matrix and
         then uses the result to offset the stage's texture coordinates
         for a 2D non-projective texture.

    9.   OFFSET_TEXTURE_2D_SCALE_NV - Same as above except the magnitude
         component of the previous texture unit result scales the red,
         green, and blue components of the unsigned RGBA texture 2D
         access.

    10.  OFFSET_TEXTURE_RECTANGLE_NV - Similar to OFFSET_TEXTURE_2D_NV
         except that the texture access is into a rectangular
         non-projective texture.

    11.  OFFSET_TEXTURE_RECTANGLE_SCALE_NV - Similar to
         OFFSET_TEXTURE_2D_SCALE_NV except that the texture access is
         into a rectangular non-projective texture.

    <dependent textures>

    12.  DEPENDENT_AR_TEXTURE_2D_NV - Converts the alpha and red
         components of a previous shader result into an (s,t) texture
         coordinate set to access a 2D non-projective texture.

    13.  DEPENDENT_GB_TEXTURE_2D_NV - Converts the green and blue
         components of a previous shader result into an (s,t) texture
         coordinate set to access a 2D non-projective texture.

    <dot product textures>

    14.  DOT_PRODUCT_NV - Computes the dot product of the texture
         shader's texture coordinate set (s,t,r) with some mapping of the
         components of a previous texture shader result.  The component
         mapping depends on the type (RGBA or HILO) and signedness of
         the stage's previous texture input.  Other dot product texture
         programs use the result of this program to compose a texture
         coordinate set for a dependent texture access.  The color result
         is undefined.

    15.  DOT_PRODUCT_TEXTURE_2D_NV - When preceded by a DOT_PRODUCT_NV
         program in the previous texture shader stage, computes a second
         similar dot product and composes the two dot products into (s,t)
         texture coordinate set to access a 2D non-projective texture.

    16.  DOT_PRODUCT_TEXTURE_RECTANGLE_NV - Similar to
         DOT_PRODUCT_TEXTURE_2D_NV except that the texture acces is into
         a rectangular non-projective texture.  

    17.  DOT_PRODUCT_TEXTURE_CUBE_MAP_NV - When preceded by two
         DOT_PRODUCT_NV programs in the previous two texture shader
         stages, computes a third similar dot product and composes the
         three dot products into (s,t,r) texture coordinate set to access
         a cube map texture.

    18.  DOT_PRODUCT_REFLECT_CUBE_MAP_NV - When preceded by two
         DOT_PRODUCT_NV programs in the previous two texture shader
         stages, computes a third similar dot product and composes the
         three dot products into a normal vector (Nx,Ny,Nz).  An eye
         vector (Ex,Ey,Ez) is composed from the q texture coordinates of
         the three stages.  A reflection vector (Rx,Ry,Rz) is computed
         based on the normal and eye vectors.  The reflection vector
         forms an (s,t,r) texture coordinate set to access a cube map
         texture.

    19.  DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV - Operates like
         DOT_PRODUCT_REFLECT_CUBE_MAP_NV except that the eye vector
         (Ex,Ey,Ez) is a user-defined constant rather than composed from
         the q coordinates of the three stages.

    20.  DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV - When used instead of the second
         DOT_PRODUCT_NV program preceding
         a DOT_PRODUCT_REFLECT_CUBE_MAP_NV or
         DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV stage, the normal
         vector forms an (s,t,r) texture  coordinate set to access a
         cube map texture.

    <dot product depth replace>

    21.  DOT_PRODUCT_DEPTH_REPLACE_NV - When preceded by a DOT_PRODUCT_NV
         program in the previous texture shader stage, computes a second
         similar dot product and replaces the fragment's window-space
         depth value with the first dot product results divided by
         the second.  The texture unit RGBA result is (0,0,0,0).

Issues

    What should this extension be called?  How does the functionality
    compare with DirectX 8's pixel shaders?
      
      RESOLUTION:  This extension is called NV_texture_shader.

      DirectX 8 refers to its similar functionality as "pixel shaders".
      However, DirectX 8 lumps both the functionality described in this
      extension and additional functionality similar to the functionality
      in the NV_register_combiners extension together into what DirectX
      8 calls pixel shaders.  This is confusing in two ways.

      1)  Pixels are not being shaded.  In fact, the DirectX 8 pixel
          shaders functionality is, taken as a whole, shading only
          fragments (though Direct3D tends not to make the same
          clear distinction between fragments and pixels that OpenGL
          consistently makes).

      2)  There are two very distinct tasks being performed.

          First, there is the task of interpolated texture coordinate
          mapping.  This per-fragment task maps from interpolated
          floating-point texture coordinate sets to (typically
          fixed-point) texture unit RGBA results.  In conventional OpenGL,
          this mapping is performed by accessing the highest priority
          enabled texture target using the fragment's corresponding
          interpolated texture coordinate set.  This NV_texture_shader
          extension provides a significantly more powerful mechanism
          for performing this mapping.

          Second, there is the task of fragment coloring.  Fragment
          coloring is process of combining (typically fixed-point) RGBA
          colors to generate a final fragment color that, assuming the
          fragment is not discarded by subsequent per-fragment tests,
          is used to update the fragment's corresponding pixel in the
          frame buffer.  In conventional OpenGL, fragment coloring is
          performed by the enabled texture environment functions, fog, and
          color sum operations.  NVIDIA's register combiners functionality
          (see the NV_register_combiners and NV_register_combiners2
          extensions) provides a substantially more powerful alternative
          to conventional OpenGL fragment coloring.

      DirectX 8 has two types of opcodes for pixel shaders.  Texture
      address opcodes correspond to the first task listed above.  Texture
      register opcodes correspond to the second task listed above.

      NVIDIA OpenGL extensions maintain a clear distinction between
      these two tasks.  The texture shaders functionality described in
      this specification corresponds to the first task listed above.

      Here is the conceptual framework that NVIDIA OpenGL extensions use
      to describe shading:  Shading is the process of assigning colors
      to pixels, fragments, or texels.  The texture shaders functionality
      assigns colors to texture unit results (essentially texture
      shading).  These texture unit RGBA results can be used by fragment
      coloring (fragment shading).  The resulting fragments are used to
      update pixels (pixel shading) possibly via blending and/or multiple
      rendering passes.

      The goal of these individual shading operations is per-pixel
      shading.  Per-pixel shading is accomplished by combining the
      texture shading, fragment shading, and pixel shading operations,
      possibly with multiple rendering passes.

      Programmable shading is a style of per-pixel shading where the
      shading operations are expressed in a higher level of abstraction
      than "raw" OpenGL texture, fragment, and pixel shading operations.
      In our view, programmable shading does not necessarily require a
      "pixel program" to be downloaded and executed per-pixel by graphics
      hardware.  Indeed, there are many disadvantages to such an approach
      in practice.  An alternative view of programmable shading (the
      one that we are promoting) treats the OpenGL primitive shading
      operations as a SIMD machine and decomposes per-pixel shading
      programs into one or more OpenGL rendering passes that map to "raw"
      OpenGL shading operations.  We believe that conventional OpenGL
      combined with NV_register_combiners and NV_texture_shader (and
      further augmented by programmable geometry via NV_vertex_program
      and higher-order surfaces via NV_evaluators) can become the hardware
      basis for a powerful programmable shading system.

      The roughly equivalent functionality to DirectX 8's pixel
      shaders in OpenGL is the combination of NV_texture_shader with
      NV_register_combiners.

    Is anyone working on programmable shading using the NV_texture_shader
    functionality?

      Yes.  The Stanford Shading Group is actively working on
      support for programmable shading using NV_texture_shader,
      NV_register_combiners, and other extensions as the hardware basis
      for such a system.

    What terms are important to this specification?

      texture shaders - A series of texture shader stages that map texture
      coordinate sets to texture unit RGBA results.  An alternative to
      conventional OpenGL texturing.

      texture coordinate set - The interpolated (s,t,r,q) value for a
      particular texture unit of a particular fragment.

      conventional OpenGL texturing - The conventional mechanism used by
      OpenGL to map texture coordinate sets to texture unit RGBA results
      whereby a given texture unit's texture coordinate set is used to
      access the highest priority enabled texture target to generate
      the texture unit's RGBA result.  Conventional OpenGL texturing
      supports 1D, 2D, 3D, and cube map texture targets.  In conventional
      OpenGL texturing each texture unit operates independently.

      texture target type - One of the four texture target types:  1D, 2D,
      3D, and cube map.  (Note that NV_texture_shader does NOT provide
      support for 3D textures; the NV_texture_shader2 extension adds
      texture shader operations for 3D texture targets.)

      texture internal format - The internal format of a particular
      texture object.  For example, GL_RGBA8, GL_SIGNED_RGBA8, or
      GL_SIGNED_HILO16_NV.

      texture format type - One of the three texture format types:  RGBA,
      HILO, or texture offset group.

      texture component signedness - Whether or not a given component
      of a texture's texture internal format is signed or not.
      Signed components are clamped to the range [-1,1] while unsigned
      components are clamped to the range [0,1].

      texture shader enable - The OpenGL enable that determines whether
      the texture shader functionality (if enabled) or conventional
      OpenGL texturing functionality (if disabled) is used to map texture
      coordinate sets to texture unit RGBA results.  The enable's initial
      state is disabled.

      texture shader stage - Each texture unit has a corresponding texture
      shader stage that can be loaded with one of 21 texture shader
      operations.  Depending on the stage's texture shader operation,
      a texture shader stage uses the texture unit's corresponding
      texture coordinate set and other state including the texture shader
      results of previous texture shader stages to generate the stage's
      particular texture shader result and texture unit RGBA result.

      texture unit RGBA result - A (typically fixed-point) color result
      generated by either a texture shader or conventional OpenGL
      texturing.  This is the color that becomes the texture unit's
      texture environment function texture input or the initial value
      of the texture unit's corresponding texture register in the case
      of register combiners.

      texture shader result - The result of a texture shader stage that
      may be used as an input to a subsequent texture shader stage.
      This result is distinct from the texture unit RGBA result.
      The texture shader result may be one of four types:  an RGBA
      color value, a HILO value, a texture offset group value, or a
      floating-point value.  A few texture shader operations are defined
      to always generate an invalid texture shader result.

      texture shader result type - One of the four texture shader result
      types: RGBA color, HILO, texture offset group, or floating-point.

      texture shader operation - One of 21 fixed programs that maps a
      texture unit's texture coordinate set to a texture shader result
      and a texture unit RGBA result.

      texture consistency - Whether or not the texture object for a
      given texture target is consistent.  The rules for determining
      consistency depend on the texture target and the texture object's
      filtering state.  For example, a mipmapped texture is inconsistent
      if its texture levels do not form a consistent mipmap pyramid.
      Also, a cube map texture is inconsistent if its (filterable)
      matching cube map faces do not have matching dimensions.

      texture shader stage consistency - Whether or not a texture
      shader stage is consistent or not.  The rules for determining
      texture shader stage consistency depend on the texture shader
      stage operation and the inputs upon which the texture shader
      operation depends.  For example, texture shader operations that
      depend on accessing a given texture target are not consistent
      if the given texture target is not consistent.  Also, a texture
      shader operation that depends on a particular texture shader
      result type for a previous texture shader result is not consistent
      if the previous texture shader result type is not appropriate
      or the previous texture shader stage itself is not consistent.
      If a texture shader stage is not consistent, it operates as if
      the operation is the GL_NONE operation.

      previous texture input - Some texture shader operations depend
      on a texture shader result from a specific previous texture input
      designated by the GL_PREVIOUS_TEXTURE_INPUT_NV state.

    What should the default state be?

      RESOLUTION: Texture shaders disabled with all stages set to GL_NONE.

    How is the mipmap lambda parameter computed for dependent texture fetches?

      RESOLUTION:  Very carefully.  NVIDIA's implementation details are
      NVIDIA proprietary, but mipmapping of dependent texture fetches
      is supported.

    Does this extension support so-called "bump environment mapping"?

      Something similar to DirectX 6 so-called bump environment mapping
      can be emulated with the GL_OFFSET_TEXTURE_2D_NV texture shader.

      A more correct form of bump environment mapping can be implemented
      by using the following texture shaders:

        texture unit 0: GL_TEXTURE_2D
        texture unit 1: GL_DOT_PRODUCT_NV
        texture unit 2: GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV
        texture unit 3: GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV

      Texture unit 0 should use a normal map for its 2D texture.
      A GL_SIGNED_RGB texture can encode signed tangent-space normal
      perturbations.  Or for more precision, a GL_SIGNED_HILO_NV texture
      can encode the normal perturbations in hemisphere fashion.

      The tangent (Tx,Ty,Tz), binormal (Bx,By,Bz), and normal (Nx,Ny,Nz)
      that together map tangent-space normals to cube map-space normals
      should be sent as texture coordinates s1, t1, r1, s2, t2, r2, s3,
      t3, and r3 respectively.  Typically, cube map space is aligned to
      match world space.

      The (unnormalized) cube map-space eye vector (Ex,Ey,Ez) should be
      sent as texture coordinates q1, q2, and q3 respectively.

      A vertex programs (using the NV_vertex_program extension) can
      compute and assign the required tangent, binormal, normal, and
      eye vectors to the appropriate texture coordinates.  Conventional
      OpenGL evaluators (or the NV_evaluators extension) can be used to
      evaluate the tangent and normal automatically for Bezier patches.
      The binormal is the cross product of the normal and tangent.

      Texture units 1, 2, and 3, should also all specify GL_TEXTURE0_ARB
      (the texture unit accessing the normal map) for their
      GL_PREVIOUS_TEXTURE_INPUT_NV parameter.

      The three dot product texture shader operations performed by the
      texture shaders for texture units 1, 2, and 3 form a 3x3 matrix
      that transforms the tangent-space normal (the result of the texture
      shader for texture unit 0).  This rotates the tangent-space normal
      into a cube map-space.

      Texture unit 2's cube map texture should encode a pre-computed
      diffuse lighting solution.  Texture unit 3's cube map texture should
      encode a pre-computed specular lighting solution.  The specular
      lighting solution can be an environment map.

      Texture unit 2 is accessed using the cube map-space normal
      vector resulting from the three dot product results
      of the texture shaders for texture units 1, 2, and 3.
      (While normally texture shader operations are executed
      in order, preceding GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV by
      GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV is a special case where a dot
      product result from texture unit 3 influences the cube map access
      of texture unit 2.)

      Texture unit 3 is accessed using the cube map-space reflection
      vector computed using the cube map-space normal vector from the
      three dot product results of the texture shaders for texture units
      1, 2, and 3 and the cube-map space eye-vector (q1,q2,q3).

      Note that using cube maps to access the diffuse and specular
      illumination obviates the need for an explicit normalization of
      the typically unnormalized cube map-space normal and reflection
      vectors.

      The register combiners (using the NV_register_combiners extension)
      can combine the diffuse and specular contribution available in
      the GL_TEXTURE2_ARB and GL_TEXTURE3_ARB registers respectively.
      A constant ambient contribution can be stored in a register combiner
      constant.  The ambient contribution could also be folded into the
      diffuse cube map.

      If desired, the diffuse and ambient contribution can be modulated
      by a diffuse material parameter encoded in the RGB components of
      the primary color.

      If desired, the specular contribution can be modulated by a specular
      material parameter encoded in the RGB components of the secondary
      color.

      Yes, this is all quite complicated, but the result is a true
      bump environment mapping technique with excellent accounting for
      normalization and per-vertex interpolated diffuse and specular
      materials.  An environment and/or an arbitrary number of distant
      or infinite lights can be encoded into the diffuse and specular
      cube maps.

    Why must GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV be used only in
    conjunction with GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV?  Why does the
    GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV stage rely on a result computed
    in the following stage?

      Think of the GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV and
      GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV operations as forming a compound
      operation.  The idea is to generate two cube map accesses based
      on a perturbed normal and reflection vector where the reflection
      vector is a function of the perturbed normal vector.  To minimize
      the number of stages (three stages only) and reuse the internal
      computations involved, this is treated as a compound operation.

      Note that the GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV
      vector can be preceded by two GL_DOT_PRODUCT_NV
      operations instead of a GL_DOT_PRODUCT_NV operation then a
      GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV operation.  This may be more
      efficient when only the cube map access using the reflection vector
      is required (a shiny object without any diffuse reflectance).

      Also note that if only the diffuse reflectance cube map
      access is required, this can be accomplished by simply using
      the GL_DOT_PRODUCT_CUBE_MAP_NV operation preceded by two
      GL_DOT_PRODUCT_NV operations.

    How do texture shader stages map to register combiner texture registers?

      RESOLUTION:  If GL_TEXTURE_SHADER_NV is enabled, the texture unit
      RGBA result for a each texture stage is used to initialize the
      respective texture register in the register combiners.

      So if a texture shader generates a texture unit RGBA result for
      texture unit 2, use GL_TEXTURE2_ARB for the name of the register
      value in register combiners.

    Should the number of shader stages be settable?

      RESOLUTION: No, unused stages can be set to GL_NONE.

    How do signed RGBA texture components show up in the register
    combiners texture registers?

      RESOLUTION: As signed values.  You can use GL_SIGNED_IDENTITY_NV
      and get to the signed value directly.

    How does the texture unit RGBA result of a
    GL_NONE, GL_CULL_FRAGMENT_NV, DOT_PRODUCT_NV, or
    GL_DOT_PRODUCT_DEPTH_REPLACE_NV texture shader operation show up in
    the register combiners texture registers?
     
      RESOLUTION: Always as the value (0,0,0,0).

      How the texture RGBA result of the GL_NONE, GL_CULL_FRAGMENT_NV,
      GL_DOT_PRODUCT_NV, and GL_DOT_PRODUCT_DEPTH_REPLACE_NV texture
      shader operations shows up in the texture environment is not
      an issue, because the texture environment operation is always
      assumed to be GL_NONE when the corresponding texture shader
      is one of GL_NONE, GL_CULL_FRAGMENT_NV, GL_DOT_PRODUCT_NV, or
      GL_DOT_PRODUCT_DEPTH_REPLACE_NV when GL_TEXTURE_SHADER_NV is
      enabled.

    Why introduce new pixel groups (the HILO and texture offset groups)?
    
      RESOLUTION:  In core OpenGL, texture image data is transferred and
      stored as sets of color components.  Such color data can always
      be promoted to RGBA data.

      In addition to color components, there are other types of image
      data in OpenGL including depth components, stencil components,
      and color indices.  Depth and stencil components can be used by
      glReadPixels, glDrawPixels, and glCopyPixels, but are not useful
      for storing texture data in core OpenGL.  The EXT_paletted_texture
      and EXT_index_texture extensions extend the contents of textures to
      include indices (even though in the case of EXT_paletted_texture,
      texel fetches are always eventually expanded into color components
      by the texture palette).

      However this these existing pixel groups are not sufficient for
      all the texture shader operations introduced by this extension.
      Certain texture shader operations require texture data that
      is not merely a set of color components.  The dot product
      (GL_DOT_PRODUCT_NV, etc) operations both can
      utilize high-precision hi and lo components.  The
      offset texture operations (GL_OFFSET_TEXTURE_2D_NV,
      GL_OFFSET_TEXTURE_2D_SCALE_NV, GL_OFFSET_TEXTURE_RECTANGLE_NV,
      and GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV) require
      textures containing signed offsets used to displace
      texture coordinates.  The GL_OFFSET_TEXTURE_2D_SCALE_NV and
      GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV also require an unsigned
      magnitude for the scaling operation.

      To facilitate these new texture representations, this extension
      introduces several new (external) formats, pixel groups, and
      internal texture formats.  An (external) format is the external
      representation used by an application to specify pixel data
      for use by OpenGL.  A pixel group is a grouping of components
      that are transformed by OpenGL's pixel transfer mechanism is a
      particular manner.  For example, RGBA components for colors are
      transformed differently than stencil components when passed through
      OpenGL's pixel transfer mechanism.  An internal texture format is
      the representation of texture data within OpenGL.  Note that the
      (external) format used to specify the data by the application may
      be different than the internal texture format used to store the
      texture data internally to OpenGL.  For example, core OpenGL permits
      an application to specify data for a texture as GL_LUMINANCE_ALPHA
      data stored in GLfloats even though the data is to be store in
      a GL_RGBA8 texture.  OpenGL's pixel unpacking and pixel transfer
      operations perform an appropriate transformation of the data when
      such a texture download is performed.  Also note that data from
      one pixel group (say stencil components) cannot be supplied as
      data for a different pixel group (say RGBA components).

      This extension introduces four new (external) formats for
      texture data:  GL_HILO_NV, GL_DSDT_NV, GL_DSDT_MAG_NV, and
      GL_DSDT_MAG_VIB_NV.

      GL_HILO_NV is for specifying high-precision hi and lo components.
      The other three formats are used to specify texture offset groups.
      These new formats can only be used for specifying textures (not
      copying, reading, or writing pixels).

      Each of these four pixel formats belong to one of two pixel groups.
      Pixels specified with the GL_HILO_NV format are transformed as HILO
      components.  Pixels specified with the DSDT_NV, DSDT_MAG_NV, and
      DSDT_MAG_VIB_NV formats are transformed as texture offset groups.

      The HILO component and texture offset group pixel groups have
      independent scale and bias operations for each component type.
      Various pixel transfer operations that are performed on the RGBA
      components pixel group are NOT performed on these two new pixel
      groups.  OpenGL's pixel map, color table, convolution, color matrix,
      histogram, and min/max are NOT performed on the HILO components
      or texture offset group pixel groups.

      There are four internal texture formats for texture data specified
      as HILO components:  GL_HILO_NV, GL_HILO16_NV, GL_SIGNED_HILO_NV,
      and GL_SIGNED_HILO16_NV.  The HILO data can be stored as either
      unsigned [0,1] value or [-1,1] signed values.  There are also
      enumerants for both explicitly sized component precision (16-bit
      components) and unsized component precision.  OpenGL implementations
      are expected to keep HILO components are high precision even if
      an unsized internal texture format is used.

      The expectation with HILO textures is that applications will
      specify HILO data using a type of GL_UNSIGNED_SHORT or GL_SHORT or
      larger data types.  Specifying HILO data with GL_UNSIGNED_BYTE or
      GL_BYTE works but does not exploit the full available precision
      of the HILO internal texture formats.

      There are six internal texture formats for texture data
      specified as texture offset groups: GL_DSDT_NV, GL_DSDT8_NV,
      GL_DSDT_MAG_NV, GL_DSDT8_MAG8_NV, GL_DSDT_MAG_INTENSITY_NV and
      GL_DSDT8_MAG8_INTENSITY8_NV.  The GL_DSDT_NV formats specify two
      signed [-1,1] components, ds and dt, used to offset s and t texture
      coordinates.  The GL_DSDT_MAG_NV formats specify an additional
      third unsigned [0,1] component that is a magnitude to scale an
      unsigned RGBA texture fetch by.  The GL_DSDT_MAG_INTENSITY_NV
      formats specify an additional fourth [0,1] unsigned component,
      intensity, that becomes the intensity of the fetched texture for
      use in the texture environment or register combiners.  There are
      also enumerants for both explicitly sized (8-bit components)
      and unsized component precision.

      Note that the vibrance (VIB) component of the
      GL_DSDT_MAG_VIB_NV format becomes the intensity component of
      the GL_DSDT_MAG_INTENSITY_NV internal texture format.  Vibrance
      becomes intensity in the GL_DSDT_MAG_INTENSITY_NV texture format.
      The introduction of vibrance is because core OpenGL has no notion
      of an intensity component in the pixel transfer mechanism or as
      an external format (instead the red component of an RGBA value
      becomes the intensity component of intensity textures).

    How does the texture unit RGBA result of a texture shader that fetches
    a texture with a base internal format of GL_HILO_NV, GL_DSDT_NV, or
    GL_DSDT_MAG_NV show up in the register combiners texture registers?

      RESOLUTION: Always as the value (0,0,0,0).

      How the texture RGBA result of a texture shader that fetches a
      texture with a base internal format of GL_HILO_NV, GL_DSDT_NV,
      or GL_DSDT_MAG_NV the GL_DOT_PRODUCT_NV texture shader shows up
      in the texture environment is not an issue, because the texture
      environment operation is always assumed to be GL_NONE in this case
      when GL_TEXTURE_SHADER_NV is enabled.

    Does the GL_DOT_PRODUCT_DEPTH_REPLACE_NV program replace the
    eye-distance Z or window-space depth?

      RESOLUTION:  Window-space depth.  And if the window-space depth
      value is outside of the near and far depth range values, the
      fragment is rejected.

    The GL_CULL_FRAGMENT_NV operation always compares against all four
    texture coordinates.  What if I want only one, two, or three
    comparisons?

      RESOLUTION:  To compare against a single value, replicate that value
      in all the coordinates and set the comparison for all components to
      be identical.  Or you can set uninteresting coordinates to zero and
      use the GL_GEQUAL comparison which will never cull for the value zero.

    What is GL_CULL_FRAGMENT_NV good for?

      The GL_CULL_FRAGMENT_NV operation provides a mechanism to implement
      per-fragment clip planes.  If a texture coordinate is assigned a
      signed distance to a plane, the cull fragment test can discard
      fragments on the wrong side of the plane.  Each texture shader
      stage provides up to four such clip planes.  An eye-space clip
      plane can be established using the GL_EYE_LINEAR texture coordinate
      generation mode where the clip plane equation is specified via
      the GL_EYE_PLANE state.

      Clip planes are one application for GL_CULL_FRAGMENT_NV, but
      other clipping approaches are possible too.  For example, by
      computing and assigning appropriate texture coordinates (perhaps
      with NV_vertex_program), fragments beyond a certain distance from
      a point can be culled (assuming that it is acceptable to linearly
      interpolate a distance between vertices).

    The texture border color is supposed to be an RGBA value clamped to
    the range [0,1].  How does the texture border color work in conjunction
    with signed RGBA color components, HILO components, and texture offset
    component groups?

      RESOLUTION:  The per-texture object GL_TEXTURE_BORDER_COLOR
      is superceded by a GL_TEXTURE_BORDER_VALUES symbolic token.
      The texture border values are four floats (not clamped to
      [0,1] when specified).  When a texture border is required for
      a texture, the components for the border texel are determined
      by the GL_TEXTURE_BORDER_VALUES state.  For color components,
      the GL_TEXTURE_BORDER_VALUES state is treated as a set of RGBA
      color components.  For HILO components, the first value is treated
      as hi and the second value is treated as lo.  For texture offset
      components, the ds, dt, mag, and vib values correspond to the first,
      second, third, and fourth texture border values respectively.
      The particular texture border components are clamped to the range
      of the component determined by the texture's internal format.  So a
      signed component is clamped to the [-1,1] range and an unsigned
      component is clamped to the [0,1] range.

      For backward compatibility, the GL_TEXTURE_BORDER_COLOR can
      still be specified and queried.  When specified, the values are
      clamped to [0,1] and used to update the texture border values.
      When GL_TEXTURE_BORDER_COLOR is queried, there is no clamping of
      the returned values.

    With signed texture components, does the texture environment function
    discussion need to be amended?

      RESOLUTION:  Yes.  We do not want texture environment results to
      exceed the range [-1,1].

      The GL_DECAL and GL_BLEND operations perform linear interpolations
      of various components of the form

        A * B + (1-A) * C

      The value of A should not be allowed to be negative otherwise,
      the value of (1-A) may exceed 1.0.  These linear interpolations
      should be written in the form

        max(0,A) * B + (1-max(0,A)) * C

      The GL_ADD operation clamps its result to 1.0, but if negative
      components are permitted, the result should be clamped to the range
      [-1,1].

      The GL_COMBINE_ARB (and GL_COMBINE_EXT) and GL_COMBINE4_NV
      operations do explicit clamping of all result to [0,1].
      In addition, NV_texture_shader adds requirements to clamp
      inputs to [0,1] too.  This is because the GL_ONE_MINUS_SRC_COLOR
      and GL_ONE_MINUS_SRC_ALPHA operands should really be computing
      1-max(0,C).  For completeness, GL_SRC_COLOR and GL_SRC_ALPHA should
      be computing max(0,C).

    With signed texture components, does the color sum discussion need
    to be amended?

      RESOLUTION:  Yes.  The primary and secondary color should both be
      clamped to the range [0,1] before they are summed.

      The unextended OpenGL 1.2 description of color sum does not
      require a clamp of the primary and secondary colors to the [0,1]
      range before they are summed.  Before signed texture components,
      the standard texture environment modes either could not generate
      results outside the [0,1] range or explicitly clamped their
      results to this range (as in the case of GL_ADD, GL_COMBINE_EXT,
      and GL_COMBINE4_NV).  Now with signed texture components, negative
      values can be generated by texture environment functions.

      We do not want to clamp the intermediate results of texture
      environment stages since negative results may be useful in
      subsequent stages, but clamping should be applied to the primary
      color immediately before the color sum.  For symmetry, clamping of
      the secondary color is specified as well (though there is currently
      no way to generate a negative secondary color).

    Why vibrance?

      Vibrance is the fourth component of the external representation of a
      texture offset group.  During pixel transfer, vibrance is scaled and
      biased based on the GL_VIBRANCE_SCALE and GL_VIBRANCE_BIAS state.
      Once transformed, the vibrance component becomes the intensity
      component for textures with a DSDT_MAG_INTENSITY base internal
      format.  Vibrance is meaningful only when specifying texture images
      with the DS_DT_MAG_VIB_NV external format (and is not supported
      when reading, drawing, or copying pixels).

    There are lots of reasons that a texture shader stage is inconsistent,
    and in which case, the stage operates as if the operation is NONE.
    For debugging sanity, is there a way to determine whether a particular
    texture shader stage is consistent?

      RESOLUTION:  Yes.  Query the shader consistency of a particular
      texture unit with:

        GLint consistent;

        glActiveTextureARB(stage_to_check);
        glGetTexEnviv(GL_TEXTURE_SHADER_NV, GL_SHADER_CONSISTENT_NV,
          &consistent);

      consistent is one or zero depending on whether the shader stage
      is consistent or not.

    Should there be signed components with sub 8-bit precision?

      RESOLUTION:  No.

    Should packed pixel formats for texture offset groups be supported?

      RESOLUTION:  Yes, but they are limited to UNSIGNED_INT_S8_S8_8_8_NV
      and UNSIGNED_INT_8_8_S8_S8_REV_NV for use with the DSDT_MAG_VIB_NV
      format.

      Note that these two new packed pixel formats are only for the
      DSDT_MAG_VIB_NV and cannot be used with RGBA or BGRA formats.
      Likewise, the RGBA and BGRA formats cannot be used with the new
      UNSIGNED_INT_S8_S8_8_8_NV and UNSIGNED_INT_8_8_S8_S8_REV_NV types.

    What should be said about signed fixed-point precision and range of
    actual implementations?

      RESOLUTION:  The core OpenGL specification typically specifies
      fixed-point numerical computations without regard to the specific
      precision of the computations.  This practice is intentional because
      it permits implementations to vary in the degree of precision used
      for internal OpenGL computations.  When mapping unsigned fixed-point
      values to a [0,1] range, the mapping is straightforward.

      However, this extension supports signed texture components in
      the range [-1,1].  This presents some awkward choices for how to
      map [-1,1] to a fixed-point representation.  Assuming a binary
      fixed-point representation with an even distribution of precision,
      there is no way to exactly represent -1, 0, and 1 and avoid
      representing values outside the [-1,1] range.

      This is not a unique issue for this extension.  In core OpenGL,
      table 2.6 describes mappings from unsigned integer types (GLbyte,
      GLshort, and GLint) that preclude the exact specification of 0.0.
      NV_register_combiners supports signed fixed-point values that have
      similar representation issues.

      NVIDIA's solution to this representation problem is to use 8-, 9-,
      and 16-bit fixed-point representations for signed values in the
      [-1,1] range such that

   floating-point   8-bit fixed-point   9-bit fixed-point  16 bit fixed-point
   --------------   -----------------   -----------------  ------------------
    1.0              n/a                 255                n/a  
    0.99996...       n/a                 n/a                32767
    0.99218...      127                  n/a                n/a  
    0.0              0                   0                  0
   -1.0            -128                 -255               -32768
   -1.00392...      n/a                 -256                n/a

      The 8-bit and 16-bit signed fixed-point types are used for signed
      internal texture formats, while the 9-bit signed fixed-point type
      is used for register combiners computations.

      The 9-bit signed fixed-point type has the disadvantage that a
      number slightly more negative than -1 can be represented and this
      particular value is different dependent on the number of bits of
      fixed-point precision.  The advantage of this approach is that 1,
      0, and -1 can all be represented exactly.

      The 8-bit and 16-bit signed fixed-point types have the disadvantage
      that 1.0 cannot be exactly represented (though -1.0 and zero can
      be exactly represented).

      The specification however is written using the conventional
      OpenGL practice (table 2.6) of mapping signed values evenly over
      the range [-1,1] so that zero cannot be precisely represented.
      This is done to keep this specification consistent with OpenGL's
      existing conventions and to avoid the ugliness of specifying
      a precision-dependent range.  We expect leeway in how signed
      fixed-point values are represented.

      The spirit of this extension is that an implicit allowance is
      made for signed fixed-point representations that cannot exactly
      represent 1.0.

    How should NV_texture_rectangle interact with NV_texture_shader?

      NV_texture_rectangle introduces a new texture target similar
      to GL_TEXTURE_2D but that supports non-power-of-two texture
      dimensions and several usage restrictions (no mipmapping, etc).
      Also the imaged texture coordinate range for rectangular textures
      is [0,width]x[0,height] rather than [0,1]x[0,1].

      Four texture shader operations will operate like their 2D texture
      counter-parts, but will access the rectangular texture
      target rather than the 2D texture target.  These are:

        GL_TEXTURE_RECTANGLE_NV
        GL_OFFSET_TEXTURE_RECTANGLE_NV
        GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV
        GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV

      A few 2D texture shader operations, namely
      GL_DEPENDENT_AR_TEXTURE_2D_NV and GL_DEPENDENT_GB_TEXTURE_2D_NV,
      do not support rectangular textures because turning colors in the
      [0,1] range into texture coordinates would only access a single
      corner texel in a rectangular texture.  The offset and dot product
      rectangular texture shader operations support scaling of the
      dependent texture coordinates so these operations can access the
      entire image of a rectangular texture.  Note however that it is the
      responsibility of the application to perform the proper scaling.

      Note that the 2D and rectangular "offset texture" shaders both
      use the same matrix, scale, and bias state.

    Does the GL_DOT_PRODUCT_DEPTH_REPLACE_NV operation happen before or
    after polygon offset?

      RESOLUTION:  After.  The window Z (w_z) is computed during
      rasterization and polygon offset occurs at this point.  The depth
      replace operation occurs after rasterization (at the point that
      conventional OpenGL calls "texturing") so when the depth value
      is replaced, the effect of polygon offset (and normal depth
      interpolation) is lost when using the depth replace operation.

    How does the GL_DOT_PRODUCT_DEPTH_REPLACE_NV operation interact with
    ARB_multisample?

      RESOLUTION:  The depth value for all covered samples of a
      multisampled fragment are replaced with the _same_ single depth
      value computed by the depth replace operation.  Without depth
      replace, the depth values of each sample of a fragment may have
      slightly different depth values because of the polygon's depth
      gradient.

    How should the clamping work for GL_OFFSET_TEXTURE_2D_SCALE?

       RESOLUTION:  The scale factor should be clamped to [0,1] prior
       to scaling red, green, and blue.

       Red, green, and blue are guaranteed to be unsigned RGB values
       so the [0,1] scale factor times the [0,1] RGB values results in
       [0,1] values so no output clamping need be specified.

New Procedures and Functions

    None.

New Tokens


        TEXTURE_SHADER_NV                         0x86DE

     
        RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV      0x86D9
        SHADER_OPERATION_NV                       0x86DF
        OFFSET_TEXTURE_SCALE_NV                   0x86E2
        OFFSET_TEXTURE_BIAS_NV                    0x86E3
        PREVIOUS_TEXTURE_INPUT_NV                 0x86E4


        CULL_MODES_NV                             0x86E0
        OFFSET_TEXTURE_MATRIX_NV                  0x86E1
        CONST_EYE_NV                              0x86E5
     

        SHADER_CONSISTENT_NV                      0x86DD






        PASS_THROUGH_NV                           0x86E6
        CULL_FRAGMENT_NV                          0x86E7

        OFFSET_TEXTURE_2D_NV                      0x86E8
        OFFSET_TEXTURE_RECTANGLE_NV               0x864C
        OFFSET_TEXTURE_RECTANGLE_SCALE_NV         0x864D
        DEPENDENT_AR_TEXTURE_2D_NV                0x86E9
        DEPENDENT_GB_TEXTURE_2D_NV                0x86EA

        DOT_PRODUCT_NV                            0x86EC
        DOT_PRODUCT_DEPTH_REPLACE_NV              0x86ED
        DOT_PRODUCT_TEXTURE_2D_NV                 0x86EE
        DOT_PRODUCT_TEXTURE_RECTANGLE_NV          0x864E
        DOT_PRODUCT_TEXTURE_CUBE_MAP_NV           0x86F0
        DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV           0x86F1
        DOT_PRODUCT_REFLECT_CUBE_MAP_NV           0x86F2
        DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV 0x86F3








        HILO_NV                                   0x86F4
        DSDT_NV                                   0x86F5
        DSDT_MAG_NV                               0x86F6
        DSDT_MAG_VIB_NV                           0x86F7


        UNSIGNED_INT_S8_S8_8_8_NV                 0x86DA 
        UNSIGNED_INT_8_8_S8_S8_REV_NV             0x86DB 


        SIGNED_RGBA_NV                            0x86FB
        SIGNED_RGBA8_NV                           0x86FC
        SIGNED_RGB_NV                             0x86FE
        SIGNED_RGB8_NV                            0x86FF
        SIGNED_LUMINANCE_NV                       0x8701
        SIGNED_LUMINANCE8_NV                      0x8702
        SIGNED_LUMINANCE_ALPHA_NV                 0x8703
        SIGNED_LUMINANCE8_ALPHA8_NV               0x8704
        SIGNED_ALPHA_NV                           0x8705
        SIGNED_ALPHA8_NV                          0x8706
        SIGNED_INTENSITY_NV                       0x8707
        SIGNED_INTENSITY8_NV                      0x8708
        SIGNED_RGB_UNSIGNED_ALPHA_NV              0x870C
        SIGNED_RGB8_UNSIGNED_ALPHA8_NV            0x870D


        HILO16_NV                                 0x86F8
        SIGNED_HILO_NV                            0x86F9
        SIGNED_HILO16_NV                          0x86FA
        DSDT8_NV                                  0x8709
        DSDT8_MAG8_NV                             0x870A
        DSDT_MAG_INTENSITY_NV                     0x86DC
        DSDT8_MAG8_INTENSITY8_NV                  0x870B


        HI_SCALE_NV                               0x870E
        LO_SCALE_NV                               0x870F
        DS_SCALE_NV                               0x8710
        DT_SCALE_NV                               0x8711
        MAGNITUDE_SCALE_NV                        0x8712
        VIBRANCE_SCALE_NV                         0x8713
        HI_BIAS_NV                                0x8714
        LO_BIAS_NV                                0x8715
        DS_BIAS_NV                                0x8716
        DT_BIAS_NV                                0x8717
        MAGNITUDE_BIAS_NV                         0x8718
        VIBRANCE_BIAS_NV                          0x8719


        TEXTURE_BORDER_VALUES_NV                  0x871A


        TEXTURE_HI_SIZE_NV                        0x871B
        TEXTURE_LO_SIZE_NV                        0x871C
        TEXTURE_DS_SIZE_NV                        0x871D
        TEXTURE_DT_SIZE_NV                        0x871E
        TEXTURE_MAG_SIZE_NV                       0x871F

