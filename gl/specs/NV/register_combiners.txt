Name
    
    NV_register_combiners

Name Strings

    GL_NV_register_combiners

Contact

    Mark J. Kilgard, NVIDIA Corporation (mjk 'at' nvidia.com)

Notice

    Copyright NVIDIA Corporation, 1999, 2000, 2001, 2002, 2003.

IP Status

    NVIDIA Proprietary.

Status

    Shipping (version 1.6)

Version

    NVIDIA Date: February 1, 2007 (version 1.7)

Number

    191

Dependencies

    ARB_multitexture, assuming the value of MAX_TEXTURE_UNITS_ARB is
    at least 2.

    Written based on the wording of the OpenGL 1.2 specification with
    the ARB_multitexture appendix E.

    NV_texture_shader affects the definition of this extension.

    ARB_depth_texture and ARB_shadow -or- SGIX_depth_texture and
    SGIX_shadow affect the definition of this extension.

    ARB_color_buffer_float affects the definiton of this extension.

Overview

    NVIDIA's next-generation graphics processor and its derivative
    designs support an extremely configurable mechanism know as "register
    combiners" for computing fragment colors.

    The register combiner mechanism is a significant redesign of NVIDIA's
    original TNT combiner mechanism as introduced by NVIDIA's RIVA
    TNT graphics processor.  Familiarity with the TNT combiners will
    help the reader appreciate the greatly enhanced register combiners
    functionality (see the NV_texture_env_combine4 OpenGL extension
    specification for this background).  The register combiner mechanism
    has the following enhanced functionality: 

      The numeric range of combiner computations is from [-1,1]
      (instead of TNT's [0,1] numeric range),

      The set of available combiner inputs is expanded to include the
      secondary color, fog color, fog factor, and a second combiner
      constant color (TNT's available combiner inputs consist of
      only zero, a single combiner constant color, the primary color,
      texture 0, texture 1, and, in the case of combiner 1, the result
      of combiner 0).

      Each combiner variable input can be independently scaled and
      biased into several possible numeric ranges (TNT can only
      complement combiner inputs).

      Each combiner stage computes three distinct outputs (instead
      TNT's single combiner output).

      The output operations include support for computing dot products
      (TNT has no support for computing dot products).

      After each output operation, there is a configurable scale and bias
      applied (TNT's combiner operations builds in a scale and/or bias
      into some of its combiner operations).

      Each input variable for each combiner stage is fetched from any
      entry in a combiner register set.  Moreover, the outputs of each
      combiner stage are written into the register set of the subsequent
      combiner stage (TNT could only use the result from combiner 0 as
      a possible input to combiner 1; TNT lacks the notion of an
      input/output register set).

      The register combiner mechanism supports at least two general
      combiner stages and then a special final combiner stage appropriate
      for applying a color sum and fog computation (TNT provides two
      simpler combiner stages, and TNT's color sum and fog stages are
      hard-wired and not subsumed by the combiner mechanism as in register
      combiners).

    The register combiners fit into the OpenGL pipeline as a rasterization
    processing stage operating in parallel to the traditional OpenGL
    texture environment, color sum, AND fog application.  Enabling this
    extension bypasses OpenGL's existing texture environment, color
    sum, and fog application processing and instead use the register
    combiners.  The combiner and texture environment state is orthogonal
    so modifying combiner state does not change the traditional OpenGL
    texture environment state and the texture environment state is
    ignored when combiners are enabled.

    OpenGL application developers can use the register combiner mechanism
    for very sophisticated shading techniques.  For example, an
    approximation of Blinn's bump mapping technique can be achieved with
    the combiner mechanism.  Additionally, multi-pass shading models
    that require several passes with unextended OpenGL 1.2 functionality
    can be implemented in several fewer passes with register combiners.

Issues

    Should we expose the full register combiners mechanism?

      RESOLUTION:  NO.  We ignore small bits of NV10 hardware
      functionality.  The texture LOD input is ignored.  We also ignore
      the inverts on input to the EF product.

    Do we provide full gets for all the combiner state?

      RESOLUTION:  YES.

    Do we parameterize combiner input and output updates to avoid
    enumerant explosions?

      RESOLUTION:  YES.  To update a combiner stage input variable, you
      need to specify the <stage>, <portion>, and <variable>.  To update a
      combiner stage output operation, you need to specify the <stage> and
      <portion>.  This does mean that we need to add special Get routines
      that are likewise parameterized.  Hence, GetCombinerInputParameter*,
      GetCombinerOutputParameter*, and GetFinalCombinerInputParameter*.

   Is the register combiner functionality a super-set of the TNT combiner
   functionality?

      Yes, but only in the sense of being a computational super-set.
      All computations performed with the TNT combiners can be performed
      with the register combiners, but the sequence of operations necessary
      to configure an identical computational result can be quite
      different.

      For example, the TNT combiners have an operation that includes
      a final complement operation.  The register combiners can perform
      range mappings only on inputs, but not on outputs.  The register
      combiners can mimic the TNT operation with a post-operation
      complement only by taking pains to complement on input any uses
      of the output in later combiner stages.

      What this does mean is that NV10's hardware functionality
      will permit support for both the NV_register_combiners AND
      NV_texture_env_combine4 extensions.

      Note the existance of an "speclit" input complement bit supported
      by NV10 (but not accessible through the NV_register_combiners
      extensions).

   Should we say anything about the precision of the combiner
   computations?

      RESOLUTION:  NO.  The spec is written as if the computations are
      done on floating point values ranging from -1.0 to 1.0 (clamping is
      specified where this range is exceeded).  The fact that NV10 does
      the computations as 9-bit signed fixed point is not mentioned in
      the spec.  This permits a future design to support more precision
      or use a floating pointing representation.

    What should the initial combiner state be?

      RESOLUTION:  See tables NV_register_combiners.5 and
      NV_register_combiners.6.  The default state has one general combiner
      stage active that modulates the incoming color with texture 0.
      The final combiner is setup initially to implement OpenGL 1.2's
      standard color sum and fog stages.

    What should happen to the TEXTURE0_ARB and TEXTUER1_ARB inputs if
    one or both textures are disabled?

      RESOLUTION:  The value of these inputs is undefined.

    What do the TEXTURE0_ARB and TEXTURE1_ARB inputs correspond to?
    Does the number correspond to the absolute texture unit number
    or is the number based on how many textures are enabled (ie,
    TEXTURE_ARB0 would correspond to the 2nd texture unit if the
    2nd unit is enabled, but the 1st is disabled).

      RESOLUTION:  The absolute texture unit.

      This should be a lot less confusing to the programmer than having
      the texture inputs switch textures if texture 0 is disabled.

      Note that the proposed hardware actually determines the TEXTURE0
      and TEXTURE1 input based on which texture is enabled.  This means
      it is up to the ICD to properly update the combiner state when just
      one texture is enabled.  Since we will already have to do this to
      track the standard OpenGL texture environment for ARB_multitexture,
      we can do it for this extension too.

    Should the combiners state be PushAttrib/PopAttrib'ed along with
    the texture state?

      RESOLUTION:  YES.

    Should we advertise the LOD fractional input to the combiners?

      RESOLUTION:  NO.

    There will be a performance impact when two combiner stages are
    enabled versus just one stage.  Should we mention that somewhere?

      RESOLUTION:  NO.  (But it is worth mentioning in this issues
      section.)

    Should the scale and bias for the CombinerOutputNV be indicated
    by enumerants or specified outright as floats?

      RESOLUTION:  ENUMERANTS.  While some future combiners might
      support an arbitrary scale & bias specified as floats, NV10 just
      does the enumerated options.

    Should a dot product be computed in parralel with the sum of
    products?

      RESOLUTION:  YES (changed for version 1.6).  The hardware is
      capable of summing the two dot products.

      Versions of this specification prior to version 1.6 documented that
      an INVALID_OPERATION should be generated if either <abDotProduct>
      or <cdDotProduct> is true and then <sumOutput> is not GL_DISCARD.
      However, this check was never added to the driver and some
      applications found the mode useful.

    Does the GL_E_TIMES_F_NV token for the final combiner perform any
    mapping on E or F before the mapping?  Is the multiply signed?
    Can the result be negative?

      RESOLUTION:  Input mappings and component usage is applied to E or
      F before their product is computed.  Yes, the product is a signed
      multiplication.  The result can be negative, but the two allowed
      final combiner input mapping modes (GL_UNSIGNED_IDENTITY_NV and
      GL_UNSIGNED_INVERT_NV) both effectively clamp their results to
      [0,1].

      A negative value resulting from the "E times F" product with the
      GL_UNSIGNED_IDENTITY_NV mapping mode would be clamped to zero.

      A negative value resulting from the "E times F" product with the
      GL_UNSIGNED_INVERT_NV mpaping mode would be clamped to zero but
      then one minus that clamped result (zero) would generate one.

New Procedures and Functions

    void CombinerParameterfvNV(GLenum pname,
                               const GLfloat *params);

    void CombinerParameterivNV(GLenum pname,
                               const GLint *params);

    void CombinerParameterfNV(GLenum pname,
                              GLfloat param);

    void CombinerParameteriNV(GLenum pname,
                              GLint param);

    void CombinerInputNV(GLenum stage,
                         GLenum portion,
                         GLenum variable,
                         GLenum input,
                         GLenum mapping,
                         GLenum componentUsage);

    void CombinerOutputNV(GLenum stage,
                          GLenum portion, 
                          GLenum abOutput,
                          GLenum cdOutput,
                          GLenum sumOutput,
                          GLenum scale,
                          GLenum bias,
                          GLboolean abDotProduct,
                          GLboolean cdDotProduct,
                          GLboolean muxSum);

    void FinalCombinerInputNV(GLenum variable,
                              GLenum input,
                              GLenum mapping,
                              GLenum componentUsage);

    void GetCombinerInputParameterfvNV(GLenum stage,
                                       GLenum portion,
                                       GLenum variable,
                                       GLenum pname,
                                       GLfloat *params);

    void GetCombinerInputParameterivNV(GLenum stage,
                                       GLenum portion,
                                       GLenum variable,
                                       GLenum pname,
                                       GLint *params);

    void GetCombinerOutputParameterfvNV(GLenum stage,
                                        GLenum portion, 
                                        GLenum pname,
                                        GLfloat *params);

    void GetCombinerOutputParameterivNV(GLenum stage,
                                        GLenum portion, 
                                        GLenum pname,
                                        GLint *params);

    void GetFinalCombinerInputParameterfvNV(GLenum variable,
                                            GLenum pname,
                                            GLfloat *params);

    void GetFinalCombinerInputParameterivNV(GLenum variable,
                                            GLenum pname,
                                            GLint *params);

New Tokens


        REGISTER_COMBINERS_NV              0x8522


        COMBINER0_NV                       0x8550
        COMBINER1_NV                       0x8551
        COMBINER2_NV                       0x8552
        COMBINER3_NV                       0x8553
        COMBINER4_NV                       0x8554
        COMBINER5_NV                       0x8555
        COMBINER6_NV                       0x8556
        COMBINER7_NV                       0x8557


        VARIABLE_A_NV                      0x8523
        VARIABLE_B_NV                      0x8524
        VARIABLE_C_NV                      0x8525
        VARIABLE_D_NV                      0x8526


        VARIABLE_E_NV                      0x8527
        VARIABLE_F_NV                      0x8528
        VARIABLE_G_NV                      0x8529


        CONSTANT_COLOR0_NV                 0x852A
        CONSTANT_COLOR1_NV                 0x852B
        PRIMARY_COLOR_NV                   0x852C
        SECONDARY_COLOR_NV                 0x852D
        SPARE0_NV                          0x852E
        SPARE1_NV                          0x852F


        UNSIGNED_IDENTITY_NV               0x8536
        UNSIGNED_INVERT_NV                 0x8537
        EXPAND_NORMAL_NV                   0x8538
        EXPAND_NEGATE_NV                   0x8539
        HALF_BIAS_NORMAL_NV                0x853A
        HALF_BIAS_NEGATE_NV                0x853B
        SIGNED_IDENTITY_NV                 0x853C
        SIGNED_NEGATE_NV                   0x853D


        E_TIMES_F_NV                       0x8531
        SPARE0_PLUS_SECONDARY_COLOR_NV     0x8532




        SCALE_BY_TWO_NV                    0x853E
        SCALE_BY_FOUR_NV                   0x853F
        SCALE_BY_ONE_HALF_NV               0x8540


        BIAS_BY_NEGATIVE_ONE_HALF_NV       0x8541


        DISCARD_NV                         0x8530


        COMBINER_INPUT_NV                  0x8542
        COMBINER_MAPPING_NV                0x8543
        COMBINER_COMPONENT_USAGE_NV        0x8544


        COMBINER_AB_DOT_PRODUCT_NV         0x8545
        COMBINER_CD_DOT_PRODUCT_NV         0x8546
        COMBINER_MUX_SUM_NV                0x8547
        COMBINER_SCALE_NV                  0x8548
        COMBINER_BIAS_NV                   0x8549
        COMBINER_AB_OUTPUT_NV              0x854A
        COMBINER_CD_OUTPUT_NV              0x854B
        COMBINER_SUM_OUTPUT_NV             0x854C




        NUM_GENERAL_COMBINERS_NV           0x854E
        COLOR_SUM_CLAMP_NV                 0x854F




        MAX_GENERAL_COMBINERS_NV           0x854D

