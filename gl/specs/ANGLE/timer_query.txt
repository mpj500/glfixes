Name

    ANGLE_timer_query

Name Strings

    GL_ANGLE_timer_query

Contributors

    Contributors to ARB_occlusion_query
    Contributors to EXT_timer_query
    Contributors to ARB_timer_query
    Ben Vanik, Google Inc.
    Daniel Koch, TransGaming Inc.

Contact

    Ben Vanik, Google Inc. (benvanik 'at' google 'dot' com)

Status

    Draft

Version

    Last Modified Date: Apr 28, 2011
    Author Revision: 1

Number

    OpenGL ES Extension #??

Dependencies

    OpenGL ES 2.0 is required.

    The extension is written against the OpenGL ES 2.0 specification.

Overview

    Applications can benefit from accurate timing information in a number of
    different ways.  During application development, timing information can
    help identify application or driver bottlenecks.  At run time,
    applications can use timing information to dynamically adjust the amount
    of detail in a scene to achieve constant frame rates.  OpenGL
    implementations have historically provided little to no useful timing
    information.  Applications can get some idea of timing by reading timers
    on the CPU, but these timers are not synchronized with the graphics
    rendering pipeline.  Reading a CPU timer does not guarantee the completion
    of a potentially large amount of graphics work accumulated before the
    timer is read, and will thus produce wildly inaccurate results.
    glFinish() can be used to determine when previous rendering commands have
    been completed, but will idle the graphics pipeline and adversely affect
    application performance.

    This extension provides a query mechanism that can be used to determine
    the amount of time it takes to fully complete a set of GL commands, and
    without stalling the rendering pipeline.  It uses the query object
    mechanisms first introduced in the occlusion query extension, which allow
    time intervals to be polled asynchronously by the application.

IP Status

    No known IP claims.

New Procedures and Functions

    void GenQueriesANGLE(sizei n, uint *ids);
    void DeleteQueriesANGLE(sizei n, const uint *ids);
    boolean IsQueryANGLE(uint id);
    void BeginQueryANGLE(enum target, uint id);
    void EndQueryANGLE(enum target);
    void QueryCounterANGLE(uint id, enum target);
    void GetQueryivANGLE(enum target, enum pname, int *params);
    void GetQueryObjectivANGLE(uint id, enum pname, int *params);
    void GetQueryObjectuivANGLE(uint id, enum pname, uint *params);
    void GetQueryObjecti64vANGLE(uint id, enum pname, int64 *params);
    void GetQueryObjectui64vANGLE(uint id, enum pname, uint64 *params);

New Tokens


        QUERY_COUNTER_BITS_ANGLE                       0x8864
        CURRENT_QUERY_ANGLE                            0x8865


        QUERY_RESULT_ANGLE                             0x8866
        QUERY_RESULT_AVAILABLE_ANGLE                   0x8867
        

        TIME_ELAPSED_ANGLE                             0x88BF


        TIMESTAMP_ANGLE                                0x8E28

