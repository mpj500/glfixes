Name

    SGIX_async

Name Strings

    GL_SGIX_async

Version

    $Date: 1998/06/04 20:57:36 $ $Revision: 1.8 $

Number

    132

Dependencies

    None.

Overview

    This extension provides a framework for asynchronous OpenGL
    commands.  It also provides commands allowing a program to wait
    for the completion of asynchronous commands.
    
    Asynchronous commands have two properties:
    
    1) Asynchronous commands are non-blocking.  For example, an
    asynchronous ReadPixels command returns control to the program
    immediately rather than blocking until the command completes.
    This property allows the program to issue other OpenGL commands in
    parallel with the execution of commands that normally block.
    
    2) Asynchronous commands may complete out-of-order with respect to
    other OpenGL commands.  For example, an asynchronous TexImage
    command may complete after subsequent OpenGL commands issued by
    the program rather than maintaining the normal serial order of the
    OpenGL command stream.  This property allows the graphics
    accelerator to execute asynchronous commands in parallel with the
    normal command stream, for instance using a secondary path to
    transfer data from or to the host, without doing any dependency
    checking.
    
    Programs that issue asynchronous commands must also be able to
    determine when the commands have completed.  The completion status
    may be needed so that results can be retrieved (e.g. the image
    data from a ReadPixels command) or so that dependent commands can
    be issued (e.g. drawing commands that use texture data downloaded
    by an earlier asynchronous command).  This extension provides
    fine-grain control over asynchronous commands by introducing a
    mechanism for determining the status of individual commands.

    Each invocation of an asynchronous command is associated with an
    integer called a "marker."  A program specifies a marker before it
    issues an asynchronous command.  The program may later issue a
    command to query if any asynchronous commands have completed.  The
    query commands return a marker to identify the command that
    completed.  This extension provides both blocking and non-blocking
    query commands.

    This extension does not define any asynchronous commands.
    See SGIX_async_pixel for the asynchronous pixel commands.

Issues

    * Should all asynchronous operations share the same marker name space?

      Ans: Yes.  The argument for separate name spaces is that it
      makes modularizing an application easier.  The proposal was to
      use a separate name space for each category of commands,
      e.g. readpixels, teximage, drawpixels, and histogram. That works
      if each name space is used by only one part of the application
      (e.g. one part of the application issues asynchronous readpixels
      and some other part issues asynchronous teximage), but it
      doesn't work if there are multiple uses of one name space
      (e.g. two libraries that both use asynchronous readpixels).  It
      doesn't seem worth complicating the API to provide such a
      limited benefit.  The better solution is for a higher-level API
      to provide a mechanism for registering an interest in particular
      markers, similar to the X Windows mechanism for distributing
      window events.

    * Should the order of asynchronous operations be preserved, even
      if they are executed out-of-order with respect to normal commands?
    
      Ans: No, let the extensions that define the async operations choose
      whether or not to preserve order.

    * Should the extension also define a WaitAsyncSGIX command that
      guarantees completion of a specified asynchronous command before
      subsequent commands are executed?  This command wouldn't require
      the marker to make a round trip back to the host like
      FinishAsyncSGIX does, so it could be implemented more efficiently.

      Ans: No for now (no compelling application).

    * When are errors associated with an asynchronous command
      reported?

      Ans: A call to GetError after an asynchronous command always
      reports any errors associated with the command.  The behavior
      is as if errors are detected at the time a command is issued rather
      than when it is executed.  In this respect asynchronous commands
      are no different from synchronous commands.
      
    * Should a call to MakeCurrent implicitly force all pending
      asynchronous commands to complete?

      Ans: This is an implementation issue.  It does not affect the
      semantics of this extension.

    * Should there be an implementation-dependent limit on the
      number of outstanding asynchronous commands before the
      application calls FinishAsync?
      
      Ans: This extension does not impose such a limit, but the
      extensions that introduce asynchronous commands must address the
      issue.  An asynchronous command that uses an application-allocated
      buffer for return results (e.g. instruments) lets the application
      determine the limit by sizing the buffer appropriately.

    * Should this extension modify the instruments extension to use
      the new PollAsyncSGIX command instead of PollInstrumentsSGIX?

      Ans: No for now.

    * Should there be a generic command to set the current marker
      instead of a different mechanism for each asynchronous command?

      Ans: Yes, this has been added (AsyncMarkerSGIX).

    * Should there be a command to reserve a set of markers, like
      GenLists?

      Ans: Yes, this has been added (GenAsyncMarkers and
      DeleteAsyncMarkers).

    * Should name spaces be specified using enums instead of bitmasks?

      Ans: Yes, but name spaces have now been removed (see above).

    * Would it be better to define an extension that provides non-blocking
      commands rather than asynchronous commands?

      Ans: No.  Non-blocking commands would require the GL to preserve
      the order of commands, but that limits the potential for
      optimization.  The GL would have to check for dependencies
      between a non-blocking command and all subsequent commands
      (which is hard to do efficiently), or stall all subsequent
      commands until the non-blocking command completes, or maintain
      multiple sets of state.  By defining an asynchronous style of
      execution we place the burden of detecting dependencies on the
      application.  There is a large class of applications which can
      easily guarantee that there are no dependencies.

New Procedures and Functions

    void AsyncMarkerSGIX(uint marker)

    int FinishAsyncSGIX(uint *markerp)

    int PollAsyncSGIX(uint *markerp)

    uint GenAsyncMarkersSGIX(sizei range)

    void DeleteAsyncMarkersSGIX(uint marker, sizei range)

    boolean IsAsyncMarkerSGIX(uint marker)

New Tokens


	ASYNC_MARKER_SGIX		0x8329

