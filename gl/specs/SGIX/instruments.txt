Name

    SGIX_instruments

Name Strings

    GL_SGIX_instruments

Version

    $Date: 1997/09/18 01:12:38 $ $Revision: 1.6 $

Number

    55

Dependencies

    None

Overview

    This extension allows the gathering and return of performance
    measurements from within the graphics pipeline by adding
    instrumentation.

    There are two reasons to do this.  The first is as a part of some
    type of fixed-frame-rate load management scheme.  If we know that
    the pipeline is stalled or struggling to process the amount of
    data we have given it so far, we can reduce the level of detail of
    the remaining objects in the current frame or the next frame, or
    adjust the framebuffer resolution for the next frame if we have a
    video-zoom capability available.  We can call this type of
    instrumentation Load Monitoring.

    The second is for performance tuning and debugging of an
    application. It might tell us how many triangles were culled or
    clipped before being rasterized.  We can call this simply Tuning.

    Load Monitoring requires that the instrumentation and the access
    of the measurements be efficient, otherwise the instrumentation
    itself will reduce performance more than any load-management
    scheme could hope to offset.  Tuning does not have the same
    requirements.

    The proposed extension adds a call to setup a measurements return
    buffer, similar to FeedbackBuffer but with an asynchrounous
    behavior to prevent filling the pipeline with NOP's while waiting
    for the data to be returned.

    Note that although the extension has been specified without any
    particular instruments, defining either a device dependent or
    device independent instrument should be as simple as introducing
    an extension consisting primarily of a new enumerant to identify
    the instrument.

New Procedures and Functions

    void InstrumentsBufferSGIX(sizei size, int *buf)

    void StartInstrumentsSGIX(void)

    void StopInstrumentsSGIX(int marker)

    void ReadInstrumentsSGIX(int marker)

    int PollInstrumentsSGIX(int *markerp)

    int GetInstrumentsSGIX(void)

    An example of using the calls to test the extension:
{
#ifdef GL_SGIX_instruments

   static GLint buffer[64];
   void *bufp;
   int id, count0, count1, r;

   /* define the buffer to hold the measurments */
   glInstrumentsBufferSGIX(sizeof(buffer)/sizeof(GLint), (GLint *) buffer);

   /* enable the instruments from which one wishes to take measurements */
   glEnable(<an enum for instrument in use>);

   glStartInstrumentsSGIX();
   /* insert GL commands here */
   glReadInstrumentsSGIX(14);
   /* insert GL commands here */
   glStopInstrumentsSGIX(15);

   /* the number of msrmnts since the buffer was specified can be queried */
   glGetIntegerv(GL_INSTRUMENT_MEASUREMENTS_SGIX,&r); /* r should be 2 */

   glGetPointervEXT(GL_INSTRUMENT_BUFFER_SGIX,&bufp);
   /* bufp should be equal to buffer */

   /*
    * we can do a GetInstrumentsSGIX before or after the calls to
    * PollInstrumentsSGIX but to be sure of exactly what
    * measurements are in the buffer, we can use PollInstrumentsSGIX.
    */
   count0 = glGetInstrumentsSGIX();
   /* count0 will be a count of from 0 to 2 multiples of the size
    * in words of the instrument measurement we have enabled.
    * If buffer was overflowed, count0 will be 1.
    */

   while (!(r = glPollInstrumentsSGIX(&id))) ;
   /* if r is -1, we have overflowed, if it is 1, id will
    * have the value of the marker passed in with the first
    * measurement request (should be 14)
    */

   while (!(r = glPollInstrumentsSGIX(&id))) ;
   /* see the note on the first poll; id should be 15 */

   count1 = glGetInstrumentsSGIX();
   /* the sum of count0 and count1 should be 2 times
    * the size in words of an instrument measurement
    * that we have enabled.
    */

#endif
}


New Tokens





