Name

    ATI_vertex_array_object


Name Strings

    GL_ATI_vertex_array_object


Contact

    Rick Hammerstone, AMD (rick.hammerstone 'at' amd.com)


Version

    1.11 - 11/04/06
    Updated contact info after ATI/AMD merger.

    1.1 - 01/08/02
    Changed DeleteObjectBufferATI to FreeObjectBufferATI to match the
    glati.h header file. Removed objbuf attribute.

    1.01 - 09/18/01
    Added clarification that ArrayObectATI and VariantArrayObjectATI
    are not allowed between Begin/End but may not return an error.

    1.0 - 09/06/01
    Changed references to ATI_vertex_shader to EXT_vertex_shader.

    0.9 - 08/15/01
    Added support for variant arrays.

    0.8 - 07/06/01
    Added table of new state.

    0.7 - 07/02/01
    Added official enumerants.

    0.6 - 05/07/01
    Chopped out most of the new entry points. Back to just object
    buffers and one call to define vertex arrays in an object buffer. 

    0.5 - 04/18/01
    The great renaming. Added sample usage section. Expanded issues
    section. 

    0.4 - 04/09/01 
    Rewrote to use new entry points.

    0.3 - 04/06/01
    Changed Allocate and Free to New and Delete.

    0.2 - 03/26/01
    Added error description, additions to section 5 and 6 of the spec.

    0.1
    Original version

Number

    247

Dependencies

    This extension is written against the OpenGL 1.2.1 Specification.
    OpenGL 1.1 is required. GL_EXT_vertex_shader affects the
    definition of this extension.


Overview

    This extension defines an interface that allows multiple sets of
    vertex array data to be cached in persistent server-side memory.
    It is intended to allow client data to be stored in memory that
    can be directly accessed by graphics hardware.


Issues

    Should this extension include support for allowing vertex indices
    to be stored on the server?
    
        RESOLUTION: NO. This might not be universally supported, and
        seems simple enough to layer on top of this extension.

    Is there a better name for this extension?

        RESOLUTION: YES. The ArrayStore vs. StoredArray terminology
        was confusing. StoredArrays have been changed to be
        ArrayObjects. Since any type of object could be stored in the
        ArrayStore, these have been changed to ObjectBuffers.

    Should the layout of an array store be defined at array store
    creation time?

        RESOLUTION: NO. This could provide better performance if the
        client specifies a data type that the hardware doesn't
        support, but this isn't a performance path anyways, and it
        adds a cumbersome interface on top of the extension.

    Should the client be able to retrieve a pointer to the array store
    instead of a handle?

        RESOLUTION: NO. For now, it doesn't seem like this is a big
        win, and it presents problems on certain OS's. It also
        requires using an explicit synchronization mechanism. This
        would be pretty trivial to add, however.

    Should this just sit on top of the existing vertex array
    implementation, instead of introducing a new set of API calls?

        RESOLUTION: NO. Trying to fit something on top existing vertex
        arrays introduces a lot of confusion as to where the data is
        stored (on the client side vs. on the server side). Adding new
        API that mirrors traditional vertex arrays doesn't seem to
        cumbersome.


New Procedures and Functions

  For creating, updating, and querying object buffers:

    uint NewObjectBufferATI(sizei size, const void *pointer, enum usage)

    boolean IsObjectBufferATI(uint buffer)

    void UpdateObjectBufferATI(uint buffer, uint offset, sizei size, 
                               const void *pointer, enum preserve)

    void GetObjectBufferfvATI(uint buffer, enum pname, float *params)

    void GetObjectBufferivATI(uint buffer, enum pname, int *params)

    void FreeObjectBufferATI(uint buffer)


  For defining vertex arrays inside an object buffer:

    void ArrayObjectATI(enum array, int size, enum type, 
                        sizei stride, uint buffer, uint offset)

  For querying vertex arrays inside an object buffer:

    void GetArrayObjectfvATI(enum array, enum pname, float *params)

    void GetArrayObjectivATI(enum array, enum pname, int *params)

  If EXT_vertex_shader is defined, for defining variant arrays inside
  an object buffer:

    void VariantArrayObjectATI(uint id, enum type, sizei stride,
			       uint buffer, uint offset)

  If EXT_vertex_shader is defined, for querying variant arrays inside
  an object buffer:

    void GetVariantArrayObjectfvATI(uint id, enum pname, 
                                    float *params)

    void GetVariantArrayObjectivATI(uint id, enum pname,
				    int *params)


New Tokens


        STATIC_ATI                      0x8760
        DYNAMIC_ATI                     0x8761


        PRESERVE_ATI                    0x8762
        DISCARD_ATI                     0x8763


        OBJECT_BUFFER_SIZE_ATI          0x8764
        OBJECT_BUFFER_USAGE_ATI         0x8765


        ARRAY_OBJECT_BUFFER_ATI         0x8766
        ARRAY_OBJECT_OFFSET_ATI         0x8767


