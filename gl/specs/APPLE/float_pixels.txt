Name

    APPLE_float_pixels

Name Strings

    GL_APPLE_float_pixels

Contact

    Geoff Stahl, Apple (gstahl 'at' apple.com)
    Jeremy Sandmel, Apple (jsandmel 'at' apple.com)

Status

    Shipping Mac OS X v10.2.3 (version 1.0)

Version

    1.0
    
Number

    368

Dependencies

    Written based on the wording of the OpenGL 2.0 specification.
    
    Depends on (but does not require) ARB_texture_float

    Depends on (but does not require) ARB_color_buffer_float

    Depends on (but does not require) ARB_half_float_pixel
    
    Interacts with APPLEX_texture_float_16_filter.

    Interacts with APPLEX_color_buffer_float_16_blend.

Overview

    This extensions adds texture types, texture internal formats and
    color buffers composed of both 32 bit and 16 floating point numbers.
     16 bit floats (half float) are very similar to the IEEE
    single-precision floating-point standard, except that it has only 5
    exponent bits and 10 mantissa bits. All floating point numbers are
    clamped to the limits of the range representable by their respective
    format.

    Specifically, APPLE_float_pixels adds four pieces of functionality
    to OpenGL.  First, it provides an HALF_APPLE texture type allowing
    clients to pass textures in the half float format.  Second, it adds
    12 additional sized internal formats to allow OpenGL to process and
    maintain texture data in the requested format if possible.  Next, it
    provides the COLOR_FLOAT_APPLE pixel format to allow creation of
    floating point and half float color buffers. Lastly, it provides an
    additional query to allow clients to verify that they have a
    floating point color buffer.

    The HALF_APPLE texture type allows clients to use source textures
    composed of half float color components.  This constant is use in
    the type parameter in DrawPixels, ReadPixels and texturing commands
    with a corresponding GL half data type, which corresponds to a 16
    bit half float, and has no special interpretation.

    Clients can use the 12 additional (6 floating point and 6 half
    float) sized internal texture formats to specify the mapping of R,
    G, B and A values to texture components, as they would with any
    other sized internal texture format.  Note, as is the standard
    practice with OpenGL, implementations should map the sized internal
    texture R, G, B and A values to internal components with memory
    allocations as close as possible to those specified in the sized
    internal format.

    Floating point color buffers are created by specifying the
    appropriate color floating point pixel format attribute for the
    windowing system API in use by the client.  Both 128 bit and 64 bit
    floating point color buffers can be supported, the former with full
    32 bit floating point components and the latter with 16 bit half
    float components.

    Additionally, clients can query to see if they have a floating point
    color buffer using GetBooleanv with COLOR_FLOAT_APPLE as the get
    value.  The number of bits per color buffer component can be
    determined in the usual manner.

Issues:

    1. How is this extension different from the ARB floating point extensions?
    
        Conceptually, this extension can be considered the union of the
        feature sets from the following extensions:

            ARB_texture_float
            ARB_color_buffer_float
            ARB_half_float_pixel
        
        with the following EXCEPTIONS:
        
            * this extension does not support the the per-component
              query of TEXTURE_*_TYPE from ARB_texture_float.

            * this extension only supports the half float pixel type
              from ARB_half_float_pixel for {Draw|Read}|Pixels and
              Tex{Sub}Image{1D|2D|3D}, and for color buffers as
              described by ARB_color_buffer_float.  (Note: unlike the
              ARB_half_float extension, APPLE_float_pixels does not
              support using 16 bit half float data with the imaging
              subset routines that accept images, i.e.,
              ConvolutionFilter{1D|2D}, ColorTable, etc.

            * this extension does not include the ClampColorARB routine
              from ARB_color_buffer_float.  It does, however, use the
              default clamping behavior specified in the
              ARB_color_buffer_float extension.
              
              Note that this means the following in this extension:

                - vertex color outputs are always clamped, regardless of
                  color buffer format
                - fragment color outputs are clamped when writing to a
                  fixed point color buffer and unclamped when writing to
                  a floating point color buffer, and
                - the read color returned by
                  ReadPixels/CopyPixels/GetTexImage/etc. is clamped when
                  reading from a fixed point format and unclamped when
                  reading from a floating point format.

            * unlike ARB_texture_float, this extension only supports
              GL_NEAREST filtering for float (and half float) textures.

            * unlike ARB_color_buffer_float, this extension does not
              support src/dst alpha blending on float (and half float)
              destination color buffers.

    2. Since this extension is more limited than the ARB floating point
       extensions, what is the appropriate (and "future-proof") method
       for an application to use to query for floating point color
       buffer and texture support?
       
        This extension and the related extensions
        APPLEX_color_buffer_float_16_blend and
        APPLEX_texture_float_16_filter, should be considered
        "transitional" in nature. The limited functionality described by
        these extensions is superseded by the more powerful ARB
        extensions and as hardware becomes more capable, it is possible
        that future revisions of OpenGL may deprecate or remove them
        altogether.
       
        As such, to allow for ease of transition to support of the ARB
        floating point extensions, applications are *strongly*
        encouraged to use the following algorithm to query for floating
        point texture and color buffer support:
        
            // any Floating Point Support at all?
            bool supportsFloatColorBuffers = FALSE;
            bool supportsFloatTextures     = FALSE;
            
            // 16 bit/component Floating Point Blend/Filter Support?
            bool supportsFloat16ColorBufferBlending = FALSE;
            bool supportsFloat16TextureFiltering    = FALSE;

            // 32 bit/component Floating Point Blend/Filter Support?
            bool supportsFloat32ColorBufferBlending = FALSE;
            bool supportsFloat32TextureFiltering    = FALSE;
        
            // ===============================================
            // Check for floating point texture support
            // 
            // * First check for full ARB_texture_float
            //   extension and only then check for more
            //   limited APPLE and APPLEX texture extensions
            // ===============================================
            if (extensionSupported("ARB_texture_float"))
            {
                supportsFloatTextures           = TRUE;
                supportsFloat16TextureFiltering = TRUE;
                supportsFloat32TextureFiltering = TRUE;            
            }
            else if (extensionSupported("APPLE_float_pixels"))
            {
                supportsFloatTextures = TRUE;

                if (extensionSupported("APPLEX_texture_float_16_filter"))
                {
                    supportsFloat16TextureFiltering = TRUE;
                }
            }

            // ===============================================
            // Check for floating point color buffer support
            // 
            // * First check for full ARB_color_buffer_float
            //   extension and only then check for more
            //   limited APPLE and APPLEX color buffer extensions
            // ===============================================
            if (extensionSupported("ARB_color_buffer_float"))
            {
                supportsFloatColorBuffers          = TRUE;
                supportsFloat16ColorBufferBlending = TRUE;
                supportsFloat32ColorBufferBlending = TRUE;            
            }
            else if (extensionSupported("APPLE_float_pixels"))
            {
                supportsFloatColorBuffers = TRUE;

                if (extensionSupported("APPLEX_color_buffer_float_16_blend"))
                {
                    supportsFloat16ColorBufferBlending = TRUE;
                }
            }


    3. Why does this extension (and the related APPLEX_*_float_*
       extensions) even exist, given the existence of the ARB, ATI, and
       NVIDIA floating point extensions?
       
        A good question.  This extension was developed contemporaneously
        with the ATI and NVIDIA extensions and support for this
        extension in Mac OS X's OpenGL implementation predates the
        definition of the ARB extensions.  In addition, this extension
        specification attempts to document the behavior of the APPLE
        extension to support use of floating point features on hardware
        which may not support the full feature set described by the ARB
        extensions.  The behavior of the APPLE extension more closely
        matches the feature set of this class of hardware and can be
        used by applications to get a more accurate description of
        native hardware support when falling back to software rendering
        may not be appropriate.

        It is expected that as hardware renderers becomes more capable
        the Mac OS X OpenGL implementation will transition to supporting
        the ARB extensions and may deprecate and/or remove these APPLE
        extensions from the API.  Please see issue #2 for details on how
        to query for floating point support in a "future-proof" manner.


    4. What will happen when the ARB floating point extensions are
       supported?
       
        The APPLE_float_pixels and the related
        APPLEX_texture_float_16_filter and
        APPLEX_color_buffer_float_16_blend extensions are intended as a
        strict subset of the functionality in ARB_texture_float,
        ARB_color_buffer_float, and ARB_half_float_pixel.

        Consequently, an implementation could legally support all of
        these extensions simulataneously, however once the ARB
        extensions are supported there is no need to export the
        APPLE{X}_* floating point extensions.

        Consequently, it's possible that implementations may deprecate
        or remove the APPLE_float_pixels,
        APPLEX_texture_float_16_filter, and
        APPLEX_color_buffer_float_16_blend extensions when the
        corresponding ARB extensions are supported by the underlying
        hardware.  Applications should pay attention to issue #2 above
        to prepare for this possibility.
        

New Procedures and Functions

    None

New Tokens


      HALF_APPLE                      0x140B        // Same as HALF_FLOAT_NV/ARB


      COLOR_FLOAT_APPLE               0x8A0F
      

      RGBA_FLOAT32_APPLE              0x8814        // Same as RGBA_FLOAT32_ATI/ARB
      RGB_FLOAT32_APPLE               0x8815        // Same as RGB_FLOAT32_ATI/ARB              
      ALPHA_FLOAT32_APPLE             0x8816        // Same as ALPHA_FLOAT32_ATI/ARB            
      INTENSITY_FLOAT32_APPLE         0x8817        // Same as INTENSITY_FLOAT32_ATI/ARB        
      LUMINANCE_FLOAT32_APPLE         0x8818        // Same as LUMINANCE_FLOAT32_ATI/ARB        
      LUMINANCE_ALPHA_FLOAT32_APPLE   0x8819        // Same as LUMINANCE_ALPHA_FLOAT32_ATI/ARB  
      RGBA_FLOAT16_APPLE              0x881A        // Same as RGBA_FLOAT16_ATI/ARB             
      RGB_FLOAT16_APPLE               0x881B        // Same as RGB_FLOAT16_ATI/ARB              
      ALPHA_FLOAT16_APPLE             0x881C        // Same as ALPHA_FLOAT16_ATI/ARB            
      INTENSITY_FLOAT16_APPLE         0x881D        // Same as NTENSITY_FLOAT16_ATI/ARB        
      LUMINANCE_FLOAT16_APPLE         0x881E        // Same as LUMINANCE_FLOAT16_ATI/ARB        
      LUMINANCE_ALPHA_FLOAT16_APPLE   0x881F        // Same as LUMINANCE_ALPHA_FLOAT16_ATI/ARB  

