Name

    APPLE_fence

Name Strings

    GL_APPLE_fence

Contact

    Geoff Stahl, Apple (gstahl 'at' apple.com)

Status

    Shipping as of August 24, 2002 (Mac OS X v10.2)

Version

    $Date: 2002/08/23 00:31:45 $ $Revision: 1.3 $
	
Number

    272

Dependencies

    None

Overview

    This extension is provided a finer granularity of synchronizing GL command
    completion than offered by standard OpenGL, which currently offers only two
    mechanisms for synchronization: Flush and Finish. Since Flush merely assures
    the user that the commands complete in a finite (though undetermined) amount
    of time, it is, thus, of only modest utility.  Finish, on the other hand,
    stalls CPU execution until all pending GL commands have completed forcing
    completely synchronous operation, which most often not the desired result.
    This extension offers a middle ground - the ability to "finish" a subset of
    the command stream, and the ability to determine whether a given command has
    completed or not.

    This extension introduces the concept of a "fence" to the OpenGL command
    stream with SetFenceAPPLE.  Once the fence is inserted into the command
    stream, it can be tested for its completion with TestFenceAPPLE. Moreover,
    the application may also request a partial Finish up to a particular "fence"
    using the FinishFenceAPPLE command -- that is, all commands prior to the
    fence will be forced to complete until control is returned to the calling
    process.  These new mechanisms allow for synchronization between the host
    CPU and the GPU, which may be accessing the same resources (typically
    memory).

    Fences are created and deleted, as are other objects in OpenGL, specifically
    with GenFencesAPPLE and DeleteFencesAPPLE.  The former returns a list of
    unused fence names and the later deletes the provided list of fence names.

    In addition to being able to test or finish a fence this extension allows
    testing for other types of completion, including texture objects, vertex
    array objects, and draw pixels. This allows the client to use
    TestObjectAPPLE or FinishObjectAPPLE with FENCE_APPLE, TEXTURE,
    VERTEX_ARRAY, or DRAW_PIXELS_APPLE with the same type of results as
    TestFenceAPPLE and FinishFenceAPPLE.  Specifically, using the FENCE_APPLE
    type is equivalent to calling TestFenceAPPLE or FinishFenceAPPLE with the
    particular fence name.  Using TEXTURE as the object type tests or waits for
    completion of a specific texture, meaning when there are no pending
    rendering commands which use that texture object. Using the VERTEX_ARRAY
    type will test or wait for drawing commands using that particular vertex
    array object name.  Finally, DRAW_PIXELS_APPLE will wait or test for
    completion of all pending DrawPixels commands.  These tests and finishes
    operate with the same limitations and results as test and finish fence.

    One use of this extension is in conjunction with APPLE_vertex_array_range to
    determine when graphics hardware has completed accessing vertex data from a
    vertex array range.  Once a fence has been tested TRUE or finished, all
    vertex indices issued before the fence must have completed being accessed.
    This ensures that the vertex data memory corresponding to the issued vertex
    indices can be safely modified (assuming no other outstanding vertex indices
    are issued subsequent to the fence).
    
Issues

	How is TestObjectAPPLE or FinishObjectAPPLE used with DRAW_PIXELS_APPLE?
		
		Resolution:  Currently there is no support DrawPixels with storage using
		the APPLE_client_storage extension and thus this option has no utility,
		due to implementation specifics, which always copy the DrawPixels
		buffer, thus allowing the client to immediately modify the data used by
		DrawPixels.  Once the APPLE_client_storage extension is supported,
		DrawPixels modification synchronization will be required after drawing
		with a buffer, which resides in client space.

    Do we need an IsFenceAPPLE command?

        RESOLUTION:  Yes.  IsFenceAPPLE makes APPLE_fence's API orthogonal to
        other OpenGL object interfaces, and can be used as any other Is...
        command would be.

    Are the fences sharable between multiple contexts?

        RESOLUTION:  No.

    What is the relative performance of the calls?

        Execution of a SetFenceAPPLE is not free.  In the initial
        implementation, a Flush is generated.  This will likely change for
        future implementations and should not be depended on.  A Finish will not
        be generated in any case.

    Is the TestFenceAPPLE call really necessary?  How often would this be used
    compared to the FinishFenceAPPLE call (which also flushes to ensure this
    happens in finite time)?

        TestFenceAPPLE allows clients to provide logic to handle
        synchronization issues rather than forcing completely synchronous
        operation at the point of testing or finishing.

    Should we allow these commands to be compiled within display list?
    Which ones?  How about within Begin/End pairs?

        RESOLUTION:  DeleteFencesAPPLE, GenFencesAPPLE, TestFenceAPPLE,
        TestObjectAPPLE, and IsFenceAPPLE are executed immediately while
        FinishFenceAPPLE, FinishObjectAPPLE and SetFenceAPPLE are compiled. 
        None of these commands are allowed within Begin/End pairs.

New Procedures and Functions

	void GenFencesAPPLE(sizei n, uint *fences);

	void DeleteFencesAPPLE(sizei n, const uint *fences);

	void SetFenceAPPLE(uint fence);

	boolean IsFenceAPPLE(uint fence);

	boolean TestFenceAPPLE(uint fence);

	void FinishFenceAPPLE(uint fence);

	boolean TestObjectAPPLE(enum object, uint name);

	void FinishObjectAPPLE(enum object, int name);

New Tokens


        DRAW_PIXELS_APPLE                    0x8A0A
        FENCE_APPLE                          0x8A0B

