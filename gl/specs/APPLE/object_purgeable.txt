Name

    APPLE_object_purgeable

Name Strings

    GL_APPLE_object_purgeable

Contributors

    Andrew Barnes
    Bob Beretta
    Kenneth Dyke
    Alex Eddy
    John Harper
    Charlie Lao
    Jeremy Sandmel

Contact

    Charlie Lao, Apple Computer Inc. (clao 'at' apple.com)

Status

    TBD

Version

    Last Modified Date: September 29, 2006

Number

    371

Dependencies

    OpenGL 1.5 is required.
    
    The extension is written against the OpenGL 1.5 Specification.

Overview

    This extension provides the ability to mark the storage of OpenGL
    objects as "purgeable".

    Many of today's modern virtual memory systems include the concept of
    purgeability in order to avoid unnecessary paging when the object
    contents are no longer needed.  In OpenGL, objects such as textures,
    vertex buffers, pixel buffers, and renderbuffers all have
    significant storage requirements.  By default, the OpenGL is
    required to preserve the contents of these objects regardless of
    system resource stress, such as vram shortage or physical memory
    shortage.  Often this is accomplished by temporarily paging the
    contents of objects that are not currently needed to some kind of
    secondary storage area.  This paging operation can be an unnecessary
    computational expense in the cases where the data is not going to be
    used again or where the content can be reproduced by the application
    with less expense than the paging operation would require.
    
    This extension defines a mechanism for the application to mark the
    storage of OpenGL objects as "purgeable" in order to influence these
    paging operations.  The application can further control the
    semantics of making object storage "purgeable" with two options
    ("volatile" and "released") and "unpurgeable" with two options
    ("undefined" and "retained")

    Applications that use this extension will typically follow one of
    two operational models.  The typical model for most applications is
    to mark an object storage as "purgeable" with the "volatile" option,
    and then later mark the storage as "unpurgeable" with the "retained"
    option. When this happens, the application may or may not need to
    respecify the object contents, depending on the whether the object
    storage was actually released.  The application can find out whether
    the storage was released by examining the return value of the
    function which marks the storage as "unpurgeable".  This model is
    useful when the application does not know at the time it marks the
    object storage as "purgeable" whether it will later need those
    contents to be valid.

    Another operational model is for an application to mark the storage
    for an object as "purgeable" with the "released" option, and then
    later mark the object "unpurgeable" with the "undefined" option.  In
    this latter model, the application intends to unconditionally reload
    the object contents later on, and so it tells the GL that it is okay
    if the contents are "undefined" when the storage is re-allocated.

    Note that in both models, it is possible for the contents to become
    undefined since they could have actually been purged from the system
    in either case.  The various options are still useful, however,
    since they give more information to the GL about what the
    application expects to happen and the GL can use this information to
    make better predictions about which paging choices will be more
    efficient.

IP Status

    No known IP claims.

Issues

    1. Why use two functions rather than just one? 
    
        The reason we chose two functions is that switching between the
        two possible object states - purgeable and unpurgeable - might
        be expensive.  In addition, the return values of the operation
        may be different depending on what state the object storage is
        in and whether it has been purged or not.  Therefore, we want to
        enforce that the state is changed in matching pairs of function
        calls, similar to Begin/End.  In order to enforce this behavior,
        we require two functions.

        Applications are required to call ObjectPurgeable and
        ObjectUnpurgeable in matched pairs, otherwise INVALID_OPERATION
        is generated.

    2. What does calling ObjectUnpurgeable with <option> set to
       UNDEFINED_APPLE really mean?
    
        An application calls ObjectUnpurgeable in order to change the
        state of the object storage to unpurgeable.  This is the
        "default" state for object storage as defined traditionally in
        GL.

        Further, by using the <option> of UNDEFINED_APPLE, the
        application is also indicating that it does not care about the
        previous contents of the storage, if they still exist.  This
        gives the GL the freedom to allocate new storage or simply reuse
        the old storage without spending time to figure out whether the
        storage was actually freed and without having to tell the
        application which choice was made. In addition, this allows the
        function to return without blocking.

        In contrast, calling ObjectUnpurgeable with <option> set to
        RETAINED_APPLE requests the GL actually determine whether or not
        it is possible to retain the original contents of the object,
        and to restore the object storage to the previous contents, if
        they still exist.  This operation generally requires a flush of
        the current command stream and often involveds additional work
        to determine the state of object.

    3. What's the difference between calling ObjectPurgeable and calling
       DeleteTextures?
    
        Calling ObjectPurgeable allows the GL to release all storage
        that the GL has allocated for the object's contents, but will
        still retain the object name and other non-content related state
        of the object.  If the application intends to re-use the object
        again later, it will indicate so calling ObjectUnpurgeable.

        In contrast, DeleteTextures deletes the object storage, the
        object name, and the rest of the object state.  The object can
        never again be used.

        Note that this means to set the object's name as unused and to
        delete non-content related state of the object, the application
        is still responsible for calling DeleteTextures.

        There are some additional subtle differences though.

        In general, calling ObjectPurgeable with the <option>
        VOLATILE_APPLE requires less work of the GL than calling
        ObjectPurgeable with the <option> set to RELEASED_APPLE.
        Further, calling ObjectPurgeable with either option generally
        requires less work of the GL than DeleteTextures.

        Applications are encouraged, therefore, to use ObjectPurgeable
        with the <option> set to VOLATILE_APPLE where possible and fall
        back to ObjectPurgeable with the <option> set to RELEASED_APPLE
        only if they prefer to have the GL do some amount of work to try
        to release the storage.  Only if the application really requires
        the deletion of the object itself, should the application use
        DeleteTextures.

        Finally note, though the discussion above refers to
        DeleteTextures, the same semantics apply to all object types
        with Delete* operations, such as DeleteBuffers,
        DeleteRenderbuffers, etc. that support this extension.

    4. What should happen when ObjectPurgeable or ObjectUnpurgeable is
       called between Begin/End?
    
        This is illegal and returns INVALID_OPERATION error.

    5. What should happen if ObjectPurgeable or ObjectUnpurgeable is
       called on a currently bound texture, whether it is bound to the
       current context or another context?
    
        If the current context marks the storage of a currently bound
        object as "purgeable", then attempts to read from or write to
        the contents of that storage will result in undefined behavior.

        Considering the multiple context case, we use the precedent of
        all other state changes made by one context to an object bound
        by another context.  Namely, changes made to an object by
        context A or only guaranteed to be "visible" to context B the
        next time context B binds that object.  In the interim period
        the results of the state change are undefined.

        For this extension, this means if context A marks an object's
        storage as purgeable and that object is also bound by context B,
        then it is undefined as to whether the object's storage will
        have defined contents when used by context B. Note that in the
        case of this particular extension, the whole point is to allow
        the contents of the storage to become undefined so this is not a
        particularly surprising outcome.

        Applications are therefore advised to assume that they can not
        rely on validity of the contents of any object whose storage has
        been marked purgeable by any other context.  Further, until some
        context has marked the object storage as "unpurgeable" again and
        the current context has re-bound the object, the current context
        should not assume the contents are valid either.  And even then
        the contents should be assumed to be valid if and only if the
        contents have been respecified or ObjectUnpurgeable returned the
        value RETAINED_APPLE.

    6. What should happen if the TestObject routine from the APPLE_fence
       extension is called on an object whose storage has been marked
       purgeable?
    
        In short, it should operate "normally".

        To be specific, if TestObject is called after calling
        ObjectPurgeable with <option> set to VOLATILE_APPLE, the GL will
        still determine if there are any pending operations using the
        object, and TestObject will return TRUE or FALSE depending on
        what it finds.

        If TestObject is called after calling ObjectPurgeable with
        <option> set to RELEASED_APPLE, the TestObject will generally
        immediately return TRUE even though the object may still be in
        use.  This is acceptable since from user's point of view, the
        object's storage has been freed from further use by the GL.

    7. How does APPLE_object_purgeable interact with the
       APPLE_texture_range extension?
    
        First note that depending on the value of the storage hint
        provided in the APPLE_texture_range extension, the GL may have
        made multiple copies of the texture data.

        In general, calling ObjectPurgeable with <option> set to
        VOLATILE_APPLE option indicates that the GL should mark the
        multiple copies of the storage as candidates for eviction but
        should only release them as needed.  In contrast, using the
        <option> RELEASED_APPLE indicates that GL should try to go ahead
        and release the storage for as many of these copies as is
        efficient.

    8. How does APPLE_object_purgeable interact with the
       APPLE_client_storage extension?
    
        For reference, APPLE_client_storage allows the application to
        indicate that it will be responsible for allocating and
        retaining the storage for a texture object.
        
        In the APPLE_object_purgeable extension it is up to the
        implementation to determine what happens when an object's
        storage is marked purgeable and its up to the application to
        query to determine whether the storage has been released.  Given
        that, the APPLE_client_storage has no real practical
        interactions with APPLE_object_purgeable.

        However, if APPLE_client_storage is supported on a platform that
        gives the application control over the volatility of of client
        memory, for instance via some sort of virtual memory system
        call, then it's possible the application use the
        platform-specific virtual memory API to mark as volatile the the
        memory backing a texture using APPLE_client_storage for its
        storage.  The application on such a platform would be
        responsible for using additional virtual memory system calls to
        determine what happened to memory that was marked purgeable when
        it goes to access that memory later on. In this scenario, the
        effect would be very similar to the results of using the
        APPLE_object_purgeable to mark a texture object's storage as
        purgeable, but there is no direct interaction between the two
        API's.
    
    9. How does APPLE_object_purgeable interact with the
       aglSurfaceTexture API?
    
        For reference, the aglSurfaceTexture allows the application to
        specify an AGL drawable as the storage for a GL texture object.
        Such a texture object is informally called a "surface texture".

        Similar to the APPLE_client_storage case, it is up to the API
        that allocated the storage object to handle the purgeability of
        that object.  Given that, the APPLE_client_storage has no real
        practical interactions with AGL surface textures.
        

    10. How does APPLE_object_purgeable interact with the
        ARB_vertex_buffer_object and ARB_pixel_buffer_object extensions?
    
        The interactions should be analogous to those that occur with
        texture objects.
        
        To mark the storage for a buffer object as purgeable or
        unpurgeable, the application can specify BUFFER_OBJECT_APPLE as
        the <objectType> parameter in ObjectPurgeable or 
        ObjectUnpurgeable, respectively.  The same rules about undefined
        results from reading from or writing to the buffer object
        storage while PURGEABLE_APPLE is TRUE apply as well.

    13. After an object's storage has been marked as purgeable, what
        should happen if CopyTexImage{1|2}D, CopyTexSubImage{1|2}D,
        TexSubImage{1|2|3}D, or TexImage{1|2|3}D is called on the
        texture? What if user try to texture from it or render to it?
        
        After an object's storage has been marked purgeable, any usage
        of the object is undefined until it is marked unpurgeable.
    

New Procedures and Functions

    enum ObjectPurgeableAPPLE(enum objectType, uint name, enum option)
    enum ObjectUnpurgeableAPPLE(enum objectType, uint name, enum option)
    void GetObjectParameterivAPPLE(enum objectType, uint name, enum
                                   pname, int* params)

New Types

    None

New Tokens

    
    RELEASED_APPLE        0x8A19
    VOLATILE_APPLE        0x8A1A

    
    RETAINED_APPLE        0x8A1B
    UNDEFINED_APPLE       0x8A1C

    
    PURGEABLE_APPLE        0x8A1D

    
    BUFFER_OBJECT_APPLE        0x85B3
    
	
