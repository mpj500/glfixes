Name

    APPLE_flush_buffer_range

Name Strings

    GL_APPLE_flush_buffer_range

Contact

    Chris Niederauer, Apple (ccn 'at' apple.com)

Status

    Shipping on Mac OS X.

Version

    Last Modified Date: 19 March 2008
    Author Revision: 1.1

Number

    321

Dependencies

    Buffer Objects as per ARB_vertex_buffer_object or OpenGL 1.5 are required.

    If ARB_pixel_buffer_object is NOT supported and the OpenGL version is less
    than 2.1, ignore references to PIXEL_UNPACK_BUFFER and PIXEL_PACK_BUFFER.

    If APPLE_fence or similar fencing mechanism is NOT suppported, Finish can
    be used in place of TestObject, FinishObject, TestFence and FinishFence.

    Written based on the wording of the OpenGL 2.1 specification.

Overview

    APPLE_flush_buffer_range expands the buffer object API to allow greater
    performance when a client application only needs to write to a sub-range
    of a buffer object. To that end, this extension introduces two new buffer
    object features: non-serialized buffer modification and explicit sub-range
    flushing for mapped buffer objects.

    OpenGL requires that commands occur in a FIFO manner meaning that any
    changes to buffer objects either block until the data has been processed by
    the OpenGL pipeline or else create extra copies to avoid such a block.  By
    providing a method to asynchronously modify buffer object data, an
    application is then able to manage the synchronization points themselves
    and modify ranges of data contained by a buffer object even though OpenGL
    might still be using other parts of it.

    This extension also provides a method for explicitly flushing ranges of a
    mapped buffer object so OpenGL does not have to assume that the entire
    range may have been modified.

    Affects ARB_vertex_buffer_object, ARB_pixel_buffer_object and OpenGL 1.5
    Buffer Objects.

Issues

    Should the ability to update other Buffer Object state such as BUFFER_SIZE
    and BUFFER_USAGE be added to BufferParameteriAPPLE?

        RESOLVED:  No.  API already exists for setting this state and allowing
        this new API to update this state would add more semantics that this
        extension is not trying to address.  Also as decided when working on
        the ARB_vertex_buffer_object extension: "It is desirable for the
        implementation to know the usage when the buffer is initialized, so
        including it in the initialization command makes sense."

    Should a MapSubBuffer API be added to avoid having the application manually
    flush memory which is not modified within a buffer object?

        RESOLVED:  No.  An application may still want to modify multiple
        sections of a buffer object simultaneously such as for procedural data
        and providing a range flushing routine allows an implementation to
        effectively achieve the same performance benefits.

        Secondly, providing a MapSubBuffer routine might be confusing to
        developers as one might think that MapSubBuffers could know which
        sections need to block or provide temporary intermediary buffers and
        in theory achieve the same benefits as adding a flag that states that
        the application would like to asynchronously modify some buffer object
        data; however, implementing a "smart" MapSubBuffer function would be
        difficult to make efficient.

    When flushing ranges manually, should new API be added or should
    BufferSubData be overloaded?

        RESOLVED:  New API should be added specifically for this task.  Trying
        to override BufferSubData becomes cumbersome for many reasons.  In
        order to use BufferSubData, the behavior would need to change when
        called inside of a MapBuffer/UnmapBuffer pair to not throw an error and
        the <data> parameter would then either not be used or cause a specific
        behavior.  It is much simpler to provide new API specifically targeted
        at the task of manually flushing memory regions.  This is also less
        prone to errors in legacy applications that may incorrectly use
        BufferSubData in situations that should cause invalid operation errors
        prior to the introduction of this extension.

New Procedures and Functions

    void BufferParameteriAPPLE(enum target, enum pname, int param);

    void FlushMappedBufferRangeAPPLE(enum target, intptr offset,
                                     sizeiptr size);

New Tokens


        BUFFER_SERIALIZED_MODIFY_APPLE      0x8A12
        BUFFER_FLUSHING_UNMAP_APPLE         0x8A13

