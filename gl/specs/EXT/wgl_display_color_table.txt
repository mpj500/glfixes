Name

    EXT_display_color_table

Name Strings

    WGL_EXT_display_color_table

Version

    $Date: 1999/04/03 08:41:11 $ $Revision: 1.3 $

Number

    167

Dependencies

    None

Overview

    This extension provides the means to define display color lookup tables
    and associate them with rendering contexts. This is used primarily for
    color gamut adjustment (e.g. gamma correction). It may also be used for
    special effects like screen flashing, so it's important that creating
    and binding tables be efficient.

    Display color tables are an extension to the WGL window system interface
    layer defined by Microsoft, not an OpenGL core extension. Because WGL
    provides no built-in extension mechanism, the presence of the extension
    is advertised through the OpenGL GL_EXTENSIONS string. Once the
    extension is known to exist, the address of the entry points required
    must be obtained via wglGetProcAddress().

    There is an existing SetDeviceGammaRamp entry point in the Windows API.
    It's apparently not implemented on NT, and only allows specifying 8-bit
    LUT entries, which is inadequate for many applications. There may also
    be concerns with the Windows API's ability to support secondary display
    devices, like 3dfx Voodoo. Finally (as pointed out by Rendition),
    putting gamma table definition in WGL allows the table updates to be
    synchronized with the rest of the WGL/OpenGL command stream sent to
    hardware, and to take place during vertical blanking.

Issues

    * What do we do for devices that support the extension, but don't allow
	changing their default ramp?

    * We probably want LUT 0 to be whatever is defined by the system, not
       default to a linear ramp.

    * Are tables persistent (or would we like them to be persistent) across
	application invocations, ala the XSGIvcSetChannelGammaMap calls?

    * How do we signal errors in WGL? For the moment, I assume they return a
	status value which is WGL_OK or an error indicating the problem.

    * Use GL or Windows types for parameters? Consistency with
	existing WGL calls indicates we should use Windows types.

    * How are table IDs obtained (defined by the system or arbitrary app
	choice)? How many tables are allowed?

    * What should the format and mapping of table entries be? GLfloat (or
	perhaps GLclampf?) would be easiest, but might present performance
	issues. Rendition suggests that most devices use 8-bit LUTs, for
	which unsigned byte entries is sufficient. It may make sense to
	allow two formats (ubyte and ushort), like the XSGIvc GLX extension.

    * Do we want some sort of enable/disable to make a drawable start using
	the table?

    * Do we need query functions to identify the table bound to the current
	drawable and its contents?

    * How much math describing the table lookup process is needed?

    * What's the relative order of retrace, display table update, and buffer
	swap? What happens when a drawable is rebound several times prior to
	retrace (sure, the latest one takes effect, but should we be
	precise?)

    * What happens when we have a frame buffer with different numbers of
	bits for R, G, and B (e.g. 565 RGB)? Resampling as defined will
	ensure that we get the right number of table entries, but the
	definition implies that table entries for different color components
	of the same intensity will actually be found at different indices!
	This seems non-intuitive. Maybe specify tables for each component
	separately?

New Procedures and Functions

    GLboolean wglCreateDisplayColorTableEXT(GLushort id);

    GLboolean wglLoadDisplayColorTableEXT(GLushort *table, GLuint length);

    GLboolean wglBindDisplayColorTableEXT(GLushort id);

    void wglDestroyDisplayColorTableEXT(GLushort id);

New Tokens


