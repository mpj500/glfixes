Name

    EXT_vertex_weighting

Name Strings

    GL_EXT_vertex_weighting

Contact

    Mark J. Kilgard, NVIDIA Corporation (mjk 'at' nvidia.com)

Notice

    Copyright NVIDIA Corporation, 1999, 2000.

Status

    Discontinued.

    NVIDIA no longer supports this extension in driver updates
    after November 2002.  Instead, use either ARB_vertex_program &
    NV_vertex_program.

Version

    NVIDIA Date: January 3, 2003
    $Date$ $Revision$  

Number

    188

Dependencies

    None

    Written based on the wording of the OpenGL 1.2 specification but not
    dependent on it.

Overview

    The intent of this extension is to provide a means for blending
    geometry based on two slightly differing modelview matrices.
    The blending is based on a vertex weighting that can change on a
    per-vertex basis.  This provides a primitive form of skinning.

    A second modelview matrix transform is introduced.  When vertex
    weighting is enabled, the incoming vertex object coordinates are
    transformed by both the primary and secondary modelview matrices;
    likewise, the incoming normal coordinates are transformed by the
    inverses of both the primary and secondary modelview matrices.
    The resulting two position coordinates and two normal coordinates
    are blended based on the per-vertex vertex weight and then combined
    by addition.  The transformed, weighted, and combined vertex position
    and normal are then used by OpenGL as the eye-space position and
    normal for lighting, texture coordinate, generation, clipping,
    and further vertex transformation.

Issues

    Should the extension be written to extend to more than two vertex
    weights and modelview matrices?

      RESOLUTION: NO.  Supports only one vertex weight and two modelview
      matrices.  If more than two is useful, that can be handled with
      another extension.

    Should the weighting factor be GLclampf instead of GLfloat?
    
      RESOLUTION:  GLfloat.  Though the value of a weighting factors
      outside the range of zero to one (and even weights that do not add
      to one) is dubious, there is no reason to limit the implementation
      to values between zero and one.

    Should the weights and modelview matrices be labeled 1 & 2 or 0 & 1?

      RESOLUTION:  0 & 1.  This is consistent with the way lights and
      texture units are named in OpenGL.  Make GL_MODELVIEW0_EXT
      be an alias for GL_MODELVIEW.  Note that the GL_MODELVIEW0_EXT+1
      will not be GL_MODELVIEW1_EXT as is the case with GL_LIGHT0 and
      GL_LIGHT1.

    Should there be a way to simultaneously Rotate, Translate, Scale,
    LoadMatrix, MultMatrix, etc. the two modelview matrices together?

      RESOLUTION:  NO.  The application must use MatrixMode and repeated
      calls to keep the matrices in sync if desired.

    Should the secondary modelview matrix stack be as deep as the primary
    matrix stack or can they be different sizes?

      RESOLUTION:  Must be the SAME size.  This wastes a lot of memory
      that will be probably never be used (the modelview matrix stack
      must have at least 32 entries), but memory is cheap.

      The value returned by MAX_MODELVIEW_STACK_DEPTH applies to both
      modelview matrices.

    Should there be any vertex array support for vertex weights.

      RESOLUTION:  YES.

    Should we have a VertexWeight2fEXT that takes has two weight values?

      RESOLUTION:  NO.  The weights are always vw and 1-vw.

    What is the "correct" way to blend matrices, particularly when wo is
    not one or the modelview matrix is projective?

      RESOLUTION:  While it may not be 100% correct, the extension blends
      the vertices based on transforming the object coordinates by
      both M0 and M1, but the resulting w coordinate comes from simply
      transforming the object coordinates by M0 and extracting the w.

      Another option would be to simply blend the two sets of eye
      coordinates without any special handling of w.  This is harder.

      Another option would be to divide by w before blending the two
      sets of eye coordinates.  This is awkward because if the weight
      is 1.0 with vertex weighting enabled, the result is not the
      same as disabling vertex weighting since EYE_LINEAR texgen
      is based of of the non-perspective corrected eye coordinates.

    As specified, the normal weighting and combination is performed on
    unnormalized normals.  Would the math work better if the normals
    were normalized before weighting and combining?

      RESOLUTION:  Vertex weighting of normals is after the
      GL_RESCALE_NORMAL step and before the GL_NORMALIZE step.

    As specified, feedback and selection should apply vertex weighting
    if enabled.  Yuck, that would mean that we need software code for
    vertex weighting.

       RESOLUTION:  YES, it should work with feedback and selection.

    Sometimes it would be useful to mirror changes in both modelview
    matrices.  For example, the viewing transforms are likely to be
    different, just the final modeling transforms would be different.
    Should there be an API support for mirroring transformations into
    both matrices?

      RESOLUTION:  NO.  Such support is likely to complicate the
      matrix management in the OpenGL.  Applications can do a
      Get matrix from modelview0 and then a LoadMatrix into modelview1
      manually if they need to mirror things.

      I also worry that if we had a mirrored matrix mode, it would
      double the transform concatenation work if used naively.

    Many of the changes to the two modelview matrices will be the same.
    For example, the initial view transform loaded into each will be the
    same.  Should there be a way to "mirror" changes to both modelview
    matrices?

      RESOLUTION:  NO.  Mirroring matrix changes would complicate the
      driver's management of matrices.  Also, I am worried that naive
      users would mirror all transforms and lead to lots of redundant
      matrix concatenations.  The most efficient way to handle the
      slight differences between the modelview matrices is simply
      to GetFloat the primary matrix, LoadMatrix the values in the
      secondary modelview matrix, and then perform the "extra" transform
      to the secondary modelview matrix.

      Ideally, a glCopyMatrix(GLenum src, GLenum dst) type OpenGL
      command could make this more efficient.  There are similiar cases
      where you want the modelview matrix mirrored in the texture matrix.
      This is not the extension to solve this minor problem.

    The post-vertex weighting normal is unlikely to be normalized.
    Should this extension automatically enable normalization?

      RESOLUTION:  NO.  Normalization should operate as specified.
      The user is responsible for enabling GL_RESCALE_NORMAL or
      GL_NORMALIZE as needed.

      You could imagine cases where the application only sent
      vertex weights of either zero or one and pre-normalized normals
      so that GL_NORMALIZE would not strictly be required.

      Note that the vertex weighting of transformed normals occurs
      BEFORE normalize and AFTER rescaling.  See the issue below for
      why this can make a difference.

    How does vertex weighting interact with OpenGL 1.2's GL_RESCALE_NORMAL
    enable?

      RESOLUTION:  Vertex weighting of transformed normals occurs
      BEFORE normalize and AFTER rescaling.

      OpenGL 1.2 permits normal rescaling to behave just like normalize
      and because normalize immediately follows rescaling, enabling
      rescaling can be implementied by simply always enabling normalize.

      Vertex weighting changes this.  If one or both of the modelview
      matrices has a non-uniform scale, it may be useful to enable
      rescaling and normalize and this operates differently than
      simply enabling normalize.  The difference is that rescaling
      occurs before the normal vertex weighting.

      An implementation that truly treated rescaling as a normalize
      would support both a pre-weighting normalize and a post-weighting
      normalize.  Arguably, this is a good thing.

      For implementations that perform simply rescaling and not a full
      normalize to implement rescaling, the rescaling factor can be
      concatenated into each particular inverse modelview matrix.

New Procedures and Functions

    void VertexWeightfEXT(float weight);

    void VertexWeightfvEXT(float *weight);

    void VertexWeightPointerEXT(int size, enum type, sizei stride, void *pointer);

New Tokens


        VERTEX_WEIGHTING_EXT                0x8509


        MODELVIEW0_EXT                      0x1700  (alias to MODELVIEW enumerant)
        MODELVIEW1_EXT                      0x850A


        MODELVIEW0_MATRIX_EXT               0x0BA6  (alias to MODELVIEW_MATRIX)
        MODELVIEW1_MATRIX_EXT               0x8506
        CURRENT_VERTEX_WEIGHT_EXT           0x850B
        VERTEX_WEIGHT_ARRAY_EXT             0x850C
        VERTEX_WEIGHT_ARRAY_SIZE_EXT        0x850D
        VERTEX_WEIGHT_ARRAY_TYPE_EXT        0x850E
        VERTEX_WEIGHT_ARRAY_STRIDE_EXT      0x850F
        MODELVIEW0_STACK_DEPTH_EXT          0x0BA3  (alias to MODELVIEW_STACK_DEPTH)
        MODELVIEW1_STACK_DEPTH_EXT          0x8502


        VERTEX_WEIGHT_ARRAY_POINTER_EXT     0x8510

