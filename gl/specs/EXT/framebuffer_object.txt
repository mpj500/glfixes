Name

    EXT_framebuffer_object

Name Strings

    GL_EXT_framebuffer_object

Contributors

    Kurt Akeley
    Jason Allen
    Bob Beretta
    Pat Brown
    Matt Craighead
    Alex Eddy
    Cass Everitt
    Mark Galvan
    Michael Gold
    Evan Hart
    Jeff Juliano
    Mark Kilgard
    Dale Kirkland
    Jon Leech
    Bill Licea-Kane
    Barthold Lichtenbelt
    Kent Lin
    Rob Mace
    Teri Morrison
    Chris Niederauer 
    Brian Paul
    Paul Puey
    Ian Romanick
    John Rosasco
    R. Jason Sams
    Jeremy Sandmel
    Mark Segal
    Avinash Seetharamaiah
    Folker Schamel
    Daniel Vogel
    Eric Werness
    Cliff Woolley

Contacts

    Jeff Juliano, NVIDIA Corporation (jjuliano 'at' nvidia.com)
    Jeremy Sandmel, Apple Computer (jsandmel 'at' apple.com)

Status

    Complete. 
    Approved by the ARB "superbuffers" Working Group on January 31, 2005.
    Despite being controlled by the ARB WG, this is not an officially
    approved ARB extension at this time, thus the "EXT" tag.

Version

    Last Modified Date: September 23, 2013
    Revision: #121

Number
    310

Dependencies

    OpenGL 1.1 is required.

    WGL_ARB_make_current_read affects the definition of this extension.

    GLX 1.3 / GLX_SGI_make_current_read affects the definition of this
    extension.

    ATI_draw_buffers affects the definition of this extension.

    ARB_draw_buffers affects the definition of this extension.

    ARB_fragment_program affects the definition of this extension.

    ARB_fragment_shader affects the definition of this extension.

    ARB_framebuffer_object and OpenGL 3.0 core affect the definition of
    this extension.

    ARB_texture_rectangle affects the definition of this extension.

    ARB_vertex_shader affects the definition of this extension.

    EXT_packed_depth_stencil affects the definition of this extension.

    NV_float_buffer affects the definition of this extension.

    NV_texture_shader affects the definition of this extension.

    Written based on the wording of the OpenGL 1.5 specification.

Overview

    This extension defines a simple interface for drawing to rendering
    destinations other than the buffers provided to the GL by the
    window-system.

    In this extension, these newly defined rendering destinations are
    known collectively as "framebuffer-attachable images".  This
    extension provides a mechanism for attaching framebuffer-attachable
    images to the GL framebuffer as one of the standard GL logical
    buffers: color, depth, and stencil.  (Attaching a
    framebuffer-attachable image to the accum logical buffer is left for
    a future extension to define).  When a framebuffer-attachable image
    is attached to the framebuffer, it is used as the source and
    destination of fragment operations as described in Chapter 4.

    By allowing the use of a framebuffer-attachable image as a rendering
    destination, this extension enables a form of "offscreen" rendering.
    Furthermore, "render to texture" is supported by allowing the images
    of a texture to be used as framebuffer-attachable images.  A
    particular image of a texture object is selected for use as a
    framebuffer-attachable image by specifying the mipmap level, cube
    map face (for a cube map texture), and z-offset (for a 3D texture)
    that identifies the image.  The "render to texture" semantics of
    this extension are similar to performing traditional rendering to
    the framebuffer, followed immediately by a call to CopyTexSubImage.
    However, by using this extension instead, an application can achieve
    the same effect, but with the advantage that the GL can usually
    eliminate the data copy that would have been incurred by calling
    CopyTexSubImage.

    This extension also defines a new GL object type, called a
    "renderbuffer", which encapsulates a single 2D pixel image.  The
    image of renderbuffer can be used as a framebuffer-attachable image
    for generalized offscreen rendering and it also provides a means to
    support rendering to GL logical buffer types which have no
    corresponding texture format (stencil, accum, etc).  A renderbuffer
    is similar to a texture in that both renderbuffers and textures can
    be independently allocated and shared among multiple contexts.  The
    framework defined by this extension is general enough that support
    for attaching images from GL objects other than textures and
    renderbuffers could be added by layered extensions.

    To facilitate efficient switching between collections of
    framebuffer-attachable images, this extension introduces another new
    GL object, called a framebuffer object.  A framebuffer object
    contains the state that defines the traditional GL framebuffer,
    including its set of images.  Prior to this extension, it was the
    window-system which defined and managed this collection of images,
    traditionally by grouping them into a "drawable".  The window-system
    API's would also provide a function (i.e., wglMakeCurrent,
    glXMakeCurrent, aglSetDrawable, etc.) to bind a drawable with a GL
    context (as is done in the WGL_ARB_pbuffer extension).  In this
    extension however, this functionality is subsumed by the GL and the
    GL provides the function BindFramebufferEXT to bind a framebuffer
    object to the current context.  Later, the context can bind back to
    the window-system-provided framebuffer in order to display rendered
    content.

    Previous extensions that enabled rendering to a texture have been
    much more complicated.  One example is the combination of
    ARB_pbuffer and ARB_render_texture, both of which are window-system
    extensions.  This combination requires calling MakeCurrent, an
    operation that may be expensive, to switch between the window and
    the pbuffer drawables.  An application must create one pbuffer per
    renderable texture in order to portably use ARB_render_texture.  An
    application must maintain at least one GL context per texture
    format, because each context can only operate on a single
    pixelformat or FBConfig.  All of these characteristics make
    ARB_render_texture both inefficient and cumbersome to use.

    EXT_framebuffer_object, on the other hand, is both simpler to use
    and more efficient than ARB_render_texture.  The
    EXT_framebuffer_object API is contained wholly within the GL API and
    has no (non-portable) window-system components.  Under
    EXT_framebuffer_object, it is not necessary to create a second GL
    context when rendering to a texture image whose format differs from
    that of the window.  Finally, unlike the pbuffers of
    ARB_render_texture, a single framebuffer object can facilitate
    rendering to an unlimited number of texture objects.

Glossary of Helpful Terms

        logical buffer:
            One of the color, depth, or stencil buffers of the
            framebuffer.

        framebuffer:
            The collection of logical buffers and associated state
            defining where the output of GL rendering is directed.

        texture:
            an object which consists of one or more 2D arrays of pixel
            images and associated state that can be used as a source of
            data during the texture-mapping process described in section
            3.8.

        texture image:
            one of the 2D arrays of pixels that are part of a texture
            object as defined in section 3.8.  Texture images contain
            and define the texels of the texture object.

        renderbuffer:
            A new type of storage object which contains a single 2D
            array of pixels and associated state that can be used as a
            destination for pixel data written during the rendering
            process described in Chapter 4.

        renderbuffer image:
            The 2D array of pixels that is part of a renderbuffer
            object.  A renderbuffer image contains and defines the
            pixels of the renderbuffer object.

        framebuffer-attachable image:
            A 2D pixel image that can be attached to one of the logical
            buffer attachment points of a framebuffer object.  Texture
            images and renderbuffer images are two examples of
            framebuffer-attachable images.

        attachment point:
            The set of state which references a specific
            framebuffer-attachable image, and allows that
            framebuffer-attachable image to be used to store the
            contents of a logical buffer of a framebuffer object.  There
            is an attachment point state vector for each color, depth,
            and stencil buffer of a framebuffer.

        attach:
            The act of connecting one object to another object.

            An "attach" operation is similar to a "bind" operation in
            that both represent a reference to the attached or bound
            object for the purpose of managing object lifetimes and both
            enable manipulation of the state of the attached or bound
            object.

            However, an "attach" is also different from a "bind" in that
            "binding" an unused object creates a new object, while
            "attaching" does not.  Additionally, "bind" establishes a
            connection between a context and an object, while "attach"
            establishes a connection between two objects.

            Finally, if object "A" is attached to object "B" and object
            "B" is bound to context "C", then in most respects, we treat
            "A" as if it is <implicitly> bound to "C".

        framebuffer attachment completeness:
            Similar to texture "mipmap" or "cube" completeness from
            section 3.8.10, defines a minimum set of criteria for
            framebuffer attachment points.  (for complete definition,
            see section 4.4.4.1)

        framebuffer completeness:
            Similar to texture "mipmap cube completeness", defines a
            composite set of "completeness" requirements and
            relationships among the attached framebuffer-attachable
            images.  (for complete definition, see section 4.4.4.2)


Issues

    Breaking from past convention, the very large issues section has
    been moved to the end of the document.  It can be found after
    Examples, before Revision History.


New Procedures and Functions

    boolean IsRenderbufferEXT(uint renderbuffer);
    void BindRenderbufferEXT(enum target, uint renderbuffer);
    void DeleteRenderbuffersEXT(sizei n, const uint *renderbuffers);
    void GenRenderbuffersEXT(sizei n, uint *renderbuffers);

    void RenderbufferStorageEXT(enum target, enum internalformat,
                                sizei width, sizei height);

    void GetRenderbufferParameterivEXT(enum target, enum pname, int *params);

    boolean IsFramebufferEXT(uint framebuffer);
    void BindFramebufferEXT(enum target, uint framebuffer);
    void DeleteFramebuffersEXT(sizei n, const uint *framebuffers);
    void GenFramebuffersEXT(sizei n, uint *framebuffers);

    enum CheckFramebufferStatusEXT(enum target);

    void FramebufferTexture1DEXT(enum target, enum attachment,
                                 enum textarget, uint texture,
                                 int level);
    void FramebufferTexture2DEXT(enum target, enum attachment,
                                 enum textarget, uint texture,
                                 int level);
    void FramebufferTexture3DEXT(enum target, enum attachment,
                                 enum textarget, uint texture,
                                 int level, int zoffset);

    void FramebufferRenderbufferEXT(enum target, enum attachment,
                                    enum renderbuffertarget, uint renderbuffer);

    void GetFramebufferAttachmentParameterivEXT(enum target, enum attachment,
                                                enum pname, int *params);

    void GenerateMipmapEXT(enum target);


New Types

    None.


New Tokens


        FRAMEBUFFER_EXT                     0x8D40


        RENDERBUFFER_EXT                    0x8D41


        STENCIL_INDEX1_EXT                  0x8D46
        STENCIL_INDEX4_EXT                  0x8D47
        STENCIL_INDEX8_EXT                  0x8D48
        STENCIL_INDEX16_EXT                 0x8D49


        RENDERBUFFER_WIDTH_EXT              0x8D42
        RENDERBUFFER_HEIGHT_EXT             0x8D43
        RENDERBUFFER_INTERNAL_FORMAT_EXT    0x8D44
        RENDERBUFFER_RED_SIZE_EXT           0x8D50
        RENDERBUFFER_GREEN_SIZE_EXT         0x8D51
        RENDERBUFFER_BLUE_SIZE_EXT          0x8D52
        RENDERBUFFER_ALPHA_SIZE_EXT         0x8D53
        RENDERBUFFER_DEPTH_SIZE_EXT         0x8D54
        RENDERBUFFER_STENCIL_SIZE_EXT       0x8D55


        FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT            0x8CD0
        FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT            0x8CD1
        FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT          0x8CD2
        FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT  0x8CD3
        FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT     0x8CD4


        COLOR_ATTACHMENT0_EXT                0x8CE0
        COLOR_ATTACHMENT1_EXT                0x8CE1
        COLOR_ATTACHMENT2_EXT                0x8CE2
        COLOR_ATTACHMENT3_EXT                0x8CE3
        COLOR_ATTACHMENT4_EXT                0x8CE4
        COLOR_ATTACHMENT5_EXT                0x8CE5
        COLOR_ATTACHMENT6_EXT                0x8CE6
        COLOR_ATTACHMENT7_EXT                0x8CE7
        COLOR_ATTACHMENT8_EXT                0x8CE8
        COLOR_ATTACHMENT9_EXT                0x8CE9
        COLOR_ATTACHMENT10_EXT               0x8CEA
        COLOR_ATTACHMENT11_EXT               0x8CEB
        COLOR_ATTACHMENT12_EXT               0x8CEC
        COLOR_ATTACHMENT13_EXT               0x8CED
        COLOR_ATTACHMENT14_EXT               0x8CEE
        COLOR_ATTACHMENT15_EXT               0x8CEF
        DEPTH_ATTACHMENT_EXT                 0x8D00
        STENCIL_ATTACHMENT_EXT               0x8D20


        FRAMEBUFFER_COMPLETE_EXT                          0x8CD5
        FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT             0x8CD6
        FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT     0x8CD7
        FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT             0x8CD9
        FRAMEBUFFER_INCOMPLETE_FORMATS_EXT                0x8CDA
        FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT            0x8CDB
        FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT            0x8CDC
        FRAMEBUFFER_UNSUPPORTED_EXT                       0x8CDD


        FRAMEBUFFER_BINDING_EXT             0x8CA6
        RENDERBUFFER_BINDING_EXT            0x8CA7
        MAX_COLOR_ATTACHMENTS_EXT           0x8CDF
        MAX_RENDERBUFFER_SIZE_EXT           0x84E8


        INVALID_FRAMEBUFFER_OPERATION_EXT   0x0506

