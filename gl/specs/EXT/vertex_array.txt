Name

    EXT_vertex_array

Name Strings

    GL_EXT_vertex_array

Version

    $Date: 1995/10/03 05:39:58 $ $Revision: 1.16 $  FINAL

Number

    30

Dependencies

    None

Overview

    This extension adds the ability to specify multiple geometric primitives
    with very few subroutine calls.  Instead of calling an OpenGL procedure
    to pass each individual vertex, normal, or color, separate arrays
    of vertexes, normals, and colors are prespecified, and are used to
    define a sequence of primitives (all of the same type) when a single
    call is made to DrawArraysEXT.  A stride mechanism is provided so that
    an application can choose to keep all vertex data staggered in a
    single array, or sparsely in separate arrays.  Single-array storage
    may optimize performance on some implementations.

    This extension also supports the rendering of individual array elements,
    each specified as an index into the enabled arrays.

Issues

    *   Should arrays for material parameters be provided?  If so, how?

        A: No.  Let's leave this to a separate extension, and keep this
           extension lean.

    *   Should a FORTRAN interface be specified in this document?

    *   It may not be possible to implement GetPointervEXT in FORTRAN.  If
        not, should we eliminate it from this proposal?

        A: Leave it in.

    *   Should a stride be specified by DrawArraysEXT which, if non-zero,
        would override the strides specified for the individual arrays?
        This might improve the efficiency of single-array transfers.

        A: No, it's not worth the effort and complexity.

    *   Should entry points for byte vertexes, byte indexes, and byte
        texture coordinates be added in this extension?

        A: No, do this in a separate extension, which defines byte support
           for arrays and for the current procedural interface.

    *   Should support for meshes (not strips) of rectangles be provided?

        A: No. If this is necessary, define a separate quad_mesh extension
           that supports both immediate mode and arrays.  (Add QUAD_MESH_EXT
           as an token accepted by Begin and DrawArraysEXT.  Add
           QuadMeshLengthEXT to specify the length of the mesh.)

Reasoning

    *   DrawArraysEXT requires that VERTEX_ARRAY_EXT be enabled so that
        future extensions can support evaluation as well as direct
        specification of vertex coordinates.

    *   This extension does not support evaluation.  It could be extended
        to provide such support by adding arrays of points to be evaluated,
        and by adding enables to indicate that the arrays are to be
        evaluated.  I think we may choose to add an array version of
        EvalMesh, rather than extending the operation of DrawArraysEXT,
        so I'd rather wait on this one.

    *   <size> is specified before <type> to match the order of the
        information in immediate mode commands, such as Vertex3f.
        (first 3, then f)

    *   It seems reasonable to allow attribute values to be undefined after
        DrawArraysEXT executes.  This avoids implementation overhead in
        the case where an incomplete primitive is specified, and will allow
        optimization on multiprocessor systems.  I don't expect this to be
        a burden to programmers.

    *   It is not an error to call VertexPointerEXT, NormalPointerEXT,
        ColorPointerEXT, IndexPointerEXT, TexCoordPointerEXT,
        or EdgeFlagPointerEXT between the execution of Begin and the
        corresponding execution of End.  Because these commands will
        typically be implemented on the client side with no protocol,
        testing for between-Begin-End status requires that the client
        track this state, or that a round trip be made.  Neither is
        desirable.

    *   Arrays are enabled and disabled individually, rather than with a
        single mask parameter, for two reasons.  First, we have had trouble
        allocating bits in masks, so eliminating a mask eliminates potential
        trouble down the road.  We may eventually require a larger number of
        array types than there are bits in a mask.  Second, making the
        enables into state eliminates a parameter in ArrayElementEXT, and
        may allow it to execute more efficiently.  Of course this state
        model may result in programming errors, but OpenGL is full of such
        hazards anyway!

    *   ArrayElementEXT is provided to support applications that construct
        primitives by indexing vertex data, rather than by streaming through
        arrays of data in first-to-last order.  Because each call specifies
        only a single vertex, it is possible for an application to explicitly
        specify per-primitive attributes, such as a single normal per
        individual triangle.

    *   The <count> parameters are added to the *PointerEXT commands to
        allow implementations to cache array data, and in particular to
        cache the transformed results of array data that are rendered
        repeatedly by ArrayElementEXT.  Implementations that do not wish
        to perform such caching can ignore the <count> parameter.

    *   The <first> parameter of DrawArraysEXT allows a single set of
        arrays to be used repeatedly, possibly improving performance.

New Procedures and Functions

    void ArrayElementEXT(int i);

    void DrawArraysEXT(enum mode,
                       int first,
                       sizei count);

    void VertexPointerEXT(int size,
                          enum type,
                          sizei stride,
                          sizei count,
                          const void* pointer);

    void NormalPointerEXT(enum type,
                          sizei stride,
                          sizei count,
                          const void* pointer);

    void ColorPointerEXT(int size,
                         enum type,
                         sizei stride,
                         sizei count,
                         const void* pointer);

    void IndexPointerEXT(enum type,
                         sizei stride,
                         sizei count,
                         const void* pointer);

    void TexCoordPointerEXT(int size,
                            enum type,
                            sizei stride,
                            sizei count,
                            const void* pointer);

    void EdgeFlagPointerEXT(sizei stride,
                            sizei count,
                            const Boolean* pointer);

    void GetPointervEXT(enum pname,
                       void** params);

New Tokens


        VERTEX_ARRAY_EXT               0x8074
        NORMAL_ARRAY_EXT               0x8075
        COLOR_ARRAY_EXT                0x8076
        INDEX_ARRAY_EXT                0x8077
        TEXTURE_COORD_ARRAY_EXT        0x8078
        EDGE_FLAG_ARRAY_EXT            0x8079


        DOUBLE_EXT                     0x140A


        VERTEX_ARRAY_SIZE_EXT          0x807A
        VERTEX_ARRAY_TYPE_EXT          0x807B
        VERTEX_ARRAY_STRIDE_EXT        0x807C
        VERTEX_ARRAY_COUNT_EXT         0x807D
        NORMAL_ARRAY_TYPE_EXT          0x807E
        NORMAL_ARRAY_STRIDE_EXT        0x807F
        NORMAL_ARRAY_COUNT_EXT         0x8080
        COLOR_ARRAY_SIZE_EXT           0x8081
        COLOR_ARRAY_TYPE_EXT           0x8082
        COLOR_ARRAY_STRIDE_EXT         0x8083
        COLOR_ARRAY_COUNT_EXT          0x8084
        INDEX_ARRAY_TYPE_EXT           0x8085
        INDEX_ARRAY_STRIDE_EXT         0x8086
        INDEX_ARRAY_COUNT_EXT          0x8087
        TEXTURE_COORD_ARRAY_SIZE_EXT   0x8088
        TEXTURE_COORD_ARRAY_TYPE_EXT   0x8089
        TEXTURE_COORD_ARRAY_STRIDE_EXT 0x808A
        TEXTURE_COORD_ARRAY_COUNT_EXT  0x808B
        EDGE_FLAG_ARRAY_STRIDE_EXT     0x808C
        EDGE_FLAG_ARRAY_COUNT_EXT      0x808D


        VERTEX_ARRAY_POINTER_EXT       0x808E
        NORMAL_ARRAY_POINTER_EXT       0x808F
        COLOR_ARRAY_POINTER_EXT        0x8090
        INDEX_ARRAY_POINTER_EXT        0x8091
        TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
        EDGE_FLAG_ARRAY_POINTER_EXT    0x8093

