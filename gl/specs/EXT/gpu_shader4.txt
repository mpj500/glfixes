Name

    EXT_gpu_shader4

Name Strings

    GL_EXT_gpu_shader4

Contact

    Barthold Lichtenbelt, NVIDIA (blichtenbelt 'at' nvidia.com)
    Pat Brown, NVIDIA (pbrown 'at' nvidia.com)

Status

    Multi vendor extension
 
    Shipping for GeForce 8 Series (November 2006) 

Version

    Last Modified Date:         12/14/2009
    Author revision:            16

Number

    326

Dependencies

    OpenGL 2.0 is required.

    This extension is written against the OpenGL 2.0 specification and version
    1.10.59 of the OpenGL Shading Language specification.

    This extension trivially interacts with ARB_texture_rectangle.

    This extension trivially interacts with GL_EXT_texture_array.

    This extension trivially interacts with GL_EXT_texture_integer.

    This extension trivially interacts with GL_EXT_geometry_shader4

    This extension trivially interacts with GL_EXT_texture_buffer_object.

    NV_primitive_restart trivially affects the definition of this extension.

    ARB_color_buffer_float affects the definition of this extension.
    EXT_draw_instanced affects the definition of this extension.

Overview

    This extension provides a set of new features to the OpenGL Shading
    Language and related APIs to support capabilities of new hardware. In
    particular, this extension provides the following functionality:

       * New texture lookup functions are provided that allow shaders to
         access individual texels using integer coordinates referring to the
         texel location and level of detail. No filtering is performed. These
         functions allow applications to use textures as one-, two-, and
         three-dimensional arrays.

       * New texture lookup functions are provided that allow shaders to query
         the dimensions of a specific level-of-detail image of a texture
         object.

       * New texture lookup functions variants are provided that allow shaders
         to pass a constant integer vector used to offset the texel locations
         used during the lookup to assist in custom texture filtering
         operations.

       * New texture lookup functions are provided that allow shaders to
         access one- and two-dimensional array textures. The second, or third,
         coordinate is used to select the layer of the array to access.

       * New "Grad" texture lookup functions are provided that allow shaders
         to explicitely pass in derivative values which are used by the GL to
         compute the level-of-detail when performing a texture lookup.

       * A new texture lookup function is provided to access a buffer texture.

       * The existing absolute LOD texture lookup functions are no longer
         restricted to the vertex shader only.

       * The ability to specify and use cubemap textures with a
         DEPTH_COMPONENT internal format. This also enables shadow mapping on
         cubemaps. The 'q' coordinate is used as the reference value for
         comparisons. A set of new texture lookup functions is provided to
         lookup into shadow cubemaps.

       * The ability to specify if varying variables are interpolated in a
         non-perspective correct manner, if they are flat shaded or, if
         multi-sampling, if centroid sampling should be performed.

       * Full signed integer and unsigned integer support in the OpenGL
         Shading Language:

             - Integers are defined as 32 bit values using two's complement.

             - Unsigned integers and vectors thereof are added.

             - New texture lookup functions are provided that return integer
               values. These functions are to be used in conjunction with new
               texture formats whose components are actual integers, rather
               than integers that encode a floating-point value. To support
               these lookup functions, new integer and unsigned-integer
               sampler types are introduced.

             - Integer bitwise operators are now enabled.

             - Several built-in functions and operators now operate on
               integers or vectors of integers.

             - New vertex attribute functions are added that load integer
               attribute data and can be referenced in a vertex shader as
               integer data.

             - New uniform loading commands are added to load unsigned integer
               data.

             - Varying variables can now be (unsigned) integers. If declared
               as such, they have to be flat shaded.

             - Fragment shaders can define their own output variables, and
               declare them to be of type floating-point, integer or unsigned
               integer. These variables are bound to a fragment color index
               with the new API command BindFragDataLocationEXT(), and directed
               to buffers using the existing DrawBuffer or DrawBuffers API
               commands.

       * Added new built-in functions truncate() and round() to the shading
         language.

       * A new built-in variable accessible from within vertex shaders that
         holds the index <i> implicitly passed to ArrayElement to specify the
         vertex. This is called the vertex ID.

       * A new built-in variable accessible from within fragment and geometry
         shaders that hold the index of the currently processed
         primitive. This is called the primitive ID.

    This extension also briefly mentions a new shader type, called a geometry
    shader. A geometry shader is run after vertices are transformed, but
    before clipping. A geometry shader begins with a single primitive (point,
    line, triangle. It can read the attributes of any of the vertices in the
    primitive and use them to generate new primitives. A geometry shader has a
    fixed output primitive type (point, line strip, or triangle strip) and
    emits vertices to define a new primitive. Geometry shaders are discussed
    in detail in the GL_EXT_geometry_shader4 specification.

New Procedures and Functions

    void VertexAttribI1iEXT(uint index, int x);
    void VertexAttribI2iEXT(uint index, int x, int y);
    void VertexAttribI3iEXT(uint index, int x, int y, int z);
    void VertexAttribI4iEXT(uint index, int x, int y, int z, int w);

    void VertexAttribI1uiEXT(uint index, uint x);
    void VertexAttribI2uiEXT(uint index, uint x, uint y);
    void VertexAttribI3uiEXT(uint index, uint x, uint y, uint z);
    void VertexAttribI4uiEXT(uint index, uint x, uint y, uint z,
                            uint w);

    void VertexAttribI1ivEXT(uint index, const int *v);
    void VertexAttribI2ivEXT(uint index, const int *v);
    void VertexAttribI3ivEXT(uint index, const int *v);
    void VertexAttribI4ivEXT(uint index, const int *v);

    void VertexAttribI1uivEXT(uint index, const uint *v);
    void VertexAttribI2uivEXT(uint index, const uint *v);
    void VertexAttribI3uivEXT(uint index, const uint *v);
    void VertexAttribI4uivEXT(uint index, const uint *v);

    void VertexAttribI4bvEXT(uint index, const byte *v);
    void VertexAttribI4svEXT(uint index, const short *v);
    void VertexAttribI4ubvEXT(uint index, const ubyte *v);
    void VertexAttribI4usvEXT(uint index, const ushort *v);

    void VertexAttribIPointerEXT(uint index, int size, enum type,
                                sizei stride, const void *pointer);

    void GetVertexAttribIivEXT(uint index, enum pname, int *params);
    void GetVertexAttribIuivEXT(uint index, enum pname,
                               uint *params);

    void Uniform1uiEXT(int location, uint v0);
    void Uniform2uiEXT(int location, uint v0, uint v1);
    void Uniform3uiEXT(int location, uint v0, uint v1, uint v2);
    void Uniform4uiEXT(int location, uint v0, uint v1, uint v2,
                      uint v3);

    void Uniform1uivEXT(int location, sizei count, const uint *value);
    void Uniform2uivEXT(int location, sizei count, const uint *value);
    void Uniform3uivEXT(int location, sizei count, const uint *value);
    void Uniform4uivEXT(int location, sizei count, const uint *value);

    void GetUniformuivEXT(uint program, int location, uint *params);

    void BindFragDataLocationEXT(uint program, uint colorNumber,
                                const char *name);
    int GetFragDataLocationEXT(uint program, const char *name);

New Tokens


      VERTEX_ATTRIB_ARRAY_INTEGER_EXT                    0x88FD


      SAMPLER_1D_ARRAY_EXT                               0x8DC0
      SAMPLER_2D_ARRAY_EXT                               0x8DC1
      SAMPLER_BUFFER_EXT                                 0x8DC2
      SAMPLER_1D_ARRAY_SHADOW_EXT                        0x8DC3
      SAMPLER_2D_ARRAY_SHADOW_EXT                        0x8DC4
      SAMPLER_CUBE_SHADOW_EXT                            0x8DC5
      UNSIGNED_INT                                       0x1405
      UNSIGNED_INT_VEC2_EXT                              0x8DC6
      UNSIGNED_INT_VEC3_EXT                              0x8DC7
      UNSIGNED_INT_VEC4_EXT                              0x8DC8
      INT_SAMPLER_1D_EXT                                 0x8DC9
      INT_SAMPLER_2D_EXT                                 0x8DCA
      INT_SAMPLER_3D_EXT                                 0x8DCB
      INT_SAMPLER_CUBE_EXT                               0x8DCC
      INT_SAMPLER_2D_RECT_EXT                            0x8DCD
      INT_SAMPLER_1D_ARRAY_EXT                           0x8DCE
      INT_SAMPLER_2D_ARRAY_EXT                           0x8DCF
      INT_SAMPLER_BUFFER_EXT                             0x8DD0
      UNSIGNED_INT_SAMPLER_1D_EXT                        0x8DD1
      UNSIGNED_INT_SAMPLER_2D_EXT                        0x8DD2
      UNSIGNED_INT_SAMPLER_3D_EXT                        0x8DD3
      UNSIGNED_INT_SAMPLER_CUBE_EXT                      0x8DD4
      UNSIGNED_INT_SAMPLER_2D_RECT_EXT                   0x8DD5
      UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT                  0x8DD6
      UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT                  0x8DD7
      UNSIGNED_INT_SAMPLER_BUFFER_EXT                    0x8DD8


      MIN_PROGRAM_TEXEL_OFFSET_EXT                       0x8904
      MAX_PROGRAM_TEXEL_OFFSET_EXT                       0x8905

