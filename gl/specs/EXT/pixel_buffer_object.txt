Name

    EXT_pixel_buffer_object

Name Strings

    GL_EXT_pixel_buffer_object

Status

    Implemented by NVIDIA drivers (Release 55).

Contributors

    Ralf Biermann
    Derek Cornish
    Matt Craighead
    Bill Licea-Kane
    Brian Paul

Contact

    Ralf Biermann, NVIDIA Corporation (rbiermann 'at' nvidia.com)
    Derek Cornish, NVIDIA Corporation (dcornish 'at' nvidia.com)

IP Status

    Unknown.

Version

    NVIDIA Date: March 29, 2004 (version 1.0)

Number

    302

Status

    NVIDIA Release 55 (early 2004) drivers support this extension.

Dependencies

    Written based on the wording of the OpenGL 1.5 specification.

    GL_NV_pixel_data_range affects the definition of this extension.

Overview

    This extension expands on the interface provided by buffer objects.
    It is intended to permit buffer objects to be used not only with 
    vertex array data, but also with pixel data.
    Buffer objects were promoted from the ARB_vertex_buffer_object
    extension in OpenGL 1.5.

    Recall that buffer objects conceptually are nothing more than arrays
    of bytes, just like any chunk of memory. Buffer objects allow GL
    commands to source data from a buffer object by binding the buffer
    object to a given target and then overloading a certain set of GL
    commands' pointer arguments to refer to offsets inside the buffer,
    rather than pointers to user memory.  An offset is encoded in a
    pointer by adding the offset to a null pointer.

    This extension does not add any new functionality to buffer
    objects themselves.  It simply adds two new targets to which buffer
    objects can be bound: PIXEL_PACK_BUFFER and PIXEL_UNPACK_BUFFER.
    When a buffer object is bound to the PIXEL_PACK_BUFFER target,
    commands such as ReadPixels write their data into a buffer object.
    When a buffer object is bound to the PIXEL_UNPACK_BUFFER target,
    commands such as DrawPixels read their data from a buffer object.

    There are a wide variety of applications for such functionality.
    Some of the most interesting ones are:

    - "Render to vertex array."  The application can use a fragment
      program to render some image into one of its buffers, then read
      this image out into a buffer object via ReadPixels.  Then, it can
      use this buffer object as a source of vertex data.

    - Streaming textures.  If the application uses MapBuffer/UnmapBuffer
      to write its data for TexSubImage into a buffer object, at least
      one of the data copies usually required to download a texture can
      be eliminated, significantly increasing texture download
      performance.

    - Asynchronous ReadPixels.  If an application needs to read back a
      number of images and process them with the CPU, the existing GL
      interface makes it nearly impossible to pipeline this operation.
      The driver will typically send the hardware a readback command
      when ReadPixels is called, and then wait for all of the data to
      be available before returning control to the application.  Then,
      the application can either process the data immediately or call
      ReadPixels again; in neither case will the readback overlap with
      the processing.  If the application issues several readbacks into
      several buffer objects, however, and then maps each one to process
      its data, then the readbacks can proceed in parallel with the data
      processing.

Issues

    How does this extension relate to ARB_vertex_buffer_object?

        It builds on the ARB_vertex_buffer_object framework by adding
        two new targets that buffers can be bound to.

    How does this extension relate to NV_pixel_data_range?

        This extension relates to NV_pixel_data_range in the same way that
        ARB_vertex_buffer_object relates to NV_vertex_array_range. To
        paraphrase the ARB_vertex_buffer_object spec, here are the main
        differences:

        - Applications are no longer responsible for memory management
          and synchronization.

        - Applications may still access high-performance memory directly,
          but this is optional, and such access is more restricted.

        - Buffer changes (BindBuffer) are generally expected to
          be very lightweight, rather than extremely heavyweight
          (PixelDataRangeNV).

        - A platform-specific allocator such as wgl/glXAllocateMemoryNV
          is no longer required.

    Can a given buffer be used for both vertex and pixel data?

        RESOLVED: YES.  All buffers can be used with all buffer bindings,
        in whatever combinations the application finds useful.  Consider
        yourself warned, however, by the following issue.

    May implementations make use of the target as a hint to select an
    appropriate memory space for the buffer?

        RESOLVED: YES, as long as such behavior is transparent to the
        application. Some implementations may choose, for example,
        that they would rather stream vertex data from write-combined
        system memory, element (or index) data from video memory, and
        pixel data from video memory.

        In fact, one can imagine arbitrarily complicated heuristics for
        selecting the memory space, based on factors such as the target,
        the "usage" argument, and the application's observed behavior.

        While it is entirely legal to create a buffer object by binding
        it to ARRAY_BUFFER and loading it with data, then using it with
        the PIXEL_UNPACK_BUFFER_EXT or PIXEL_PACK_BUFFER_EXT binding, such
        behavior is liable to confuse the driver and may hurt performance.
        If the driver implemented the hypothetical heuristic described
        earlier, such a buffer might have already been located in
        write-combined system memory, and so the driver would have to
        choose between two bad options: relocate the buffer into video
        memory, or accept lower performance caused by streaming pixel
        data from slower system memory.

    Should all pixel path commands be supported, or just a subset of
    them?

        RESOLVED: ALL.  While there is little reason to believe that,
        say, ConvolutionFilter2D would benefit from this extension, there
        is no reason _not_ to support it.  The full list of commands
        affected by this extension is listed in the spec.

    Should PixelMap and GetPixelMap be supported?

        RESOLVED: YES.  They're not really pixel path operations, but,
        again, there is no good reason to omit operations, and they _are_
        operations that pass around big chunks of pixel-related data.
        If we support PolygonStipple, surely we should support this.

    How does the buffer binding state push/pop?

        RESOLVED: As part of the pixel store client state.  This is
        analogous to how the vertex buffer object bindings pushed/popped
        as part of the vertex array client state.

    Should NV_pixel_data_range (PDR) be used concurrently with pixel
    buffer objects ?

        RESOLVED: NO. While it would be possible to allocate a memory
        range for PDR, using a pointer into this memory range with one
        of the commands affected by EXT_pixel_buffer_object will not
        work if a pixel buffer object other than zero is bound to the
        buffer binding point affecting the command. Pixel buffer objects
        always have higher precedence than PDR.

    Do the null pointer rules for glTexImage1D, glTexImage2D
    and glTexImage3D for allocating textures with undefined
    content also apply when a non-zero buffer object is bound to
    PIXEL_UNPACK_BUFFER_BINDING_EXT ?
        
        RESOLVED: NO. The null pointer is interpreted as a non-zero
        pointer to the data storage whose contents may be still
        undefined. This data will be used to create the texture array.
        If the null pointer rule is required, no non-zero buffer object
        should be bound to PIXEL_UNPACK_BUFFER_BINDING_EXT.

New Procedures and Functions

    None.

New Tokens


        PIXEL_PACK_BUFFER_EXT                        0x88EB
        PIXEL_UNPACK_BUFFER_EXT                      0x88EC


        PIXEL_PACK_BUFFER_BINDING_EXT                0x88ED
        PIXEL_UNPACK_BUFFER_BINDING_EXT              0x88EF


