Name

    EXT_texture_from_pixmap

Name Strings

    GLX_EXT_texture_from_pixmap

Contributors

    James Jones, NVIDIA
    Aaron Plattner, NVIDIA
    Andy Ritger, NVIDIA

Contact

    David Reveman, Novell, Inc. (davidr 'at' novell.com)

Status

    Complete

Version

    17 (10 Feb 2009)

Number

    344

Dependencies

    OpenGL 1.1 is required.
    GLX 1.3 is required.
    GL_EXT_framebuffer_object affects the definition of this extension.
    GL_ARB_texture_rectangle affects the definition of this extension.
    GL_ARB_texture_non_power_of_two affects the definition of this extension.
    GL_SGIS_generate_mipmap affects the definition of this extension.

Overview

    This extension allows a color buffer to be used for both rendering and
    texturing.

    Only color buffers of pixmaps can be used for texturing by this extension
    but other types of drawables can be supported by future extensions layered
    on top of this extension.

    The functionality of this extension is similar to WGL_ARB_render_texture. 
    However, the purpose of this extension is not to provide
    "render to texture" like functionality but rather the ability to bind
    an existing X drawable to a texture. Though, there is nothing that
    prohibits it from being used for "render to texture".

    -   Windows are problematic as they can change size and therefore are not
        supported by this extension.

    -   Only a color buffer of a GLX pixmap created using an FBConfig with
        attribute GLX_BIND_TO_TEXTURE_RGB_EXT or GLX_BIND_TO_TEXTURE_RGBA_EXT
        set to TRUE can be bound as a texture.

    -   The texture internal format is determined when the color buffer
        is associated with the texture, guaranteeing that the color 
        buffer format is equivalent to the texture internal format.

    -   A client can create a complete set of mipmap images if
        EXT_framebuffer_object is supported.


IP Status 

    There are no known IP issues. 

Issues

    1. What should this extension be called?

    Even though it is very similar to WGL_ARB_render_texture that name is
    not appropriate as the intention of this extension is not
    "render to texture" like functionality.

    EXT_texture_from_pixmap seams most appropriate. Layering of future
    extensions on top of this extension for using other type of drawables
    as textures follows the same conventions as vertex/pixel buffer objects
    and vertex/fragment programs.


    2. Should we allow applications to render to different mipmap levels and
    cube map faces?

    In order to discourage the use of this extension as a render to texture
    mechanism, cube maps and rendering directly to mip-map levels > 0 will
    not be supported.  A new FBConfig attribute is introduced that specifies
    whether or not drawables created with that config will support multiple
    mipmap levels when bound to a texture.  The other mipmap levels can be
    filled in by the EXT_framebuffer_object GenerateMipmapEXT function.

    Specifying which level of a pixmap was being rendered to on a per-drawable
    basis, as was done in the WGL_ARB_render_texture extension, also
    introduces concurrency issues.  The state of the drawable when it was
    being rendered two by two separate threads of execution and both were
    changing the mipmap level was difficult to define.

    It is also desireable to keep this extension as simple as possible.
    Adding functionality that complicates the implementation and that is not
    directly relevenat to the goal of exposing a mechanism for texturing from
    arbitrary X pixmaps is not productive.  If the ability to render directly
    to all levels of a texture is needed, EXT_framebuffer_object is the
    extension that should be used.


    3. Should 1D textures be supported?

    X servers layered on top of an OpenGL implementation might not be able
    to support this.  A new FBConfig attribute is introduced specifying
    which texture targets a drawable created with the given FBConfig can
    be bound to.


    4. What should the default value for GLX_TEXTURE_TARGET_EXT be?  Should
    users be required to set this value if GLX_TEXTURE_FORMAT_EXT is not
    GLX_TEXTURE_FORMAT_NONE_EXT?

    The implementation is capable of choosing a reasonable default, we simply
    need to specify the correct way to do so.  We can base the ordering on
    the properties of the pixmap and the texturing capabilities of the
    pixmap's FBConfig and the implementation.

    The order is:

    - If GL_ARB_texture_non_power_of_two is supported GL_TEXTURE_2D will
      be used for all pixmap sizes.

    - If only GL_ARB_texture_rectangle is supported GL_TEXTURE_2D will
      be used for all power of two pixmap sizes and GL_TEXTURE_RECTANGLE_ARB
      will be used for all non power of two pixmap sizes.


    5. Should users be required to re-bind the drawable to a texture after
    the drawable has been rendered to?

    It is difficult to define what the contents of the texture would be if
    we don't require this.  Also, requiring this would allow implementations
    to perform an implicit copy at this point if they could not support
    texturing directly out of renderable memory.

    The problem with defining the contents of the texture after rendering
    has occured to the associated drawable is that there is no way to
    synchronize the use of the buffer as a source and as a destination.
    Direct OpenGL rendering is not necessarily done in the same command
    stream as X rendering.  At the time the pixmap is used as the source
    for a texturing operation, it could be in a state halfway through a
    copyarea operation in which half of it is say, white, and half is the
    result of the copyarea operation.  How is this defined?  Worse, some
    other OpenGL application could be halfway through a frame of rendering
    when the composite manager sources from it.  The buffer might just
    contain the results of a "glClear" operation at that point.

    To gurantee tear-free rendering, a composite manager would run as follows:

    -receive request for compositing:
    XGrabServer()
    glXWaitX() or XSync()
    glXBindTexImageEXT()

    <Do rendering/compositing>

    glXReleaseTexImageEXT()
    XUngrabServer()

    Apps that don't synchronize like this would get what's available, 
    and that may or may not be what they expect.


    6. What is the result of calling GenerateMipmapEXT on a drawable that
    was not created with mipmap levels?

    The results are undefined.


    7. Rendering done by the window system may be y-inverted compared
    to the standard OpenGL texture representation.  More specifically:
    the X Window system uses a coordinate system where the origin is in
    the upper left; however, the GL uses a coordinate system where the
    origin is in the lower left.  Should we define the contents of the
    texture as the y-inverted contents of the drawable?

    X implementations may represent their drawables differently internally,
    so y-inversion should be exposed as an FBConfig attribute.
    Applications will need to query this attribute and adjust their rendering
    appropriately.

    If a drawables is y-inverted and is bound to a texture, the contents of the
    texture will be y-inverted with respect to the standard GL memory layout.
    This means the contents of a pixmap of size (width, height) at pixmap
    coordinate (x, y) will be at location (x, height-y-1) in the texture.
    Applications will need to adjust their texture coordinates accordingly to
    avoid drawing the texture contents upside down.


    8. Why wasn't this extension based on FBO instead of ARB_render_texture?
    Isn't the render_texture extension deprecated?

    At first glance, FBO may seem like the perfect framework to base a spec
    for texturing from pixmap surfaces on.  It replaced the
    WGL_ARB_render_texture specification, which provided a mechanism to
    texture from pbuffer surfaces.  However, this train of thought is another
    side effect of the unfortunate naming of the WGL_ARB_render_texture
    specification.  FBO and the orginal render_texture specification were
    two different solutions to the problem of how to render to and texture
    from the same surface.  WGL_ARB_render_texture provided a method to bind
    a texture to a drawable surface, as this extension does.  FBO provides the
    opposite solution, allowing rendering to arbitrary surfaces including
    textures.  In the case of FBO, the application doing the rendering knows
    that it needs to render to an alternate surface.  In our usage case, the
    application doing the rendering is arbitrary, and has no knowledge that another
    application wants to use the surface it is rendering to as a texture.  The
    only application able to name the surface is the one texturing from it.
    Therefore, it makes sense to provide a mechanism for binding a texture to
    an arbitrary surface in general, and a pixmap in this particular case.


    9. Why not allow binding directly to an X pixmap without creating an
    intermediate GLX pixmap?

    Architecturally, GLX has moved away from operating directly on X
    drawables.  This allows GLX specific attributes to be associated with the
    GLX drawables.  In this case, it is important to associate an FBConfig
    with the drawable.  The FBConfig contains attributes specifying the
    internal format the GL will use when utilizing the drawable's framebuffer
    as a texture.


New Procedures and Functions

    void glXBindTexImageEXT (Display     *display, 
                             GLXDrawable drawable, 
                             int         buffer,
                             const int   *attrib_list)

    void glXReleaseTexImageEXT (Display     *display, 
                                GLXDrawable drawable, 
                                int         buffer)


New Tokens


        GLX_BIND_TO_TEXTURE_RGB_EXT        0x20D0
        GLX_BIND_TO_TEXTURE_RGBA_EXT       0x20D1
        GLX_BIND_TO_MIPMAP_TEXTURE_EXT     0x20D2
        GLX_BIND_TO_TEXTURE_TARGETS_EXT    0x20D3
        GLX_Y_INVERTED_EXT                 0x20D4


        GLX_TEXTURE_FORMAT_EXT             0x20D5
        GLX_TEXTURE_TARGET_EXT             0x20D6
        GLX_MIPMAP_TEXTURE_EXT             0x20D7


        GLX_TEXTURE_FORMAT_NONE_EXT        0x20D8
        GLX_TEXTURE_FORMAT_RGB_EXT         0x20D9
        GLX_TEXTURE_FORMAT_RGBA_EXT        0x20DA


        GLX_TEXTURE_1D_BIT_EXT             0x00000001
        GLX_TEXTURE_2D_BIT_EXT             0x00000002
        GLX_TEXTURE_RECTANGLE_BIT_EXT      0x00000004


        GLX_TEXTURE_1D_EXT                 0x20DB
        GLX_TEXTURE_2D_EXT                 0x20DC
        GLX_TEXTURE_RECTANGLE_EXT          0x20DD


        GLX_FRONT_LEFT_EXT                 0x20DE
        GLX_FRONT_RIGHT_EXT                0x20DF
        GLX_BACK_LEFT_EXT                  0x20E0
        GLX_BACK_RIGHT_EXT                 0x20E1
        GLX_AUX0_EXT                       0x20E2
        GLX_AUX1_EXT                       0x20E3 
        GLX_AUX2_EXT                       0x20E4 
        GLX_AUX3_EXT                       0x20E5 
        GLX_AUX4_EXT                       0x20E6 
        GLX_AUX5_EXT                       0x20E7 
        GLX_AUX6_EXT                       0x20E8
        GLX_AUX7_EXT                       0x20E9 
        GLX_AUX8_EXT                       0x20EA 
        GLX_AUX9_EXT                       0x20EB




            1           CARD8                   opcode (X assigned)
            1           16                      GLX opcode (glXVendorPrivate)
            2           6+n                     request length
            4           1330                    vendor specific opcode
            4           CARD32                  context tag
            4           CARD32                  num_attributes

            1           CARD8           opcode (X assigned)
            1           16              GLX opcode (glXVendorPrivate)
            2           5               request length
            4           1331            vendor specific opcode
            4           CARD32          context tag



